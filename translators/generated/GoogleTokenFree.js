var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
				var args = [null];
				args.push.apply(args, arguments);
				var Ctor = Function.bind.apply(f, args);
				return new Ctor();
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var translators = {};

var BaseTranslator$1 = {};

var basicFetcher$1 = {};

/* eslint-disable no-prototype-builtins */
var g$2 =
  (typeof globalThis !== 'undefined' && globalThis) ||
  (typeof self !== 'undefined' && self) ||
  // eslint-disable-next-line no-undef
  (typeof global !== 'undefined' && global) ||
  {};

var support = {
  searchParams: 'URLSearchParams' in g$2,
  iterable: 'Symbol' in g$2 && 'iterator' in Symbol,
  blob:
    'FileReader' in g$2 &&
    'Blob' in g$2 &&
    (function() {
      try {
        new Blob();
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in g$2,
  arrayBuffer: 'ArrayBuffer' in g$2
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ];

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value}
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    };
  }

  return iterator
}

function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length)
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)];
};

Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null
};

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
};

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items)
};

Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items)
};

Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items)
};

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}

function consumed(body) {
  if (body._noBody) return
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : 'utf-8';
  reader.readAsText(blob, encoding);
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function(body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    // eslint-disable-next-line no-self-assign
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    };
  }

  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        )
      } else {
        return Promise.resolve(this._bodyArrayBuffer)
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer)
    } else {
      throw new Error('could not read as ArrayBuffer')
    }
  };

  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  };

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode$3)
    };
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  };

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }

  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || (function () {
    if ('AbortController' in g$2) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }());
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body);

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
      }
    }
  }
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
};

function decode$3(body) {
  var form = new FormData();
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers();
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders
    .split('\r')
    .map(function(header) {
      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
    })
    .forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        try {
          headers.append(key, value);
        } catch (error) {
          console.warn('Response ' + error.message);
        }
      }
    });
  return headers
}

Body.call(Request.prototype);

function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].")
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}

Body.call(Response.prototype);

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
};

Response.error = function() {
  var response = new Response(null, {status: 200, statusText: ''});
  response.ok = false;
  response.status = 0;
  response.type = 'error';
  return response
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
};

var DOMException$4 = g$2.DOMException;
try {
  new DOMException$4();
} catch (err) {
  DOMException$4 = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException$4.prototype = Object.create(Error.prototype);
  DOMException$4.prototype.constructor = DOMException$4;
}

function fetch$2(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException$4('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      // This check if specifically for when a user fetches a file locally from the file system
      // Only if the status is out of a normal range
      if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response(body, options));
      }, 0);
    };

    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'));
      }, 0);
    };

    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError('Network request timed out'));
      }, 0);
    };

    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException$4('Aborted', 'AbortError'));
      }, 0);
    };

    function fixUrl(url) {
      try {
        return url === '' && g$2.location.href ? g$2.location.href : url
      } catch (e) {
        return url
      }
    }

    xhr.open(request.method, fixUrl(request.url), true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob';
      } else if (
        support.arrayBuffer
      ) {
        xhr.responseType = 'arraybuffer';
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g$2.Headers && init.headers instanceof g$2.Headers))) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  })
}

fetch$2.polyfill = true;

if (!g$2.fetch) {
  g$2.fetch = fetch$2;
  g$2.Headers = Headers;
  g$2.Request = Request;
  g$2.Response = Response;
}

var fetch$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get DOMException () { return DOMException$4; },
	Headers: Headers,
	Request: Request,
	Response: Response,
	fetch: fetch$2
});

var fetch$1 = /*@__PURE__*/getAugmentedNamespace(fetch$3);

// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.

var fetchNpmBrowserify = self.fetch.bind(self);

var fetchNpmBrowserify$1 = /*@__PURE__*/getDefaultExportFromCjs(fetchNpmBrowserify);

"use strict";

Object.defineProperty(basicFetcher$1, "__esModule", {
  value: true
});
var convertHeadersToMap_1 = basicFetcher$1.convertHeadersToMap = basicFetcher_2 = basicFetcher$1.basicFetcher = void 0;

var __awaiter$a = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
const convertHeadersToMap = headers => {
  const map = new Map();
  headers.forEach((key, value) => {
    map.set(key, value);
  });
  return map;
};
/**
 * Basic implementation of API fetcher
 */
convertHeadersToMap_1 = basicFetcher$1.convertHeadersToMap = convertHeadersToMap;
const basicFetcher = (url, _a) => __awaiter$a(void 0, void 0, void 0, function* () {
  var {
      responseType
    } = _a,
    options = __rest(_a, ["responseType"]);
  return fetch(url, options).then(response => __awaiter$a(void 0, void 0, void 0, function* () {
    const data = yield response[responseType]();
    const {
      ok,
      status,
      statusText
    } = response;
    return {
      headers: convertHeadersToMap(response.headers),
      ok,
      status,
      statusText,
      data
    };
  }));
});
var basicFetcher_2 = basicFetcher$1.basicFetcher = basicFetcher;

"use strict";

Object.defineProperty(BaseTranslator$1, "__esModule", {
  value: true
});
var BaseTranslator_2 = BaseTranslator$1.BaseTranslator = void 0;
var _basicFetcher = basicFetcher$1;
var __awaiter$9 = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
// TODO: remove it and provide utils to implement translators
/**
 * Basic abstract class for translator
 */
class BaseTranslator {
  constructor(options) {
    this.options = {};
    this.fetch = (url, options) => __awaiter$9(this, void 0, void 0, function* () {
      var _a;
      const fetcher = (_a = this.options.fetcher) !== null && _a !== void 0 ? _a : _basicFetcher.basicFetcher;
      return fetcher(url, options);
    });
    if (options !== undefined) {
      this.options = options;
    }
  }
  checkLimitExceeding(text) {
    const plainText = Array.isArray(text) ? text.join('') : text;
    const extra = plainText.length - this.getLengthLimit();
    return extra > 0 ? extra : 0;
  }
}
BaseTranslator_2 = BaseTranslator$1.BaseTranslator = BaseTranslator;
BaseTranslator.translatorName = 'UnknownTranslator';
BaseTranslator.isRequiredKey = () => false;
BaseTranslator.isSupportedAutoFrom = () => false;
BaseTranslator.getSupportedLanguages = () => [];

var Translator = {};

"use strict";

Object.defineProperty(Translator, "__esModule", {
  value: true
});

var FakeTranslator$1 = {};

"use strict";

Object.defineProperty(FakeTranslator$1, "__esModule", {
  value: true
});
var FakeTranslator_2 = FakeTranslator$1.FakeTranslator = ErrorFakeTranslator_1 = FakeTranslator$1.ErrorFakeTranslator = void 0;
var _BaseTranslator$5 = BaseTranslator$1;
var __awaiter$8 = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable class-methods-use-this */
/* eslint-disable @typescript-eslint/require-await */

/**
 * Fake translator for use in tests and debug
 */
class FakeTranslator extends _BaseTranslator$5.BaseTranslator {
  static isSupportedAutoFrom() {
    return false;
  }
  static getSupportedLanguages() {
    return ['ru', 'en', 'de', 'ja'];
  }
  getLengthLimit() {
    return 3000;
  }
  getRequestsTimeout() {
    return 10;
  }
  checkDirection(from, to) {
    return from == 'ru' && to == 'ja' ? false : true;
  }
  translate(text, from, to) {
    const delay = this.options.delay === undefined ? 0 : this.options.delay === 'random' ? Math.floor(Math.random() * 1000) : this.options.delay;
    return new Promise(resolve => {
      setTimeout(() => {
        resolve(`*[${from}-${to}]` + text);
      }, delay);
    });
  }
  translateBatch(text, from, to) {
    return Promise.all(text.map(i => this.translate(i, from, to).catch(() => null)));
  }
}
FakeTranslator_2 = FakeTranslator$1.FakeTranslator = FakeTranslator;
FakeTranslator.translatorName = 'FakeTranslator';
/**
 * Fake translator which always throw error for use in tests and debug
 */
class ErrorFakeTranslator extends FakeTranslator {
  translate(_text, _from, _to) {
    return __awaiter$8(this, void 0, void 0, function* () {
      throw new Error('Fake error for translate method');
    });
  }
  translateBatch(_text, _from, _to) {
    return __awaiter$8(this, void 0, void 0, function* () {
      throw new Error('Fake error for translateBatch method');
    });
  }
}
var ErrorFakeTranslator_1 = FakeTranslator$1.ErrorFakeTranslator = ErrorFakeTranslator;
ErrorFakeTranslator.translatorName = 'FakeTranslator';

var MicrosoftTranslator$1 = {};

var zod = {};

var external$1 = {};

var core$5 = {};

var core$4 = {};

(function (exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.globalConfig = exports.$ZodEncodeError = exports.$ZodAsyncError = exports.$brand = exports.NEVER = void 0;
	exports.$constructor = $constructor;
	exports.config = config;
	/** A special constant with type `never` */
	exports.NEVER = Object.freeze({
	    status: "aborted",
	});
	function $constructor(name, initializer, params) {
	    function init(inst, def) {
	        var _a;
	        Object.defineProperty(inst, "_zod", {
	            value: inst._zod ?? {},
	            enumerable: false,
	        });
	        (_a = inst._zod).traits ?? (_a.traits = new Set());
	        inst._zod.traits.add(name);
	        initializer(inst, def);
	        // support prototype modifications
	        for (const k in _.prototype) {
	            if (!(k in inst))
	                Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
	        }
	        inst._zod.constr = _;
	        inst._zod.def = def;
	    }
	    // doesn't work if Parent has a constructor with arguments
	    const Parent = params?.Parent ?? Object;
	    class Definition extends Parent {
	    }
	    Object.defineProperty(Definition, "name", { value: name });
	    function _(def) {
	        var _a;
	        const inst = params?.Parent ? new Definition() : this;
	        init(inst, def);
	        (_a = inst._zod).deferred ?? (_a.deferred = []);
	        for (const fn of inst._zod.deferred) {
	            fn();
	        }
	        return inst;
	    }
	    Object.defineProperty(_, "init", { value: init });
	    Object.defineProperty(_, Symbol.hasInstance, {
	        value: (inst) => {
	            if (params?.Parent && inst instanceof params.Parent)
	                return true;
	            return inst?._zod?.traits?.has(name);
	        },
	    });
	    Object.defineProperty(_, "name", { value: name });
	    return _;
	}
	//////////////////////////////   UTILITIES   ///////////////////////////////////////
	exports.$brand = Symbol("zod_brand");
	class $ZodAsyncError extends Error {
	    constructor() {
	        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
	    }
	}
	exports.$ZodAsyncError = $ZodAsyncError;
	class $ZodEncodeError extends Error {
	    constructor(name) {
	        super(`Encountered unidirectional transform during encode: ${name}`);
	        this.name = "ZodEncodeError";
	    }
	}
	exports.$ZodEncodeError = $ZodEncodeError;
	exports.globalConfig = {};
	function config(newConfig) {
	    if (newConfig)
	        Object.assign(exports.globalConfig, newConfig);
	    return exports.globalConfig;
	} 
} (core$4));

var core$3 = /*@__PURE__*/getDefaultExportFromCjs(core$4);

var parse$4 = {};

var errors$6 = {};

var util$3 = {};

"use strict";
Object.defineProperty(util$3, "__esModule", { value: true });
var Class_1 = util$3.Class = BIGINT_FORMAT_RANGES = util$3.BIGINT_FORMAT_RANGES = NUMBER_FORMAT_RANGES = util$3.NUMBER_FORMAT_RANGES = primitiveTypes = util$3.primitiveTypes = propertyKeyTypes = util$3.propertyKeyTypes = getParsedType_1 = util$3.getParsedType = allowsEval = util$3.allowsEval = captureStackTrace = util$3.captureStackTrace = void 0;
var assertEqual_1 = util$3.assertEqual = assertEqual;
var assertNotEqual_1 = util$3.assertNotEqual = assertNotEqual;
var assertIs_1 = util$3.assertIs = assertIs;
var assertNever_1 = util$3.assertNever = assertNever;
var assert_1 = util$3.assert = assert;
var getEnumValues_1 = util$3.getEnumValues = getEnumValues;
var joinValues_1 = util$3.joinValues = joinValues;
var jsonStringifyReplacer_1 = util$3.jsonStringifyReplacer = jsonStringifyReplacer;
var cached_1 = util$3.cached = cached;
var nullish_1 = util$3.nullish = nullish;
var cleanRegex_1 = util$3.cleanRegex = cleanRegex;
var floatSafeRemainder_1 = util$3.floatSafeRemainder = floatSafeRemainder;
var defineLazy_1 = util$3.defineLazy = defineLazy;
var objectClone_1 = util$3.objectClone = objectClone;
var assignProp_1 = util$3.assignProp = assignProp;
var mergeDefs_1 = util$3.mergeDefs = mergeDefs;
var cloneDef_1 = util$3.cloneDef = cloneDef;
var getElementAtPath_1 = util$3.getElementAtPath = getElementAtPath;
var promiseAllObject_1 = util$3.promiseAllObject = promiseAllObject;
var randomString_1 = util$3.randomString = randomString;
var esc_1 = util$3.esc = esc;
var isObject_1 = util$3.isObject = isObject;
var isPlainObject_1 = util$3.isPlainObject = isPlainObject;
var shallowClone_1 = util$3.shallowClone = shallowClone;
var numKeys_1 = util$3.numKeys = numKeys;
var escapeRegex_1 = util$3.escapeRegex = escapeRegex;
var clone_1 = util$3.clone = clone;
var normalizeParams_1 = util$3.normalizeParams = normalizeParams;
var createTransparentProxy_1 = util$3.createTransparentProxy = createTransparentProxy;
var stringifyPrimitive_1 = util$3.stringifyPrimitive = stringifyPrimitive;
var optionalKeys_1 = util$3.optionalKeys = optionalKeys;
var pick_1 = util$3.pick = pick$1;
var omit_1 = util$3.omit = omit;
var extend_1 = util$3.extend = extend;
var safeExtend_1 = util$3.safeExtend = safeExtend;
var merge_1 = util$3.merge = merge;
var partial_1 = util$3.partial = partial;
var required_1 = util$3.required = required;
var aborted_1 = util$3.aborted = aborted;
var prefixIssues_1 = util$3.prefixIssues = prefixIssues;
var unwrapMessage_1 = util$3.unwrapMessage = unwrapMessage;
var finalizeIssue_1 = util$3.finalizeIssue = finalizeIssue;
var getSizableOrigin_1 = util$3.getSizableOrigin = getSizableOrigin;
var getLengthableOrigin_1 = util$3.getLengthableOrigin = getLengthableOrigin;
var issue_1 = util$3.issue = issue;
var cleanEnum_1 = util$3.cleanEnum = cleanEnum;
var base64ToUint8Array_1 = util$3.base64ToUint8Array = base64ToUint8Array;
var uint8ArrayToBase64_1 = util$3.uint8ArrayToBase64 = uint8ArrayToBase64;
var base64urlToUint8Array_1 = util$3.base64urlToUint8Array = base64urlToUint8Array;
var uint8ArrayToBase64url_1 = util$3.uint8ArrayToBase64url = uint8ArrayToBase64url;
var hexToUint8Array_1 = util$3.hexToUint8Array = hexToUint8Array;
var uint8ArrayToHex_1 = util$3.uint8ArrayToHex = uint8ArrayToHex;
// functions
function assertEqual(val) {
    return val;
}
function assertNotEqual(val) {
    return val;
}
function assertIs(_arg) { }
function assertNever(_x) {
    throw new Error();
}
function assert(_) { }
function getEnumValues(entries) {
    const numericValues = Object.values(entries).filter((v) => typeof v === "number");
    const values = Object.entries(entries)
        .filter(([k, _]) => numericValues.indexOf(+k) === -1)
        .map(([_, v]) => v);
    return values;
}
function joinValues(array, separator = "|") {
    return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
    if (typeof value === "bigint")
        return value.toString();
    return value;
}
function cached(getter) {
    const set = false;
    return {
        get value() {
            if (!set) {
                const value = getter();
                Object.defineProperty(this, "value", { value });
                return value;
            }
            throw new Error("cached value already set");
        },
    };
}
function nullish(input) {
    return input === null || input === undefined;
}
function cleanRegex(source) {
    const start = source.startsWith("^") ? 1 : 0;
    const end = source.endsWith("$") ? source.length - 1 : source.length;
    return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepString = step.toString();
    let stepDecCount = (stepString.split(".")[1] || "").length;
    if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
        const match = stepString.match(/\d?e-(\d?)/);
        if (match?.[1]) {
            stepDecCount = Number.parseInt(match[1]);
        }
    }
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
    let value = undefined;
    Object.defineProperty(object, key, {
        get() {
            if (value === EVALUATING) {
                // Circular reference detected, return undefined to break the cycle
                return undefined;
            }
            if (value === undefined) {
                value = EVALUATING;
                value = getter();
            }
            return value;
        },
        set(v) {
            Object.defineProperty(object, key, {
                value: v,
                // configurable: true,
            });
            // object[key] = v;
        },
        configurable: true,
    });
}
function objectClone(obj) {
    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
        value,
        writable: true,
        enumerable: true,
        configurable: true,
    });
}
function mergeDefs(...defs) {
    const mergedDescriptors = {};
    for (const def of defs) {
        const descriptors = Object.getOwnPropertyDescriptors(def);
        Object.assign(mergedDescriptors, descriptors);
    }
    return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
    return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
    if (!path)
        return obj;
    return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
    const keys = Object.keys(promisesObj);
    const promises = keys.map((key) => promisesObj[key]);
    return Promise.all(promises).then((results) => {
        const resolvedObj = {};
        for (let i = 0; i < keys.length; i++) {
            resolvedObj[keys[i]] = results[i];
        }
        return resolvedObj;
    });
}
function randomString(length = 10) {
    const chars = "abcdefghijklmnopqrstuvwxyz";
    let str = "";
    for (let i = 0; i < length; i++) {
        str += chars[Math.floor(Math.random() * chars.length)];
    }
    return str;
}
function esc(str) {
    return JSON.stringify(str);
}
var captureStackTrace = util$3.captureStackTrace = ("captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => { });
function isObject(data) {
    return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = util$3.allowsEval = cached(() => {
    // @ts-ignore
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
    }
    try {
        const F = Function;
        new F("");
        return true;
    }
    catch (_) {
        return false;
    }
});
function isPlainObject(o) {
    if (isObject(o) === false)
        return false;
    // modified constructor
    const ctor = o.constructor;
    if (ctor === undefined)
        return true;
    // modified prototype
    const prot = ctor.prototype;
    if (isObject(prot) === false)
        return false;
    // ctor doesn't have static `isPrototypeOf`
    if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
        return false;
    }
    return true;
}
function shallowClone(o) {
    if (isPlainObject(o))
        return { ...o };
    return o;
}
function numKeys(data) {
    let keyCount = 0;
    for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
            keyCount++;
        }
    }
    return keyCount;
}
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return "undefined";
        case "string":
            return "string";
        case "number":
            return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
            return "boolean";
        case "function":
            return "function";
        case "bigint":
            return "bigint";
        case "symbol":
            return "symbol";
        case "object":
            if (Array.isArray(data)) {
                return "array";
            }
            if (data === null) {
                return "null";
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return "promise";
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return "map";
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return "set";
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return "date";
            }
            // @ts-ignore
            if (typeof File !== "undefined" && data instanceof File) {
                return "file";
            }
            return "object";
        default:
            throw new Error(`Unknown data type: ${t}`);
    }
};
var getParsedType_1 = util$3.getParsedType = getParsedType;
var propertyKeyTypes = util$3.propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = util$3.primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
// zod-specific utils
function clone(inst, def, params) {
    const cl = new inst._zod.constr(def ?? inst._zod.def);
    if (!def || params?.parent)
        cl._zod.parent = inst;
    return cl;
}
function normalizeParams(_params) {
    const params = _params;
    if (!params)
        return {};
    if (typeof params === "string")
        return { error: () => params };
    if (params?.message !== undefined) {
        if (params?.error !== undefined)
            throw new Error("Cannot specify both `message` and `error` params");
        params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === "string")
        return { ...params, error: () => params.error };
    return params;
}
function createTransparentProxy(getter) {
    let target;
    return new Proxy({}, {
        get(_, prop, receiver) {
            target ?? (target = getter());
            return Reflect.get(target, prop, receiver);
        },
        set(_, prop, value, receiver) {
            target ?? (target = getter());
            return Reflect.set(target, prop, value, receiver);
        },
        has(_, prop) {
            target ?? (target = getter());
            return Reflect.has(target, prop);
        },
        deleteProperty(_, prop) {
            target ?? (target = getter());
            return Reflect.deleteProperty(target, prop);
        },
        ownKeys(_) {
            target ?? (target = getter());
            return Reflect.ownKeys(target);
        },
        getOwnPropertyDescriptor(_, prop) {
            target ?? (target = getter());
            return Reflect.getOwnPropertyDescriptor(target, prop);
        },
        defineProperty(_, prop, descriptor) {
            target ?? (target = getter());
            return Reflect.defineProperty(target, prop, descriptor);
        },
    });
}
function stringifyPrimitive(value) {
    if (typeof value === "bigint")
        return value.toString() + "n";
    if (typeof value === "string")
        return `"${value}"`;
    return `${value}`;
}
function optionalKeys(shape) {
    return Object.keys(shape).filter((k) => {
        return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
    });
}
var NUMBER_FORMAT_RANGES = util$3.NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-3.4028234663852886e38, 3.4028234663852886e38],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
};
var BIGINT_FORMAT_RANGES = util$3.BIGINT_FORMAT_RANGES = {
    int64: [/* @__PURE__*/ BigInt("-9223372036854775808"), /* @__PURE__*/ BigInt("9223372036854775807")],
    uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt("18446744073709551615")],
};
function pick$1(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const newShape = {};
            for (const key in mask) {
                if (!(key in currDef.shape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                    continue;
                newShape[key] = currDef.shape[key];
            }
            assignProp(this, "shape", newShape); // self-caching
            return newShape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function omit(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const newShape = { ...schema._zod.def.shape };
            for (const key in mask) {
                if (!(key in currDef.shape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                    continue;
                delete newShape[key];
            }
            assignProp(this, "shape", newShape); // self-caching
            return newShape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function extend(schema, shape) {
    if (!isPlainObject(shape)) {
        throw new Error("Invalid input to extend: expected a plain object");
    }
    const checks = schema._zod.def.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
        throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
    }
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function safeExtend(schema, shape) {
    if (!isPlainObject(shape)) {
        throw new Error("Invalid input to safeExtend: expected a plain object");
    }
    const def = {
        ...schema._zod.def,
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        checks: schema._zod.def.checks,
    };
    return clone(schema, def);
}
function merge(a, b) {
    const def = mergeDefs(a._zod.def, {
        get shape() {
            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        get catchall() {
            return b._zod.def.catchall;
        },
        checks: [], // delete existing checks
    });
    return clone(a, def);
}
function partial(Class, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const oldShape = schema._zod.def.shape;
            const shape = { ...oldShape };
            if (mask) {
                for (const key in mask) {
                    if (!(key in oldShape)) {
                        throw new Error(`Unrecognized key: "${key}"`);
                    }
                    if (!mask[key])
                        continue;
                    // if (oldShape[key]!._zod.optin === "optional") continue;
                    shape[key] = Class
                        ? new Class({
                            type: "optional",
                            innerType: oldShape[key],
                        })
                        : oldShape[key];
                }
            }
            else {
                for (const key in oldShape) {
                    // if (oldShape[key]!._zod.optin === "optional") continue;
                    shape[key] = Class
                        ? new Class({
                            type: "optional",
                            innerType: oldShape[key],
                        })
                        : oldShape[key];
                }
            }
            assignProp(this, "shape", shape); // self-caching
            return shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function required(Class, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const oldShape = schema._zod.def.shape;
            const shape = { ...oldShape };
            if (mask) {
                for (const key in mask) {
                    if (!(key in shape)) {
                        throw new Error(`Unrecognized key: "${key}"`);
                    }
                    if (!mask[key])
                        continue;
                    // overwrite with non-optional
                    shape[key] = new Class({
                        type: "nonoptional",
                        innerType: oldShape[key],
                    });
                }
            }
            else {
                for (const key in oldShape) {
                    // overwrite with non-optional
                    shape[key] = new Class({
                        type: "nonoptional",
                        innerType: oldShape[key],
                    });
                }
            }
            assignProp(this, "shape", shape); // self-caching
            return shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
// invalid_type | too_big | too_small | invalid_format | not_multiple_of | unrecognized_keys | invalid_union | invalid_key | invalid_element | invalid_value | custom
function aborted(x, startIndex = 0) {
    if (x.aborted === true)
        return true;
    for (let i = startIndex; i < x.issues.length; i++) {
        if (x.issues[i]?.continue !== true) {
            return true;
        }
    }
    return false;
}
function prefixIssues(path, issues) {
    return issues.map((iss) => {
        var _a;
        (_a = iss).path ?? (_a.path = []);
        iss.path.unshift(path);
        return iss;
    });
}
function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config) {
    const full = { ...iss, path: iss.path ?? [] };
    // for backwards compatibility
    if (!iss.message) {
        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
            unwrapMessage(ctx?.error?.(iss)) ??
            unwrapMessage(config.customError?.(iss)) ??
            unwrapMessage(config.localeError?.(iss)) ??
            "Invalid input";
        full.message = message;
    }
    // delete (full as any).def;
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
        delete full.input;
    }
    return full;
}
function getSizableOrigin(input) {
    if (input instanceof Set)
        return "set";
    if (input instanceof Map)
        return "map";
    // @ts-ignore
    if (input instanceof File)
        return "file";
    return "unknown";
}
function getLengthableOrigin(input) {
    if (Array.isArray(input))
        return "array";
    if (typeof input === "string")
        return "string";
    return "unknown";
}
function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
        return {
            message: iss,
            code: "custom",
            input,
            inst,
        };
    }
    return { ...iss };
}
function cleanEnum(obj) {
    return Object.entries(obj)
        .filter(([k, _]) => {
        // return true if NaN, meaning it's not a number, thus a string key
        return Number.isNaN(Number.parseInt(k, 10));
    })
        .map((el) => el[1]);
}
// Codec utility functions
function base64ToUint8Array(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
}
function uint8ArrayToBase64(bytes) {
    let binaryString = "";
    for (let i = 0; i < bytes.length; i++) {
        binaryString += String.fromCharCode(bytes[i]);
    }
    return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
    const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
    const padding = "=".repeat((4 - (base64.length % 4)) % 4);
    return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
    return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
    const cleanHex = hex.replace(/^0x/, "");
    if (cleanHex.length % 2 !== 0) {
        throw new Error("Invalid hex string length");
    }
    const bytes = new Uint8Array(cleanHex.length / 2);
    for (let i = 0; i < cleanHex.length; i += 2) {
        bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
    }
    return bytes;
}
function uint8ArrayToHex(bytes) {
    return Array.from(bytes)
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");
}
// instanceof
class Class {
    constructor(..._args) { }
}
Class_1 = util$3.Class = Class;

"use strict";
var __createBinding$4 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$4 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$4 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$4(result, mod, k);
    __setModuleDefault$4(result, mod);
    return result;
};
Object.defineProperty(errors$6, "__esModule", { value: true });
var $ZodRealError = errors$6.$ZodRealError = $ZodError = errors$6.$ZodError = void 0;
var flattenError_1 = errors$6.flattenError = flattenError;
var formatError_1 = errors$6.formatError = formatError;
var treeifyError_1 = errors$6.treeifyError = treeifyError;
var toDotPath_1 = errors$6.toDotPath = toDotPath;
var prettifyError_1 = errors$6.prettifyError = prettifyError;
const core_js_1 = core$4;
const util$2 = __importStar$4(util$3);
const initializer$1 = (inst, def) => {
    inst.name = "$ZodError";
    Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false,
    });
    Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false,
    });
    inst.message = JSON.stringify(def, util$2.jsonStringifyReplacer, 2);
    Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false,
    });
};
var $ZodError = errors$6.$ZodError = (0, core_js_1.$constructor)("$ZodError", initializer$1);
$ZodRealError = errors$6.$ZodRealError = (0, core_js_1.$constructor)("$ZodError", initializer$1, { Parent: Error });
function flattenError(error, mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of error.issues) {
        if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
        }
        else {
            formErrors.push(mapper(sub));
        }
    }
    return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
    const mapper = _mapper ||
        function (issue) {
            return issue.message;
        };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
        for (const issue of error.issues) {
            if (issue.code === "invalid_union" && issue.errors.length) {
                issue.errors.map((issues) => processError({ issues }));
            }
            else if (issue.code === "invalid_key") {
                processError({ issues: issue.issues });
            }
            else if (issue.code === "invalid_element") {
                processError({ issues: issue.issues });
            }
            else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
            }
            else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                    const el = issue.path[i];
                    const terminal = i === issue.path.length - 1;
                    if (!terminal) {
                        curr[el] = curr[el] || { _errors: [] };
                    }
                    else {
                        curr[el] = curr[el] || { _errors: [] };
                        curr[el]._errors.push(mapper(issue));
                    }
                    curr = curr[el];
                    i++;
                }
            }
        }
    };
    processError(error);
    return fieldErrors;
}
function treeifyError(error, _mapper) {
    const mapper = _mapper ||
        function (issue) {
            return issue.message;
        };
    const result = { errors: [] };
    const processError = (error, path = []) => {
        var _a, _b;
        for (const issue of error.issues) {
            if (issue.code === "invalid_union" && issue.errors.length) {
                // regular union error
                issue.errors.map((issues) => processError({ issues }, issue.path));
            }
            else if (issue.code === "invalid_key") {
                processError({ issues: issue.issues }, issue.path);
            }
            else if (issue.code === "invalid_element") {
                processError({ issues: issue.issues }, issue.path);
            }
            else {
                const fullpath = [...path, ...issue.path];
                if (fullpath.length === 0) {
                    result.errors.push(mapper(issue));
                    continue;
                }
                let curr = result;
                let i = 0;
                while (i < fullpath.length) {
                    const el = fullpath[i];
                    const terminal = i === fullpath.length - 1;
                    if (typeof el === "string") {
                        curr.properties ?? (curr.properties = {});
                        (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
                        curr = curr.properties[el];
                    }
                    else {
                        curr.items ?? (curr.items = []);
                        (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
                        curr = curr.items[el];
                    }
                    if (terminal) {
                        curr.errors.push(mapper(issue));
                    }
                    i++;
                }
            }
        }
    };
    processError(error);
    return result;
}
/** Format a ZodError as a human-readable string in the following form.
 *
 * From
 *
 * ```ts
 * ZodError {
 *   issues: [
 *     {
 *       expected: 'string',
 *       code: 'invalid_type',
 *       path: [ 'username' ],
 *       message: 'Invalid input: expected string'
 *     },
 *     {
 *       expected: 'number',
 *       code: 'invalid_type',
 *       path: [ 'favoriteNumbers', 1 ],
 *       message: 'Invalid input: expected number'
 *     }
 *   ];
 * }
 * ```
 *
 * to
 *
 * ```
 * username
 *   ✖ Expected number, received string at "username
 * favoriteNumbers[0]
 *   ✖ Invalid input: expected number
 * ```
 */
function toDotPath(_path) {
    const segs = [];
    const path = _path.map((seg) => (typeof seg === "object" ? seg.key : seg));
    for (const seg of path) {
        if (typeof seg === "number")
            segs.push(`[${seg}]`);
        else if (typeof seg === "symbol")
            segs.push(`[${JSON.stringify(String(seg))}]`);
        else if (/[^\w$]/.test(seg))
            segs.push(`[${JSON.stringify(seg)}]`);
        else {
            if (segs.length)
                segs.push(".");
            segs.push(seg);
        }
    }
    return segs.join("");
}
function prettifyError(error) {
    const lines = [];
    // sort by path length
    const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
    // Process each issue
    for (const issue of issues) {
        lines.push(`✖ ${issue.message}`);
        if (issue.path?.length)
            lines.push(`  → at ${toDotPath(issue.path)}`);
    }
    // Convert Map to formatted string
    return lines.join("\n");
}

(function (exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.safeDecodeAsync = exports._safeDecodeAsync = exports.safeEncodeAsync = exports._safeEncodeAsync = exports.safeDecode = exports._safeDecode = exports.safeEncode = exports._safeEncode = exports.decodeAsync = exports._decodeAsync = exports.encodeAsync = exports._encodeAsync = exports.decode = exports._decode = exports.encode = exports._encode = exports.safeParseAsync = exports._safeParseAsync = exports.safeParse = exports._safeParse = exports.parseAsync = exports._parseAsync = exports.parse = exports._parse = void 0;
	const core = __importStar(core$4);
	const errors = __importStar(errors$6);
	const util = __importStar(util$3);
	const _parse = (_Err) => (schema, value, _ctx, _params) => {
	    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
	    const result = schema._zod.run({ value, issues: [] }, ctx);
	    if (result instanceof Promise) {
	        throw new core.$ZodAsyncError();
	    }
	    if (result.issues.length) {
	        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));
	        util.captureStackTrace(e, _params?.callee);
	        throw e;
	    }
	    return result.value;
	};
	exports._parse = _parse;
	exports.parse = (0, exports._parse)(errors.$ZodRealError);
	const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
	    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	    let result = schema._zod.run({ value, issues: [] }, ctx);
	    if (result instanceof Promise)
	        result = await result;
	    if (result.issues.length) {
	        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));
	        util.captureStackTrace(e, params?.callee);
	        throw e;
	    }
	    return result.value;
	};
	exports._parseAsync = _parseAsync;
	exports.parseAsync = (0, exports._parseAsync)(errors.$ZodRealError);
	const _safeParse = (_Err) => (schema, value, _ctx) => {
	    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
	    const result = schema._zod.run({ value, issues: [] }, ctx);
	    if (result instanceof Promise) {
	        throw new core.$ZodAsyncError();
	    }
	    return result.issues.length
	        ? {
	            success: false,
	            error: new (_Err ?? errors.$ZodError)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),
	        }
	        : { success: true, data: result.value };
	};
	exports._safeParse = _safeParse;
	exports.safeParse = (0, exports._safeParse)(errors.$ZodRealError);
	const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
	    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
	    let result = schema._zod.run({ value, issues: [] }, ctx);
	    if (result instanceof Promise)
	        result = await result;
	    return result.issues.length
	        ? {
	            success: false,
	            error: new _Err(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),
	        }
	        : { success: true, data: result.value };
	};
	exports._safeParseAsync = _safeParseAsync;
	exports.safeParseAsync = (0, exports._safeParseAsync)(errors.$ZodRealError);
	const _encode = (_Err) => (schema, value, _ctx) => {
	    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	    return (0, exports._parse)(_Err)(schema, value, ctx);
	};
	exports._encode = _encode;
	exports.encode = (0, exports._encode)(errors.$ZodRealError);
	const _decode = (_Err) => (schema, value, _ctx) => {
	    return (0, exports._parse)(_Err)(schema, value, _ctx);
	};
	exports._decode = _decode;
	exports.decode = (0, exports._decode)(errors.$ZodRealError);
	const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
	    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	    return (0, exports._parseAsync)(_Err)(schema, value, ctx);
	};
	exports._encodeAsync = _encodeAsync;
	exports.encodeAsync = (0, exports._encodeAsync)(errors.$ZodRealError);
	const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
	    return (0, exports._parseAsync)(_Err)(schema, value, _ctx);
	};
	exports._decodeAsync = _decodeAsync;
	exports.decodeAsync = (0, exports._decodeAsync)(errors.$ZodRealError);
	const _safeEncode = (_Err) => (schema, value, _ctx) => {
	    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	    return (0, exports._safeParse)(_Err)(schema, value, ctx);
	};
	exports._safeEncode = _safeEncode;
	exports.safeEncode = (0, exports._safeEncode)(errors.$ZodRealError);
	const _safeDecode = (_Err) => (schema, value, _ctx) => {
	    return (0, exports._safeParse)(_Err)(schema, value, _ctx);
	};
	exports._safeDecode = _safeDecode;
	exports.safeDecode = (0, exports._safeDecode)(errors.$ZodRealError);
	const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
	    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
	    return (0, exports._safeParseAsync)(_Err)(schema, value, ctx);
	};
	exports._safeEncodeAsync = _safeEncodeAsync;
	exports.safeEncodeAsync = (0, exports._safeEncodeAsync)(errors.$ZodRealError);
	const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
	    return (0, exports._safeParseAsync)(_Err)(schema, value, _ctx);
	};
	exports._safeDecodeAsync = _safeDecodeAsync;
	exports.safeDecodeAsync = (0, exports._safeDecodeAsync)(errors.$ZodRealError); 
} (parse$4));

var parse$3 = /*@__PURE__*/getDefaultExportFromCjs(parse$4);

var schemas$4 = {};

var checks$4 = {};

var regexes$1 = {};

(function (exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sha384_base64 = exports.sha384_hex = exports.sha256_base64url = exports.sha256_base64 = exports.sha256_hex = exports.sha1_base64url = exports.sha1_base64 = exports.sha1_hex = exports.md5_base64url = exports.md5_base64 = exports.md5_hex = exports.hex = exports.uppercase = exports.lowercase = exports.undefined = exports.null = exports.boolean = exports.number = exports.integer = exports.bigint = exports.string = exports.date = exports.e164 = exports.domain = exports.hostname = exports.base64url = exports.base64 = exports.cidrv6 = exports.cidrv4 = exports.ipv6 = exports.ipv4 = exports.browserEmail = exports.idnEmail = exports.unicodeEmail = exports.rfc5322Email = exports.html5Email = exports.email = exports.uuid7 = exports.uuid6 = exports.uuid4 = exports.uuid = exports.guid = exports.extendedDuration = exports.duration = exports.nanoid = exports.ksuid = exports.xid = exports.ulid = exports.cuid2 = exports.cuid = void 0;
	exports.sha512_base64url = exports.sha512_base64 = exports.sha512_hex = exports.sha384_base64url = void 0;
	exports.emoji = emoji;
	exports.time = time;
	exports.datetime = datetime;
	exports.cuid = /^[cC][^\s-]{8,}$/;
	exports.cuid2 = /^[0-9a-z]+$/;
	exports.ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
	exports.xid = /^[0-9a-vA-V]{20}$/;
	exports.ksuid = /^[A-Za-z0-9]{27}$/;
	exports.nanoid = /^[a-zA-Z0-9_-]{21}$/;
	/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
	exports.duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
	/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */
	exports.extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
	/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
	exports.guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
	/** Returns a regex for validating an RFC 9562/4122 UUID.
	 *
	 * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
	const uuid = (version) => {
	    if (!version)
	        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
	    return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
	};
	exports.uuid = uuid;
	exports.uuid4 = (0, exports.uuid)(4);
	exports.uuid6 = (0, exports.uuid)(6);
	exports.uuid7 = (0, exports.uuid)(7);
	/** Practical email validation */
	exports.email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
	/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */
	exports.html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	/** The classic emailregex.com regex for RFC 5322-compliant emails */
	exports.rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
	/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */
	exports.unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
	exports.idnEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
	exports.browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
	const _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
	function emoji() {
	    return new RegExp(_emoji, "u");
	}
	exports.ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
	exports.ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
	exports.cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
	exports.cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
	// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
	exports.base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
	exports.base64url = /^[A-Za-z0-9_-]*$/;
	// based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
	// export const hostname: RegExp = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
	exports.hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
	exports.domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
	// https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)
	exports.e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
	// const dateSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
	const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
	exports.date = new RegExp(`^${dateSource}$`);
	function timeSource(args) {
	    const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
	    const regex = typeof args.precision === "number"
	        ? args.precision === -1
	            ? `${hhmm}`
	            : args.precision === 0
	                ? `${hhmm}:[0-5]\\d`
	                : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`
	        : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
	    return regex;
	}
	function time(args) {
	    return new RegExp(`^${timeSource(args)}$`);
	}
	// Adapted from https://stackoverflow.com/a/3143231
	function datetime(args) {
	    const time = timeSource({ precision: args.precision });
	    const opts = ["Z"];
	    if (args.local)
	        opts.push("");
	    // if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
	    if (args.offset)
	        opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
	    const timeRegex = `${time}(?:${opts.join("|")})`;
	    return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
	}
	const string = (params) => {
	    const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
	    return new RegExp(`^${regex}$`);
	};
	exports.string = string;
	exports.bigint = /^\d+n?$/;
	exports.integer = /^\d+$/;
	exports.number = /^-?\d+(?:\.\d+)?/i;
	exports.boolean = /true|false/i;
	const _null = /null/i;
	exports.null = _null;
	const _undefined = /undefined/i;
	exports.undefined = _undefined;
	// regex for string with no uppercase letters
	exports.lowercase = /^[^A-Z]*$/;
	// regex for string with no lowercase letters
	exports.uppercase = /^[^a-z]*$/;
	// regex for hexadecimal strings (any length)
	exports.hex = /^[0-9a-fA-F]*$/;
	// Hash regexes for different algorithms and encodings
	// Helper function to create base64 regex with exact length and padding
	function fixedBase64(bodyLength, padding) {
	    return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
	}
	// Helper function to create base64url regex with exact length (no padding)
	function fixedBase64url(length) {
	    return new RegExp(`^[A-Za-z0-9-_]{${length}}$`);
	}
	// MD5 (16 bytes): base64 = 24 chars total (22 + "==")
	exports.md5_hex = /^[0-9a-fA-F]{32}$/;
	exports.md5_base64 = fixedBase64(22, "==");
	exports.md5_base64url = fixedBase64url(22);
	// SHA1 (20 bytes): base64 = 28 chars total (27 + "=")
	exports.sha1_hex = /^[0-9a-fA-F]{40}$/;
	exports.sha1_base64 = fixedBase64(27, "=");
	exports.sha1_base64url = fixedBase64url(27);
	// SHA256 (32 bytes): base64 = 44 chars total (43 + "=")
	exports.sha256_hex = /^[0-9a-fA-F]{64}$/;
	exports.sha256_base64 = fixedBase64(43, "=");
	exports.sha256_base64url = fixedBase64url(43);
	// SHA384 (48 bytes): base64 = 64 chars total (no padding)
	exports.sha384_hex = /^[0-9a-fA-F]{96}$/;
	exports.sha384_base64 = fixedBase64(64, "");
	exports.sha384_base64url = fixedBase64url(64);
	// SHA512 (64 bytes): base64 = 88 chars total (86 + "==")
	exports.sha512_hex = /^[0-9a-fA-F]{128}$/;
	exports.sha512_base64 = fixedBase64(86, "==");
	exports.sha512_base64url = fixedBase64url(86); 
} (regexes$1));

var regexes = /*@__PURE__*/getDefaultExportFromCjs(regexes$1);

(function (exports) {
	"use strict";
	// import { $ZodType } from "./schemas.js";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.$ZodCheckOverwrite = exports.$ZodCheckMimeType = exports.$ZodCheckProperty = exports.$ZodCheckEndsWith = exports.$ZodCheckStartsWith = exports.$ZodCheckIncludes = exports.$ZodCheckUpperCase = exports.$ZodCheckLowerCase = exports.$ZodCheckRegex = exports.$ZodCheckStringFormat = exports.$ZodCheckLengthEquals = exports.$ZodCheckMinLength = exports.$ZodCheckMaxLength = exports.$ZodCheckSizeEquals = exports.$ZodCheckMinSize = exports.$ZodCheckMaxSize = exports.$ZodCheckBigIntFormat = exports.$ZodCheckNumberFormat = exports.$ZodCheckMultipleOf = exports.$ZodCheckGreaterThan = exports.$ZodCheckLessThan = exports.$ZodCheck = void 0;
	const core = __importStar(core$4);
	const regexes = __importStar(regexes$1);
	const util = __importStar(util$3);
	exports.$ZodCheck = core.$constructor("$ZodCheck", (inst, def) => {
	    var _a;
	    inst._zod ?? (inst._zod = {});
	    inst._zod.def = def;
	    (_a = inst._zod).onattach ?? (_a.onattach = []);
	});
	const numericOriginMap = {
	    number: "number",
	    bigint: "bigint",
	    object: "date",
	};
	exports.$ZodCheckLessThan = core.$constructor("$ZodCheckLessThan", (inst, def) => {
	    exports.$ZodCheck.init(inst, def);
	    const origin = numericOriginMap[typeof def.value];
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
	        if (def.value < curr) {
	            if (def.inclusive)
	                bag.maximum = def.value;
	            else
	                bag.exclusiveMaximum = def.value;
	        }
	    });
	    inst._zod.check = (payload) => {
	        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
	            return;
	        }
	        payload.issues.push({
	            origin,
	            code: "too_big",
	            maximum: def.value,
	            input: payload.value,
	            inclusive: def.inclusive,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckGreaterThan = core.$constructor("$ZodCheckGreaterThan", (inst, def) => {
	    exports.$ZodCheck.init(inst, def);
	    const origin = numericOriginMap[typeof def.value];
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
	        if (def.value > curr) {
	            if (def.inclusive)
	                bag.minimum = def.value;
	            else
	                bag.exclusiveMinimum = def.value;
	        }
	    });
	    inst._zod.check = (payload) => {
	        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
	            return;
	        }
	        payload.issues.push({
	            origin,
	            code: "too_small",
	            minimum: def.value,
	            input: payload.value,
	            inclusive: def.inclusive,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckMultipleOf = 
	/*@__PURE__*/ core.$constructor("$ZodCheckMultipleOf", (inst, def) => {
	    exports.$ZodCheck.init(inst, def);
	    inst._zod.onattach.push((inst) => {
	        var _a;
	        (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
	    });
	    inst._zod.check = (payload) => {
	        if (typeof payload.value !== typeof def.value)
	            throw new Error("Cannot mix number and bigint in multiple_of check.");
	        const isMultiple = typeof payload.value === "bigint"
	            ? payload.value % def.value === BigInt(0)
	            : util.floatSafeRemainder(payload.value, def.value) === 0;
	        if (isMultiple)
	            return;
	        payload.issues.push({
	            origin: typeof payload.value,
	            code: "not_multiple_of",
	            divisor: def.value,
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckNumberFormat = core.$constructor("$ZodCheckNumberFormat", (inst, def) => {
	    exports.$ZodCheck.init(inst, def); // no format checks
	    def.format = def.format || "float64";
	    const isInt = def.format?.includes("int");
	    const origin = isInt ? "int" : "number";
	    const [minimum, maximum] = util.NUMBER_FORMAT_RANGES[def.format];
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.format = def.format;
	        bag.minimum = minimum;
	        bag.maximum = maximum;
	        if (isInt)
	            bag.pattern = regexes.integer;
	    });
	    inst._zod.check = (payload) => {
	        const input = payload.value;
	        if (isInt) {
	            if (!Number.isInteger(input)) {
	                // invalid_format issue
	                // payload.issues.push({
	                //   expected: def.format,
	                //   format: def.format,
	                //   code: "invalid_format",
	                //   input,
	                //   inst,
	                // });
	                // invalid_type issue
	                payload.issues.push({
	                    expected: origin,
	                    format: def.format,
	                    code: "invalid_type",
	                    continue: false,
	                    input,
	                    inst,
	                });
	                return;
	                // not_multiple_of issue
	                // payload.issues.push({
	                //   code: "not_multiple_of",
	                //   origin: "number",
	                //   input,
	                //   inst,
	                //   divisor: 1,
	                // });
	            }
	            if (!Number.isSafeInteger(input)) {
	                if (input > 0) {
	                    // too_big
	                    payload.issues.push({
	                        input,
	                        code: "too_big",
	                        maximum: Number.MAX_SAFE_INTEGER,
	                        note: "Integers must be within the safe integer range.",
	                        inst,
	                        origin,
	                        continue: !def.abort,
	                    });
	                }
	                else {
	                    // too_small
	                    payload.issues.push({
	                        input,
	                        code: "too_small",
	                        minimum: Number.MIN_SAFE_INTEGER,
	                        note: "Integers must be within the safe integer range.",
	                        inst,
	                        origin,
	                        continue: !def.abort,
	                    });
	                }
	                return;
	            }
	        }
	        if (input < minimum) {
	            payload.issues.push({
	                origin: "number",
	                input,
	                code: "too_small",
	                minimum,
	                inclusive: true,
	                inst,
	                continue: !def.abort,
	            });
	        }
	        if (input > maximum) {
	            payload.issues.push({
	                origin: "number",
	                input,
	                code: "too_big",
	                maximum,
	                inst,
	            });
	        }
	    };
	});
	exports.$ZodCheckBigIntFormat = core.$constructor("$ZodCheckBigIntFormat", (inst, def) => {
	    exports.$ZodCheck.init(inst, def); // no format checks
	    const [minimum, maximum] = util.BIGINT_FORMAT_RANGES[def.format];
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.format = def.format;
	        bag.minimum = minimum;
	        bag.maximum = maximum;
	    });
	    inst._zod.check = (payload) => {
	        const input = payload.value;
	        if (input < minimum) {
	            payload.issues.push({
	                origin: "bigint",
	                input,
	                code: "too_small",
	                minimum: minimum,
	                inclusive: true,
	                inst,
	                continue: !def.abort,
	            });
	        }
	        if (input > maximum) {
	            payload.issues.push({
	                origin: "bigint",
	                input,
	                code: "too_big",
	                maximum,
	                inst,
	            });
	        }
	    };
	});
	exports.$ZodCheckMaxSize = core.$constructor("$ZodCheckMaxSize", (inst, def) => {
	    var _a;
	    exports.$ZodCheck.init(inst, def);
	    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
	        const val = payload.value;
	        return !util.nullish(val) && val.size !== undefined;
	    });
	    inst._zod.onattach.push((inst) => {
	        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);
	        if (def.maximum < curr)
	            inst._zod.bag.maximum = def.maximum;
	    });
	    inst._zod.check = (payload) => {
	        const input = payload.value;
	        const size = input.size;
	        if (size <= def.maximum)
	            return;
	        payload.issues.push({
	            origin: util.getSizableOrigin(input),
	            code: "too_big",
	            maximum: def.maximum,
	            inclusive: true,
	            input,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckMinSize = core.$constructor("$ZodCheckMinSize", (inst, def) => {
	    var _a;
	    exports.$ZodCheck.init(inst, def);
	    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
	        const val = payload.value;
	        return !util.nullish(val) && val.size !== undefined;
	    });
	    inst._zod.onattach.push((inst) => {
	        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);
	        if (def.minimum > curr)
	            inst._zod.bag.minimum = def.minimum;
	    });
	    inst._zod.check = (payload) => {
	        const input = payload.value;
	        const size = input.size;
	        if (size >= def.minimum)
	            return;
	        payload.issues.push({
	            origin: util.getSizableOrigin(input),
	            code: "too_small",
	            minimum: def.minimum,
	            inclusive: true,
	            input,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckSizeEquals = core.$constructor("$ZodCheckSizeEquals", (inst, def) => {
	    var _a;
	    exports.$ZodCheck.init(inst, def);
	    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
	        const val = payload.value;
	        return !util.nullish(val) && val.size !== undefined;
	    });
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.minimum = def.size;
	        bag.maximum = def.size;
	        bag.size = def.size;
	    });
	    inst._zod.check = (payload) => {
	        const input = payload.value;
	        const size = input.size;
	        if (size === def.size)
	            return;
	        const tooBig = size > def.size;
	        payload.issues.push({
	            origin: util.getSizableOrigin(input),
	            ...(tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size }),
	            inclusive: true,
	            exact: true,
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckMaxLength = core.$constructor("$ZodCheckMaxLength", (inst, def) => {
	    var _a;
	    exports.$ZodCheck.init(inst, def);
	    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
	        const val = payload.value;
	        return !util.nullish(val) && val.length !== undefined;
	    });
	    inst._zod.onattach.push((inst) => {
	        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);
	        if (def.maximum < curr)
	            inst._zod.bag.maximum = def.maximum;
	    });
	    inst._zod.check = (payload) => {
	        const input = payload.value;
	        const length = input.length;
	        if (length <= def.maximum)
	            return;
	        const origin = util.getLengthableOrigin(input);
	        payload.issues.push({
	            origin,
	            code: "too_big",
	            maximum: def.maximum,
	            inclusive: true,
	            input,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckMinLength = core.$constructor("$ZodCheckMinLength", (inst, def) => {
	    var _a;
	    exports.$ZodCheck.init(inst, def);
	    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
	        const val = payload.value;
	        return !util.nullish(val) && val.length !== undefined;
	    });
	    inst._zod.onattach.push((inst) => {
	        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);
	        if (def.minimum > curr)
	            inst._zod.bag.minimum = def.minimum;
	    });
	    inst._zod.check = (payload) => {
	        const input = payload.value;
	        const length = input.length;
	        if (length >= def.minimum)
	            return;
	        const origin = util.getLengthableOrigin(input);
	        payload.issues.push({
	            origin,
	            code: "too_small",
	            minimum: def.minimum,
	            inclusive: true,
	            input,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckLengthEquals = core.$constructor("$ZodCheckLengthEquals", (inst, def) => {
	    var _a;
	    exports.$ZodCheck.init(inst, def);
	    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
	        const val = payload.value;
	        return !util.nullish(val) && val.length !== undefined;
	    });
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.minimum = def.length;
	        bag.maximum = def.length;
	        bag.length = def.length;
	    });
	    inst._zod.check = (payload) => {
	        const input = payload.value;
	        const length = input.length;
	        if (length === def.length)
	            return;
	        const origin = util.getLengthableOrigin(input);
	        const tooBig = length > def.length;
	        payload.issues.push({
	            origin,
	            ...(tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length }),
	            inclusive: true,
	            exact: true,
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckStringFormat = core.$constructor("$ZodCheckStringFormat", (inst, def) => {
	    var _a, _b;
	    exports.$ZodCheck.init(inst, def);
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.format = def.format;
	        if (def.pattern) {
	            bag.patterns ?? (bag.patterns = new Set());
	            bag.patterns.add(def.pattern);
	        }
	    });
	    if (def.pattern)
	        (_a = inst._zod).check ?? (_a.check = (payload) => {
	            def.pattern.lastIndex = 0;
	            if (def.pattern.test(payload.value))
	                return;
	            payload.issues.push({
	                origin: "string",
	                code: "invalid_format",
	                format: def.format,
	                input: payload.value,
	                ...(def.pattern ? { pattern: def.pattern.toString() } : {}),
	                inst,
	                continue: !def.abort,
	            });
	        });
	    else
	        (_b = inst._zod).check ?? (_b.check = () => { });
	});
	exports.$ZodCheckRegex = core.$constructor("$ZodCheckRegex", (inst, def) => {
	    exports.$ZodCheckStringFormat.init(inst, def);
	    inst._zod.check = (payload) => {
	        def.pattern.lastIndex = 0;
	        if (def.pattern.test(payload.value))
	            return;
	        payload.issues.push({
	            origin: "string",
	            code: "invalid_format",
	            format: "regex",
	            input: payload.value,
	            pattern: def.pattern.toString(),
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckLowerCase = core.$constructor("$ZodCheckLowerCase", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.lowercase);
	    exports.$ZodCheckStringFormat.init(inst, def);
	});
	exports.$ZodCheckUpperCase = core.$constructor("$ZodCheckUpperCase", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.uppercase);
	    exports.$ZodCheckStringFormat.init(inst, def);
	});
	exports.$ZodCheckIncludes = core.$constructor("$ZodCheckIncludes", (inst, def) => {
	    exports.$ZodCheck.init(inst, def);
	    const escapedRegex = util.escapeRegex(def.includes);
	    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
	    def.pattern = pattern;
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.patterns ?? (bag.patterns = new Set());
	        bag.patterns.add(pattern);
	    });
	    inst._zod.check = (payload) => {
	        if (payload.value.includes(def.includes, def.position))
	            return;
	        payload.issues.push({
	            origin: "string",
	            code: "invalid_format",
	            format: "includes",
	            includes: def.includes,
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckStartsWith = core.$constructor("$ZodCheckStartsWith", (inst, def) => {
	    exports.$ZodCheck.init(inst, def);
	    const pattern = new RegExp(`^${util.escapeRegex(def.prefix)}.*`);
	    def.pattern ?? (def.pattern = pattern);
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.patterns ?? (bag.patterns = new Set());
	        bag.patterns.add(pattern);
	    });
	    inst._zod.check = (payload) => {
	        if (payload.value.startsWith(def.prefix))
	            return;
	        payload.issues.push({
	            origin: "string",
	            code: "invalid_format",
	            format: "starts_with",
	            prefix: def.prefix,
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckEndsWith = core.$constructor("$ZodCheckEndsWith", (inst, def) => {
	    exports.$ZodCheck.init(inst, def);
	    const pattern = new RegExp(`.*${util.escapeRegex(def.suffix)}$`);
	    def.pattern ?? (def.pattern = pattern);
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.patterns ?? (bag.patterns = new Set());
	        bag.patterns.add(pattern);
	    });
	    inst._zod.check = (payload) => {
	        if (payload.value.endsWith(def.suffix))
	            return;
	        payload.issues.push({
	            origin: "string",
	            code: "invalid_format",
	            format: "ends_with",
	            suffix: def.suffix,
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	///////////////////////////////////
	/////    $ZodCheckProperty    /////
	///////////////////////////////////
	function handleCheckPropertyResult(result, payload, property) {
	    if (result.issues.length) {
	        payload.issues.push(...util.prefixIssues(property, result.issues));
	    }
	}
	exports.$ZodCheckProperty = core.$constructor("$ZodCheckProperty", (inst, def) => {
	    exports.$ZodCheck.init(inst, def);
	    inst._zod.check = (payload) => {
	        const result = def.schema._zod.run({
	            value: payload.value[def.property],
	            issues: [],
	        }, {});
	        if (result instanceof Promise) {
	            return result.then((result) => handleCheckPropertyResult(result, payload, def.property));
	        }
	        handleCheckPropertyResult(result, payload, def.property);
	        return;
	    };
	});
	exports.$ZodCheckMimeType = core.$constructor("$ZodCheckMimeType", (inst, def) => {
	    exports.$ZodCheck.init(inst, def);
	    const mimeSet = new Set(def.mime);
	    inst._zod.onattach.push((inst) => {
	        inst._zod.bag.mime = def.mime;
	    });
	    inst._zod.check = (payload) => {
	        if (mimeSet.has(payload.value.type))
	            return;
	        payload.issues.push({
	            code: "invalid_value",
	            values: def.mime,
	            input: payload.value.type,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCheckOverwrite = core.$constructor("$ZodCheckOverwrite", (inst, def) => {
	    exports.$ZodCheck.init(inst, def);
	    inst._zod.check = (payload) => {
	        payload.value = def.tx(payload.value);
	    };
	}); 
} (checks$4));

var checks$3 = /*@__PURE__*/getDefaultExportFromCjs(checks$4);

var doc = {};

"use strict";
Object.defineProperty(doc, "__esModule", { value: true });
var Doc_1 = doc.Doc = void 0;
class Doc {
    constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
            this.args = args;
    }
    indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
    }
    write(arg) {
        if (typeof arg === "function") {
            arg(this, { execution: "sync" });
            arg(this, { execution: "async" });
            return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
            this.content.push(line);
        }
    }
    compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        // console.log(lines.join("\n"));
        return new F(...args, lines.join("\n"));
    }
}
Doc_1 = doc.Doc = Doc;

var versions = {};

"use strict";
Object.defineProperty(versions, "__esModule", { value: true });
var version = versions.version = void 0;
version = versions.version = {
    major: 4,
    minor: 1,
    patch: 5,
};

(function (exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.$ZodMap = exports.$ZodRecord = exports.$ZodTuple = exports.$ZodIntersection = exports.$ZodDiscriminatedUnion = exports.$ZodUnion = exports.$ZodObjectJIT = exports.$ZodObject = exports.$ZodArray = exports.$ZodDate = exports.$ZodVoid = exports.$ZodNever = exports.$ZodUnknown = exports.$ZodAny = exports.$ZodNull = exports.$ZodUndefined = exports.$ZodSymbol = exports.$ZodBigIntFormat = exports.$ZodBigInt = exports.$ZodBoolean = exports.$ZodNumberFormat = exports.$ZodNumber = exports.$ZodCustomStringFormat = exports.$ZodJWT = exports.$ZodE164 = exports.$ZodBase64URL = exports.$ZodBase64 = exports.$ZodCIDRv6 = exports.$ZodCIDRv4 = exports.$ZodIPv6 = exports.$ZodIPv4 = exports.$ZodISODuration = exports.$ZodISOTime = exports.$ZodISODate = exports.$ZodISODateTime = exports.$ZodKSUID = exports.$ZodXID = exports.$ZodULID = exports.$ZodCUID2 = exports.$ZodCUID = exports.$ZodNanoID = exports.$ZodEmoji = exports.$ZodURL = exports.$ZodEmail = exports.$ZodUUID = exports.$ZodGUID = exports.$ZodStringFormat = exports.$ZodString = exports.clone = exports.$ZodType = void 0;
	exports.$ZodCustom = exports.$ZodLazy = exports.$ZodPromise = exports.$ZodFunction = exports.$ZodTemplateLiteral = exports.$ZodReadonly = exports.$ZodCodec = exports.$ZodPipe = exports.$ZodNaN = exports.$ZodCatch = exports.$ZodSuccess = exports.$ZodNonOptional = exports.$ZodPrefault = exports.$ZodDefault = exports.$ZodNullable = exports.$ZodOptional = exports.$ZodTransform = exports.$ZodFile = exports.$ZodLiteral = exports.$ZodEnum = exports.$ZodSet = void 0;
	exports.isValidBase64 = isValidBase64;
	exports.isValidBase64URL = isValidBase64URL;
	exports.isValidJWT = isValidJWT;
	const checks = __importStar(checks$4);
	const core = __importStar(core$4);
	const doc_js_1 = doc;
	const parse_js_1 = parse$4;
	const regexes = __importStar(regexes$1);
	const util = __importStar(util$3);
	const versions_js_1 = versions;
	exports.$ZodType = core.$constructor("$ZodType", (inst, def) => {
	    var _a;
	    inst ?? (inst = {});
	    inst._zod.def = def; // set _def property
	    inst._zod.bag = inst._zod.bag || {}; // initialize _bag object
	    inst._zod.version = versions_js_1.version;
	    const checks = [...(inst._zod.def.checks ?? [])];
	    // if inst is itself a checks.$ZodCheck, run it as a check
	    if (inst._zod.traits.has("$ZodCheck")) {
	        checks.unshift(inst);
	    }
	    for (const ch of checks) {
	        for (const fn of ch._zod.onattach) {
	            fn(inst);
	        }
	    }
	    if (checks.length === 0) {
	        // deferred initializer
	        // inst._zod.parse is not yet defined
	        (_a = inst._zod).deferred ?? (_a.deferred = []);
	        inst._zod.deferred?.push(() => {
	            inst._zod.run = inst._zod.parse;
	        });
	    }
	    else {
	        const runChecks = (payload, checks, ctx) => {
	            let isAborted = util.aborted(payload);
	            let asyncResult;
	            for (const ch of checks) {
	                if (ch._zod.def.when) {
	                    const shouldRun = ch._zod.def.when(payload);
	                    if (!shouldRun)
	                        continue;
	                }
	                else if (isAborted) {
	                    continue;
	                }
	                const currLen = payload.issues.length;
	                const _ = ch._zod.check(payload);
	                if (_ instanceof Promise && ctx?.async === false) {
	                    throw new core.$ZodAsyncError();
	                }
	                if (asyncResult || _ instanceof Promise) {
	                    asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
	                        await _;
	                        const nextLen = payload.issues.length;
	                        if (nextLen === currLen)
	                            return;
	                        if (!isAborted)
	                            isAborted = util.aborted(payload, currLen);
	                    });
	                }
	                else {
	                    const nextLen = payload.issues.length;
	                    if (nextLen === currLen)
	                        continue;
	                    if (!isAborted)
	                        isAborted = util.aborted(payload, currLen);
	                }
	            }
	            if (asyncResult) {
	                return asyncResult.then(() => {
	                    return payload;
	                });
	            }
	            return payload;
	        };
	        // const handleChecksResult = (
	        //   checkResult: ParsePayload,
	        //   originalResult: ParsePayload,
	        //   ctx: ParseContextInternal
	        // ): util.MaybeAsync<ParsePayload> => {
	        //   // if the checks mutated the value && there are no issues, re-parse the result
	        //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)
	        //     return inst._zod.parse(checkResult, ctx);
	        //   return originalResult;
	        // };
	        const handleCanaryResult = (canary, payload, ctx) => {
	            // abort if the canary is aborted
	            if (util.aborted(canary)) {
	                canary.aborted = true;
	                return canary;
	            }
	            // run checks first, then
	            const checkResult = runChecks(payload, checks, ctx);
	            if (checkResult instanceof Promise) {
	                if (ctx.async === false)
	                    throw new core.$ZodAsyncError();
	                return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));
	            }
	            return inst._zod.parse(checkResult, ctx);
	        };
	        inst._zod.run = (payload, ctx) => {
	            if (ctx.skipChecks) {
	                return inst._zod.parse(payload, ctx);
	            }
	            if (ctx.direction === "backward") {
	                // run canary
	                // initial pass (no checks)
	                const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
	                if (canary instanceof Promise) {
	                    return canary.then((canary) => {
	                        return handleCanaryResult(canary, payload, ctx);
	                    });
	                }
	                return handleCanaryResult(canary, payload, ctx);
	            }
	            // forward
	            const result = inst._zod.parse(payload, ctx);
	            if (result instanceof Promise) {
	                if (ctx.async === false)
	                    throw new core.$ZodAsyncError();
	                return result.then((result) => runChecks(result, checks, ctx));
	            }
	            return runChecks(result, checks, ctx);
	        };
	    }
	    inst["~standard"] = {
	        validate: (value) => {
	            try {
	                const r = (0, parse_js_1.safeParse)(inst, value);
	                return r.success ? { value: r.data } : { issues: r.error?.issues };
	            }
	            catch (_) {
	                return (0, parse_js_1.safeParseAsync)(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));
	            }
	        },
	        vendor: "zod",
	        version: 1,
	    };
	});
	var util_js_1 = util$3;
	Object.defineProperty(exports, "clone", { enumerable: true, get: function () { return util_js_1.clone; } });
	exports.$ZodString = core.$constructor("$ZodString", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? regexes.string(inst._zod.bag);
	    inst._zod.parse = (payload, _) => {
	        if (def.coerce)
	            try {
	                payload.value = String(payload.value);
	            }
	            catch (_) { }
	        if (typeof payload.value === "string")
	            return payload;
	        payload.issues.push({
	            expected: "string",
	            code: "invalid_type",
	            input: payload.value,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodStringFormat = core.$constructor("$ZodStringFormat", (inst, def) => {
	    // check initialization must come first
	    checks.$ZodCheckStringFormat.init(inst, def);
	    exports.$ZodString.init(inst, def);
	});
	exports.$ZodGUID = core.$constructor("$ZodGUID", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.guid);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodUUID = core.$constructor("$ZodUUID", (inst, def) => {
	    if (def.version) {
	        const versionMap = {
	            v1: 1,
	            v2: 2,
	            v3: 3,
	            v4: 4,
	            v5: 5,
	            v6: 6,
	            v7: 7,
	            v8: 8,
	        };
	        const v = versionMap[def.version];
	        if (v === undefined)
	            throw new Error(`Invalid UUID version: "${def.version}"`);
	        def.pattern ?? (def.pattern = regexes.uuid(v));
	    }
	    else
	        def.pattern ?? (def.pattern = regexes.uuid());
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodEmail = core.$constructor("$ZodEmail", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.email);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodURL = core.$constructor("$ZodURL", (inst, def) => {
	    exports.$ZodStringFormat.init(inst, def);
	    inst._zod.check = (payload) => {
	        try {
	            // Trim whitespace from input
	            const trimmed = payload.value.trim();
	            // @ts-ignore
	            const url = new URL(trimmed);
	            if (def.hostname) {
	                def.hostname.lastIndex = 0;
	                if (!def.hostname.test(url.hostname)) {
	                    payload.issues.push({
	                        code: "invalid_format",
	                        format: "url",
	                        note: "Invalid hostname",
	                        pattern: regexes.hostname.source,
	                        input: payload.value,
	                        inst,
	                        continue: !def.abort,
	                    });
	                }
	            }
	            if (def.protocol) {
	                def.protocol.lastIndex = 0;
	                if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
	                    payload.issues.push({
	                        code: "invalid_format",
	                        format: "url",
	                        note: "Invalid protocol",
	                        pattern: def.protocol.source,
	                        input: payload.value,
	                        inst,
	                        continue: !def.abort,
	                    });
	                }
	            }
	            // Set the output value based on normalize flag
	            if (def.normalize) {
	                // Use normalized URL
	                payload.value = url.href;
	            }
	            else {
	                // Preserve the original input (trimmed)
	                payload.value = trimmed;
	            }
	            return;
	        }
	        catch (_) {
	            payload.issues.push({
	                code: "invalid_format",
	                format: "url",
	                input: payload.value,
	                inst,
	                continue: !def.abort,
	            });
	        }
	    };
	});
	exports.$ZodEmoji = core.$constructor("$ZodEmoji", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.emoji());
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodNanoID = core.$constructor("$ZodNanoID", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.nanoid);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodCUID = core.$constructor("$ZodCUID", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.cuid);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodCUID2 = core.$constructor("$ZodCUID2", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.cuid2);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodULID = core.$constructor("$ZodULID", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.ulid);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodXID = core.$constructor("$ZodXID", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.xid);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodKSUID = core.$constructor("$ZodKSUID", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.ksuid);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodISODateTime = core.$constructor("$ZodISODateTime", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.datetime(def));
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodISODate = core.$constructor("$ZodISODate", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.date);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodISOTime = core.$constructor("$ZodISOTime", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.time(def));
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodISODuration = core.$constructor("$ZodISODuration", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.duration);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodIPv4 = core.$constructor("$ZodIPv4", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.ipv4);
	    exports.$ZodStringFormat.init(inst, def);
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.format = `ipv4`;
	    });
	});
	exports.$ZodIPv6 = core.$constructor("$ZodIPv6", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.ipv6);
	    exports.$ZodStringFormat.init(inst, def);
	    inst._zod.onattach.push((inst) => {
	        const bag = inst._zod.bag;
	        bag.format = `ipv6`;
	    });
	    inst._zod.check = (payload) => {
	        try {
	            // @ts-ignore
	            new URL(`http://[${payload.value}]`);
	            // return;
	        }
	        catch {
	            payload.issues.push({
	                code: "invalid_format",
	                format: "ipv6",
	                input: payload.value,
	                inst,
	                continue: !def.abort,
	            });
	        }
	    };
	});
	exports.$ZodCIDRv4 = core.$constructor("$ZodCIDRv4", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.cidrv4);
	    exports.$ZodStringFormat.init(inst, def);
	});
	exports.$ZodCIDRv6 = core.$constructor("$ZodCIDRv6", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.cidrv6); // not used for validation
	    exports.$ZodStringFormat.init(inst, def);
	    inst._zod.check = (payload) => {
	        const [address, prefix] = payload.value.split("/");
	        try {
	            if (!prefix)
	                throw new Error();
	            const prefixNum = Number(prefix);
	            if (`${prefixNum}` !== prefix)
	                throw new Error();
	            if (prefixNum < 0 || prefixNum > 128)
	                throw new Error();
	            // @ts-ignore
	            new URL(`http://[${address}]`);
	        }
	        catch {
	            payload.issues.push({
	                code: "invalid_format",
	                format: "cidrv6",
	                input: payload.value,
	                inst,
	                continue: !def.abort,
	            });
	        }
	    };
	});
	//////////////////////////////   ZodBase64   //////////////////////////////
	function isValidBase64(data) {
	    if (data === "")
	        return true;
	    if (data.length % 4 !== 0)
	        return false;
	    try {
	        // @ts-ignore
	        atob(data);
	        return true;
	    }
	    catch {
	        return false;
	    }
	}
	exports.$ZodBase64 = core.$constructor("$ZodBase64", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.base64);
	    exports.$ZodStringFormat.init(inst, def);
	    inst._zod.onattach.push((inst) => {
	        inst._zod.bag.contentEncoding = "base64";
	    });
	    inst._zod.check = (payload) => {
	        if (isValidBase64(payload.value))
	            return;
	        payload.issues.push({
	            code: "invalid_format",
	            format: "base64",
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	//////////////////////////////   ZodBase64   //////////////////////////////
	function isValidBase64URL(data) {
	    if (!regexes.base64url.test(data))
	        return false;
	    const base64 = data.replace(/[-_]/g, (c) => (c === "-" ? "+" : "/"));
	    const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, "=");
	    return isValidBase64(padded);
	}
	exports.$ZodBase64URL = core.$constructor("$ZodBase64URL", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.base64url);
	    exports.$ZodStringFormat.init(inst, def);
	    inst._zod.onattach.push((inst) => {
	        inst._zod.bag.contentEncoding = "base64url";
	    });
	    inst._zod.check = (payload) => {
	        if (isValidBase64URL(payload.value))
	            return;
	        payload.issues.push({
	            code: "invalid_format",
	            format: "base64url",
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodE164 = core.$constructor("$ZodE164", (inst, def) => {
	    def.pattern ?? (def.pattern = regexes.e164);
	    exports.$ZodStringFormat.init(inst, def);
	});
	//////////////////////////////   ZodJWT   //////////////////////////////
	function isValidJWT(token, algorithm = null) {
	    try {
	        const tokensParts = token.split(".");
	        if (tokensParts.length !== 3)
	            return false;
	        const [header] = tokensParts;
	        if (!header)
	            return false;
	        // @ts-ignore
	        const parsedHeader = JSON.parse(atob(header));
	        if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
	            return false;
	        if (!parsedHeader.alg)
	            return false;
	        if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
	            return false;
	        return true;
	    }
	    catch {
	        return false;
	    }
	}
	exports.$ZodJWT = core.$constructor("$ZodJWT", (inst, def) => {
	    exports.$ZodStringFormat.init(inst, def);
	    inst._zod.check = (payload) => {
	        if (isValidJWT(payload.value, def.alg))
	            return;
	        payload.issues.push({
	            code: "invalid_format",
	            format: "jwt",
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodCustomStringFormat = core.$constructor("$ZodCustomStringFormat", (inst, def) => {
	    exports.$ZodStringFormat.init(inst, def);
	    inst._zod.check = (payload) => {
	        if (def.fn(payload.value))
	            return;
	        payload.issues.push({
	            code: "invalid_format",
	            format: def.format,
	            input: payload.value,
	            inst,
	            continue: !def.abort,
	        });
	    };
	});
	exports.$ZodNumber = core.$constructor("$ZodNumber", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.pattern = inst._zod.bag.pattern ?? regexes.number;
	    inst._zod.parse = (payload, _ctx) => {
	        if (def.coerce)
	            try {
	                payload.value = Number(payload.value);
	            }
	            catch (_) { }
	        const input = payload.value;
	        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
	            return payload;
	        }
	        const received = typeof input === "number"
	            ? Number.isNaN(input)
	                ? "NaN"
	                : !Number.isFinite(input)
	                    ? "Infinity"
	                    : undefined
	            : undefined;
	        payload.issues.push({
	            expected: "number",
	            code: "invalid_type",
	            input,
	            inst,
	            ...(received ? { received } : {}),
	        });
	        return payload;
	    };
	});
	exports.$ZodNumberFormat = core.$constructor("$ZodNumber", (inst, def) => {
	    checks.$ZodCheckNumberFormat.init(inst, def);
	    exports.$ZodNumber.init(inst, def); // no format checksp
	});
	exports.$ZodBoolean = core.$constructor("$ZodBoolean", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.pattern = regexes.boolean;
	    inst._zod.parse = (payload, _ctx) => {
	        if (def.coerce)
	            try {
	                payload.value = Boolean(payload.value);
	            }
	            catch (_) { }
	        const input = payload.value;
	        if (typeof input === "boolean")
	            return payload;
	        payload.issues.push({
	            expected: "boolean",
	            code: "invalid_type",
	            input,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodBigInt = core.$constructor("$ZodBigInt", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.pattern = regexes.bigint;
	    inst._zod.parse = (payload, _ctx) => {
	        if (def.coerce)
	            try {
	                payload.value = BigInt(payload.value);
	            }
	            catch (_) { }
	        if (typeof payload.value === "bigint")
	            return payload;
	        payload.issues.push({
	            expected: "bigint",
	            code: "invalid_type",
	            input: payload.value,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodBigIntFormat = core.$constructor("$ZodBigInt", (inst, def) => {
	    checks.$ZodCheckBigIntFormat.init(inst, def);
	    exports.$ZodBigInt.init(inst, def); // no format checks
	});
	exports.$ZodSymbol = core.$constructor("$ZodSymbol", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, _ctx) => {
	        const input = payload.value;
	        if (typeof input === "symbol")
	            return payload;
	        payload.issues.push({
	            expected: "symbol",
	            code: "invalid_type",
	            input,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodUndefined = core.$constructor("$ZodUndefined", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.pattern = regexes.undefined;
	    inst._zod.values = new Set([undefined]);
	    inst._zod.optin = "optional";
	    inst._zod.optout = "optional";
	    inst._zod.parse = (payload, _ctx) => {
	        const input = payload.value;
	        if (typeof input === "undefined")
	            return payload;
	        payload.issues.push({
	            expected: "undefined",
	            code: "invalid_type",
	            input,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodNull = core.$constructor("$ZodNull", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.pattern = regexes.null;
	    inst._zod.values = new Set([null]);
	    inst._zod.parse = (payload, _ctx) => {
	        const input = payload.value;
	        if (input === null)
	            return payload;
	        payload.issues.push({
	            expected: "null",
	            code: "invalid_type",
	            input,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodAny = core.$constructor("$ZodAny", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload) => payload;
	});
	exports.$ZodUnknown = core.$constructor("$ZodUnknown", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload) => payload;
	});
	exports.$ZodNever = core.$constructor("$ZodNever", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, _ctx) => {
	        payload.issues.push({
	            expected: "never",
	            code: "invalid_type",
	            input: payload.value,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodVoid = core.$constructor("$ZodVoid", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, _ctx) => {
	        const input = payload.value;
	        if (typeof input === "undefined")
	            return payload;
	        payload.issues.push({
	            expected: "void",
	            code: "invalid_type",
	            input,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodDate = core.$constructor("$ZodDate", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, _ctx) => {
	        if (def.coerce) {
	            try {
	                payload.value = new Date(payload.value);
	            }
	            catch (_err) { }
	        }
	        const input = payload.value;
	        const isDate = input instanceof Date;
	        const isValidDate = isDate && !Number.isNaN(input.getTime());
	        if (isValidDate)
	            return payload;
	        payload.issues.push({
	            expected: "date",
	            code: "invalid_type",
	            input,
	            ...(isDate ? { received: "Invalid Date" } : {}),
	            inst,
	        });
	        return payload;
	    };
	});
	function handleArrayResult(result, final, index) {
	    if (result.issues.length) {
	        final.issues.push(...util.prefixIssues(index, result.issues));
	    }
	    final.value[index] = result.value;
	}
	exports.$ZodArray = core.$constructor("$ZodArray", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, ctx) => {
	        const input = payload.value;
	        if (!Array.isArray(input)) {
	            payload.issues.push({
	                expected: "array",
	                code: "invalid_type",
	                input,
	                inst,
	            });
	            return payload;
	        }
	        payload.value = Array(input.length);
	        const proms = [];
	        for (let i = 0; i < input.length; i++) {
	            const item = input[i];
	            const result = def.element._zod.run({
	                value: item,
	                issues: [],
	            }, ctx);
	            if (result instanceof Promise) {
	                proms.push(result.then((result) => handleArrayResult(result, payload, i)));
	            }
	            else {
	                handleArrayResult(result, payload, i);
	            }
	        }
	        if (proms.length) {
	            return Promise.all(proms).then(() => payload);
	        }
	        return payload; //handleArrayResultsAsync(parseResults, final);
	    };
	});
	function handlePropertyResult(result, final, key, input) {
	    if (result.issues.length) {
	        final.issues.push(...util.prefixIssues(key, result.issues));
	    }
	    if (result.value === undefined) {
	        if (key in input) {
	            final.value[key] = undefined;
	        }
	    }
	    else {
	        final.value[key] = result.value;
	    }
	}
	function normalizeDef(def) {
	    const keys = Object.keys(def.shape);
	    for (const k of keys) {
	        if (!def.shape[k]._zod.traits.has("$ZodType")) {
	            throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
	        }
	    }
	    const okeys = util.optionalKeys(def.shape);
	    return {
	        ...def,
	        keys,
	        keySet: new Set(keys),
	        numKeys: keys.length,
	        optionalKeys: new Set(okeys),
	    };
	}
	function handleCatchall(proms, input, payload, ctx, def, inst) {
	    const unrecognized = [];
	    // iterate over input keys
	    const keySet = def.keySet;
	    const _catchall = def.catchall._zod;
	    const t = _catchall.def.type;
	    for (const key of Object.keys(input)) {
	        if (keySet.has(key))
	            continue;
	        if (t === "never") {
	            unrecognized.push(key);
	            continue;
	        }
	        const r = _catchall.run({ value: input[key], issues: [] }, ctx);
	        if (r instanceof Promise) {
	            proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
	        }
	        else {
	            handlePropertyResult(r, payload, key, input);
	        }
	    }
	    if (unrecognized.length) {
	        payload.issues.push({
	            code: "unrecognized_keys",
	            keys: unrecognized,
	            input,
	            inst,
	        });
	    }
	    if (!proms.length)
	        return payload;
	    return Promise.all(proms).then(() => {
	        return payload;
	    });
	}
	exports.$ZodObject = core.$constructor("$ZodObject", (inst, def) => {
	    // requires cast because technically $ZodObject doesn't extend
	    exports.$ZodType.init(inst, def);
	    const _normalized = util.cached(() => normalizeDef(def));
	    util.defineLazy(inst._zod, "propValues", () => {
	        const shape = def.shape;
	        const propValues = {};
	        for (const key in shape) {
	            const field = shape[key]._zod;
	            if (field.values) {
	                propValues[key] ?? (propValues[key] = new Set());
	                for (const v of field.values)
	                    propValues[key].add(v);
	            }
	        }
	        return propValues;
	    });
	    const isObject = util.isObject;
	    const catchall = def.catchall;
	    let value;
	    inst._zod.parse = (payload, ctx) => {
	        value ?? (value = _normalized.value);
	        const input = payload.value;
	        if (!isObject(input)) {
	            payload.issues.push({
	                expected: "object",
	                code: "invalid_type",
	                input,
	                inst,
	            });
	            return payload;
	        }
	        payload.value = {};
	        const proms = [];
	        const shape = value.shape;
	        for (const key of value.keys) {
	            const el = shape[key];
	            const r = el._zod.run({ value: input[key], issues: [] }, ctx);
	            if (r instanceof Promise) {
	                proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
	            }
	            else {
	                handlePropertyResult(r, payload, key, input);
	            }
	        }
	        if (!catchall) {
	            return proms.length ? Promise.all(proms).then(() => payload) : payload;
	        }
	        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
	    };
	});
	exports.$ZodObjectJIT = core.$constructor("$ZodObjectJIT", (inst, def) => {
	    // requires cast because technically $ZodObject doesn't extend
	    exports.$ZodObject.init(inst, def);
	    const superParse = inst._zod.parse;
	    const _normalized = util.cached(() => normalizeDef(def));
	    const generateFastpass = (shape) => {
	        const doc = new doc_js_1.Doc(["shape", "payload", "ctx"]);
	        const normalized = _normalized.value;
	        const parseStr = (key) => {
	            const k = util.esc(key);
	            return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
	        };
	        doc.write(`const input = payload.value;`);
	        const ids = Object.create(null);
	        let counter = 0;
	        for (const key of normalized.keys) {
	            ids[key] = `key_${counter++}`;
	        }
	        // A: preserve key order {
	        doc.write(`const newResult = {}`);
	        for (const key of normalized.keys) {
	            const id = ids[key];
	            const k = util.esc(key);
	            doc.write(`const ${id} = ${parseStr(key)};`);
	            doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
      `);
	        }
	        doc.write(`payload.value = newResult;`);
	        doc.write(`return payload;`);
	        const fn = doc.compile();
	        return (payload, ctx) => fn(shape, payload, ctx);
	    };
	    let fastpass;
	    const isObject = util.isObject;
	    const jit = !core.globalConfig.jitless;
	    const allowsEval = util.allowsEval;
	    const fastEnabled = jit && allowsEval.value; // && !def.catchall;
	    const catchall = def.catchall;
	    let value;
	    inst._zod.parse = (payload, ctx) => {
	        value ?? (value = _normalized.value);
	        const input = payload.value;
	        if (!isObject(input)) {
	            payload.issues.push({
	                expected: "object",
	                code: "invalid_type",
	                input,
	                inst,
	            });
	            return payload;
	        }
	        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
	            // always synchronous
	            if (!fastpass)
	                fastpass = generateFastpass(def.shape);
	            payload = fastpass(payload, ctx);
	            if (!catchall)
	                return payload;
	            return handleCatchall([], input, payload, ctx, value, inst);
	        }
	        return superParse(payload, ctx);
	    };
	});
	function handleUnionResults(results, final, inst, ctx) {
	    for (const result of results) {
	        if (result.issues.length === 0) {
	            final.value = result.value;
	            return final;
	        }
	    }
	    const nonaborted = results.filter((r) => !util.aborted(r));
	    if (nonaborted.length === 1) {
	        final.value = nonaborted[0].value;
	        return nonaborted[0];
	    }
	    final.issues.push({
	        code: "invalid_union",
	        input: final.value,
	        inst,
	        errors: results.map((result) => result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),
	    });
	    return final;
	}
	exports.$ZodUnion = core.$constructor("$ZodUnion", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    util.defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
	    util.defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
	    util.defineLazy(inst._zod, "values", () => {
	        if (def.options.every((o) => o._zod.values)) {
	            return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
	        }
	        return undefined;
	    });
	    util.defineLazy(inst._zod, "pattern", () => {
	        if (def.options.every((o) => o._zod.pattern)) {
	            const patterns = def.options.map((o) => o._zod.pattern);
	            return new RegExp(`^(${patterns.map((p) => util.cleanRegex(p.source)).join("|")})$`);
	        }
	        return undefined;
	    });
	    const single = def.options.length === 1;
	    const first = def.options[0]._zod.run;
	    inst._zod.parse = (payload, ctx) => {
	        if (single) {
	            return first(payload, ctx);
	        }
	        let async = false;
	        const results = [];
	        for (const option of def.options) {
	            const result = option._zod.run({
	                value: payload.value,
	                issues: [],
	            }, ctx);
	            if (result instanceof Promise) {
	                results.push(result);
	                async = true;
	            }
	            else {
	                if (result.issues.length === 0)
	                    return result;
	                results.push(result);
	            }
	        }
	        if (!async)
	            return handleUnionResults(results, payload, inst, ctx);
	        return Promise.all(results).then((results) => {
	            return handleUnionResults(results, payload, inst, ctx);
	        });
	    };
	});
	exports.$ZodDiscriminatedUnion = 
	/*@__PURE__*/
	core.$constructor("$ZodDiscriminatedUnion", (inst, def) => {
	    exports.$ZodUnion.init(inst, def);
	    const _super = inst._zod.parse;
	    util.defineLazy(inst._zod, "propValues", () => {
	        const propValues = {};
	        for (const option of def.options) {
	            const pv = option._zod.propValues;
	            if (!pv || Object.keys(pv).length === 0)
	                throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
	            for (const [k, v] of Object.entries(pv)) {
	                if (!propValues[k])
	                    propValues[k] = new Set();
	                for (const val of v) {
	                    propValues[k].add(val);
	                }
	            }
	        }
	        return propValues;
	    });
	    const disc = util.cached(() => {
	        const opts = def.options;
	        const map = new Map();
	        for (const o of opts) {
	            const values = o._zod.propValues?.[def.discriminator];
	            if (!values || values.size === 0)
	                throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
	            for (const v of values) {
	                if (map.has(v)) {
	                    throw new Error(`Duplicate discriminator value "${String(v)}"`);
	                }
	                map.set(v, o);
	            }
	        }
	        return map;
	    });
	    inst._zod.parse = (payload, ctx) => {
	        const input = payload.value;
	        if (!util.isObject(input)) {
	            payload.issues.push({
	                code: "invalid_type",
	                expected: "object",
	                input,
	                inst,
	            });
	            return payload;
	        }
	        const opt = disc.value.get(input?.[def.discriminator]);
	        if (opt) {
	            return opt._zod.run(payload, ctx);
	        }
	        if (def.unionFallback) {
	            return _super(payload, ctx);
	        }
	        // no matching discriminator
	        payload.issues.push({
	            code: "invalid_union",
	            errors: [],
	            note: "No matching discriminator",
	            discriminator: def.discriminator,
	            input,
	            path: [def.discriminator],
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodIntersection = core.$constructor("$ZodIntersection", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, ctx) => {
	        const input = payload.value;
	        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
	        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
	        const async = left instanceof Promise || right instanceof Promise;
	        if (async) {
	            return Promise.all([left, right]).then(([left, right]) => {
	                return handleIntersectionResults(payload, left, right);
	            });
	        }
	        return handleIntersectionResults(payload, left, right);
	    };
	});
	function mergeValues(a, b) {
	    // const aType = parse.t(a);
	    // const bType = parse.t(b);
	    if (a === b) {
	        return { valid: true, data: a };
	    }
	    if (a instanceof Date && b instanceof Date && +a === +b) {
	        return { valid: true, data: a };
	    }
	    if (util.isPlainObject(a) && util.isPlainObject(b)) {
	        const bKeys = Object.keys(b);
	        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
	        const newObj = { ...a, ...b };
	        for (const key of sharedKeys) {
	            const sharedValue = mergeValues(a[key], b[key]);
	            if (!sharedValue.valid) {
	                return {
	                    valid: false,
	                    mergeErrorPath: [key, ...sharedValue.mergeErrorPath],
	                };
	            }
	            newObj[key] = sharedValue.data;
	        }
	        return { valid: true, data: newObj };
	    }
	    if (Array.isArray(a) && Array.isArray(b)) {
	        if (a.length !== b.length) {
	            return { valid: false, mergeErrorPath: [] };
	        }
	        const newArray = [];
	        for (let index = 0; index < a.length; index++) {
	            const itemA = a[index];
	            const itemB = b[index];
	            const sharedValue = mergeValues(itemA, itemB);
	            if (!sharedValue.valid) {
	                return {
	                    valid: false,
	                    mergeErrorPath: [index, ...sharedValue.mergeErrorPath],
	                };
	            }
	            newArray.push(sharedValue.data);
	        }
	        return { valid: true, data: newArray };
	    }
	    return { valid: false, mergeErrorPath: [] };
	}
	function handleIntersectionResults(result, left, right) {
	    if (left.issues.length) {
	        result.issues.push(...left.issues);
	    }
	    if (right.issues.length) {
	        result.issues.push(...right.issues);
	    }
	    if (util.aborted(result))
	        return result;
	    const merged = mergeValues(left.value, right.value);
	    if (!merged.valid) {
	        throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
	    }
	    result.value = merged.data;
	    return result;
	}
	exports.$ZodTuple = core.$constructor("$ZodTuple", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    const items = def.items;
	    const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
	    inst._zod.parse = (payload, ctx) => {
	        const input = payload.value;
	        if (!Array.isArray(input)) {
	            payload.issues.push({
	                input,
	                inst,
	                expected: "tuple",
	                code: "invalid_type",
	            });
	            return payload;
	        }
	        payload.value = [];
	        const proms = [];
	        if (!def.rest) {
	            const tooBig = input.length > items.length;
	            const tooSmall = input.length < optStart - 1;
	            if (tooBig || tooSmall) {
	                payload.issues.push({
	                    ...(tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }),
	                    input,
	                    inst,
	                    origin: "array",
	                });
	                return payload;
	            }
	        }
	        let i = -1;
	        for (const item of items) {
	            i++;
	            if (i >= input.length)
	                if (i >= optStart)
	                    continue;
	            const result = item._zod.run({
	                value: input[i],
	                issues: [],
	            }, ctx);
	            if (result instanceof Promise) {
	                proms.push(result.then((result) => handleTupleResult(result, payload, i)));
	            }
	            else {
	                handleTupleResult(result, payload, i);
	            }
	        }
	        if (def.rest) {
	            const rest = input.slice(items.length);
	            for (const el of rest) {
	                i++;
	                const result = def.rest._zod.run({
	                    value: el,
	                    issues: [],
	                }, ctx);
	                if (result instanceof Promise) {
	                    proms.push(result.then((result) => handleTupleResult(result, payload, i)));
	                }
	                else {
	                    handleTupleResult(result, payload, i);
	                }
	            }
	        }
	        if (proms.length)
	            return Promise.all(proms).then(() => payload);
	        return payload;
	    };
	});
	function handleTupleResult(result, final, index) {
	    if (result.issues.length) {
	        final.issues.push(...util.prefixIssues(index, result.issues));
	    }
	    final.value[index] = result.value;
	}
	exports.$ZodRecord = core.$constructor("$ZodRecord", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, ctx) => {
	        const input = payload.value;
	        if (!util.isPlainObject(input)) {
	            payload.issues.push({
	                expected: "record",
	                code: "invalid_type",
	                input,
	                inst,
	            });
	            return payload;
	        }
	        const proms = [];
	        if (def.keyType._zod.values) {
	            const values = def.keyType._zod.values;
	            payload.value = {};
	            for (const key of values) {
	                if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
	                    const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
	                    if (result instanceof Promise) {
	                        proms.push(result.then((result) => {
	                            if (result.issues.length) {
	                                payload.issues.push(...util.prefixIssues(key, result.issues));
	                            }
	                            payload.value[key] = result.value;
	                        }));
	                    }
	                    else {
	                        if (result.issues.length) {
	                            payload.issues.push(...util.prefixIssues(key, result.issues));
	                        }
	                        payload.value[key] = result.value;
	                    }
	                }
	            }
	            let unrecognized;
	            for (const key in input) {
	                if (!values.has(key)) {
	                    unrecognized = unrecognized ?? [];
	                    unrecognized.push(key);
	                }
	            }
	            if (unrecognized && unrecognized.length > 0) {
	                payload.issues.push({
	                    code: "unrecognized_keys",
	                    input,
	                    inst,
	                    keys: unrecognized,
	                });
	            }
	        }
	        else {
	            payload.value = {};
	            for (const key of Reflect.ownKeys(input)) {
	                if (key === "__proto__")
	                    continue;
	                const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
	                if (keyResult instanceof Promise) {
	                    throw new Error("Async schemas not supported in object keys currently");
	                }
	                if (keyResult.issues.length) {
	                    payload.issues.push({
	                        code: "invalid_key",
	                        origin: "record",
	                        issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),
	                        input: key,
	                        path: [key],
	                        inst,
	                    });
	                    payload.value[keyResult.value] = keyResult.value;
	                    continue;
	                }
	                const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
	                if (result instanceof Promise) {
	                    proms.push(result.then((result) => {
	                        if (result.issues.length) {
	                            payload.issues.push(...util.prefixIssues(key, result.issues));
	                        }
	                        payload.value[keyResult.value] = result.value;
	                    }));
	                }
	                else {
	                    if (result.issues.length) {
	                        payload.issues.push(...util.prefixIssues(key, result.issues));
	                    }
	                    payload.value[keyResult.value] = result.value;
	                }
	            }
	        }
	        if (proms.length) {
	            return Promise.all(proms).then(() => payload);
	        }
	        return payload;
	    };
	});
	exports.$ZodMap = core.$constructor("$ZodMap", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, ctx) => {
	        const input = payload.value;
	        if (!(input instanceof Map)) {
	            payload.issues.push({
	                expected: "map",
	                code: "invalid_type",
	                input,
	                inst,
	            });
	            return payload;
	        }
	        const proms = [];
	        payload.value = new Map();
	        for (const [key, value] of input) {
	            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
	            const valueResult = def.valueType._zod.run({ value: value, issues: [] }, ctx);
	            if (keyResult instanceof Promise || valueResult instanceof Promise) {
	                proms.push(Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {
	                    handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
	                }));
	            }
	            else {
	                handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
	            }
	        }
	        if (proms.length)
	            return Promise.all(proms).then(() => payload);
	        return payload;
	    };
	});
	function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
	    if (keyResult.issues.length) {
	        if (util.propertyKeyTypes.has(typeof key)) {
	            final.issues.push(...util.prefixIssues(key, keyResult.issues));
	        }
	        else {
	            final.issues.push({
	                code: "invalid_key",
	                origin: "map",
	                input,
	                inst,
	                issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),
	            });
	        }
	    }
	    if (valueResult.issues.length) {
	        if (util.propertyKeyTypes.has(typeof key)) {
	            final.issues.push(...util.prefixIssues(key, valueResult.issues));
	        }
	        else {
	            final.issues.push({
	                origin: "map",
	                code: "invalid_element",
	                input,
	                inst,
	                key: key,
	                issues: valueResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),
	            });
	        }
	    }
	    final.value.set(keyResult.value, valueResult.value);
	}
	exports.$ZodSet = core.$constructor("$ZodSet", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, ctx) => {
	        const input = payload.value;
	        if (!(input instanceof Set)) {
	            payload.issues.push({
	                input,
	                inst,
	                expected: "set",
	                code: "invalid_type",
	            });
	            return payload;
	        }
	        const proms = [];
	        payload.value = new Set();
	        for (const item of input) {
	            const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
	            if (result instanceof Promise) {
	                proms.push(result.then((result) => handleSetResult(result, payload)));
	            }
	            else
	                handleSetResult(result, payload);
	        }
	        if (proms.length)
	            return Promise.all(proms).then(() => payload);
	        return payload;
	    };
	});
	function handleSetResult(result, final) {
	    if (result.issues.length) {
	        final.issues.push(...result.issues);
	    }
	    final.value.add(result.value);
	}
	exports.$ZodEnum = core.$constructor("$ZodEnum", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    const values = util.getEnumValues(def.entries);
	    const valuesSet = new Set(values);
	    inst._zod.values = valuesSet;
	    inst._zod.pattern = new RegExp(`^(${values
	        .filter((k) => util.propertyKeyTypes.has(typeof k))
	        .map((o) => (typeof o === "string" ? util.escapeRegex(o) : o.toString()))
	        .join("|")})$`);
	    inst._zod.parse = (payload, _ctx) => {
	        const input = payload.value;
	        if (valuesSet.has(input)) {
	            return payload;
	        }
	        payload.issues.push({
	            code: "invalid_value",
	            values,
	            input,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodLiteral = core.$constructor("$ZodLiteral", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    if (def.values.length === 0) {
	        throw new Error("Cannot create literal schema with no valid values");
	    }
	    inst._zod.values = new Set(def.values);
	    inst._zod.pattern = new RegExp(`^(${def.values
	        .map((o) => (typeof o === "string" ? util.escapeRegex(o) : o ? util.escapeRegex(o.toString()) : String(o)))
	        .join("|")})$`);
	    inst._zod.parse = (payload, _ctx) => {
	        const input = payload.value;
	        if (inst._zod.values.has(input)) {
	            return payload;
	        }
	        payload.issues.push({
	            code: "invalid_value",
	            values: def.values,
	            input,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodFile = core.$constructor("$ZodFile", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, _ctx) => {
	        const input = payload.value;
	        // @ts-ignore
	        if (input instanceof File)
	            return payload;
	        payload.issues.push({
	            expected: "file",
	            code: "invalid_type",
	            input,
	            inst,
	        });
	        return payload;
	    };
	});
	exports.$ZodTransform = core.$constructor("$ZodTransform", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, ctx) => {
	        if (ctx.direction === "backward") {
	            throw new core.$ZodEncodeError(inst.constructor.name);
	        }
	        const _out = def.transform(payload.value, payload);
	        if (ctx.async) {
	            const output = _out instanceof Promise ? _out : Promise.resolve(_out);
	            return output.then((output) => {
	                payload.value = output;
	                return payload;
	            });
	        }
	        if (_out instanceof Promise) {
	            throw new core.$ZodAsyncError();
	        }
	        payload.value = _out;
	        return payload;
	    };
	});
	function handleOptionalResult(result, input) {
	    if (result.issues.length && input === undefined) {
	        return { issues: [], value: undefined };
	    }
	    return result;
	}
	exports.$ZodOptional = core.$constructor("$ZodOptional", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.optin = "optional";
	    inst._zod.optout = "optional";
	    util.defineLazy(inst._zod, "values", () => {
	        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
	    });
	    util.defineLazy(inst._zod, "pattern", () => {
	        const pattern = def.innerType._zod.pattern;
	        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)})?$`) : undefined;
	    });
	    inst._zod.parse = (payload, ctx) => {
	        if (def.innerType._zod.optin === "optional") {
	            const result = def.innerType._zod.run(payload, ctx);
	            if (result instanceof Promise)
	                return result.then((r) => handleOptionalResult(r, payload.value));
	            return handleOptionalResult(result, payload.value);
	        }
	        if (payload.value === undefined) {
	            return payload;
	        }
	        return def.innerType._zod.run(payload, ctx);
	    };
	});
	exports.$ZodNullable = core.$constructor("$ZodNullable", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    util.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	    util.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	    util.defineLazy(inst._zod, "pattern", () => {
	        const pattern = def.innerType._zod.pattern;
	        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)}|null)$`) : undefined;
	    });
	    util.defineLazy(inst._zod, "values", () => {
	        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
	    });
	    inst._zod.parse = (payload, ctx) => {
	        // Forward direction (decode): allow null to pass through
	        if (payload.value === null)
	            return payload;
	        return def.innerType._zod.run(payload, ctx);
	    };
	});
	exports.$ZodDefault = core.$constructor("$ZodDefault", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    // inst._zod.qin = "true";
	    inst._zod.optin = "optional";
	    util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	    inst._zod.parse = (payload, ctx) => {
	        if (ctx.direction === "backward") {
	            return def.innerType._zod.run(payload, ctx);
	        }
	        // Forward direction (decode): apply defaults for undefined input
	        if (payload.value === undefined) {
	            payload.value = def.defaultValue;
	            /**
	             * $ZodDefault returns the default value immediately in forward direction.
	             * It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
	            return payload;
	        }
	        // Forward direction: continue with default handling
	        const result = def.innerType._zod.run(payload, ctx);
	        if (result instanceof Promise) {
	            return result.then((result) => handleDefaultResult(result, def));
	        }
	        return handleDefaultResult(result, def);
	    };
	});
	function handleDefaultResult(payload, def) {
	    if (payload.value === undefined) {
	        payload.value = def.defaultValue;
	    }
	    return payload;
	}
	exports.$ZodPrefault = core.$constructor("$ZodPrefault", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.optin = "optional";
	    util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	    inst._zod.parse = (payload, ctx) => {
	        if (ctx.direction === "backward") {
	            return def.innerType._zod.run(payload, ctx);
	        }
	        // Forward direction (decode): apply prefault for undefined input
	        if (payload.value === undefined) {
	            payload.value = def.defaultValue;
	        }
	        return def.innerType._zod.run(payload, ctx);
	    };
	});
	exports.$ZodNonOptional = core.$constructor("$ZodNonOptional", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    util.defineLazy(inst._zod, "values", () => {
	        const v = def.innerType._zod.values;
	        return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
	    });
	    inst._zod.parse = (payload, ctx) => {
	        const result = def.innerType._zod.run(payload, ctx);
	        if (result instanceof Promise) {
	            return result.then((result) => handleNonOptionalResult(result, inst));
	        }
	        return handleNonOptionalResult(result, inst);
	    };
	});
	function handleNonOptionalResult(payload, inst) {
	    if (!payload.issues.length && payload.value === undefined) {
	        payload.issues.push({
	            code: "invalid_type",
	            expected: "nonoptional",
	            input: payload.value,
	            inst,
	        });
	    }
	    return payload;
	}
	exports.$ZodSuccess = core.$constructor("$ZodSuccess", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, ctx) => {
	        if (ctx.direction === "backward") {
	            throw new core.$ZodEncodeError("ZodSuccess");
	        }
	        const result = def.innerType._zod.run(payload, ctx);
	        if (result instanceof Promise) {
	            return result.then((result) => {
	                payload.value = result.issues.length === 0;
	                return payload;
	            });
	        }
	        payload.value = result.issues.length === 0;
	        return payload;
	    };
	});
	exports.$ZodCatch = core.$constructor("$ZodCatch", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    util.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	    util.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	    util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	    inst._zod.parse = (payload, ctx) => {
	        if (ctx.direction === "backward") {
	            return def.innerType._zod.run(payload, ctx);
	        }
	        // Forward direction (decode): apply catch logic
	        const result = def.innerType._zod.run(payload, ctx);
	        if (result instanceof Promise) {
	            return result.then((result) => {
	                payload.value = result.value;
	                if (result.issues.length) {
	                    payload.value = def.catchValue({
	                        ...payload,
	                        error: {
	                            issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),
	                        },
	                        input: payload.value,
	                    });
	                    payload.issues = [];
	                }
	                return payload;
	            });
	        }
	        payload.value = result.value;
	        if (result.issues.length) {
	            payload.value = def.catchValue({
	                ...payload,
	                error: {
	                    issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),
	                },
	                input: payload.value,
	            });
	            payload.issues = [];
	        }
	        return payload;
	    };
	});
	exports.$ZodNaN = core.$constructor("$ZodNaN", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, _ctx) => {
	        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
	            payload.issues.push({
	                input: payload.value,
	                inst,
	                expected: "nan",
	                code: "invalid_type",
	            });
	            return payload;
	        }
	        return payload;
	    };
	});
	exports.$ZodPipe = core.$constructor("$ZodPipe", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    util.defineLazy(inst._zod, "values", () => def.in._zod.values);
	    util.defineLazy(inst._zod, "optin", () => def.in._zod.optin);
	    util.defineLazy(inst._zod, "optout", () => def.out._zod.optout);
	    util.defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
	    inst._zod.parse = (payload, ctx) => {
	        if (ctx.direction === "backward") {
	            const right = def.out._zod.run(payload, ctx);
	            if (right instanceof Promise) {
	                return right.then((right) => handlePipeResult(right, def.in, ctx));
	            }
	            return handlePipeResult(right, def.in, ctx);
	        }
	        const left = def.in._zod.run(payload, ctx);
	        if (left instanceof Promise) {
	            return left.then((left) => handlePipeResult(left, def.out, ctx));
	        }
	        return handlePipeResult(left, def.out, ctx);
	    };
	});
	function handlePipeResult(left, next, ctx) {
	    if (left.issues.length) {
	        // prevent further checks
	        left.aborted = true;
	        return left;
	    }
	    return next._zod.run({ value: left.value, issues: left.issues }, ctx);
	}
	exports.$ZodCodec = core.$constructor("$ZodCodec", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    util.defineLazy(inst._zod, "values", () => def.in._zod.values);
	    util.defineLazy(inst._zod, "optin", () => def.in._zod.optin);
	    util.defineLazy(inst._zod, "optout", () => def.out._zod.optout);
	    util.defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
	    inst._zod.parse = (payload, ctx) => {
	        const direction = ctx.direction || "forward";
	        if (direction === "forward") {
	            const left = def.in._zod.run(payload, ctx);
	            if (left instanceof Promise) {
	                return left.then((left) => handleCodecAResult(left, def, ctx));
	            }
	            return handleCodecAResult(left, def, ctx);
	        }
	        else {
	            const right = def.out._zod.run(payload, ctx);
	            if (right instanceof Promise) {
	                return right.then((right) => handleCodecAResult(right, def, ctx));
	            }
	            return handleCodecAResult(right, def, ctx);
	        }
	    };
	});
	function handleCodecAResult(result, def, ctx) {
	    if (result.issues.length) {
	        // prevent further checks
	        result.aborted = true;
	        return result;
	    }
	    const direction = ctx.direction || "forward";
	    if (direction === "forward") {
	        const transformed = def.transform(result.value, result);
	        if (transformed instanceof Promise) {
	            return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
	        }
	        return handleCodecTxResult(result, transformed, def.out, ctx);
	    }
	    else {
	        const transformed = def.reverseTransform(result.value, result);
	        if (transformed instanceof Promise) {
	            return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
	        }
	        return handleCodecTxResult(result, transformed, def.in, ctx);
	    }
	}
	function handleCodecTxResult(left, value, nextSchema, ctx) {
	    // Check if transform added any issues
	    if (left.issues.length) {
	        left.aborted = true;
	        return left;
	    }
	    return nextSchema._zod.run({ value, issues: left.issues }, ctx);
	}
	exports.$ZodReadonly = core.$constructor("$ZodReadonly", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    util.defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
	    util.defineLazy(inst._zod, "values", () => def.innerType._zod.values);
	    util.defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
	    util.defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
	    inst._zod.parse = (payload, ctx) => {
	        if (ctx.direction === "backward") {
	            return def.innerType._zod.run(payload, ctx);
	        }
	        const result = def.innerType._zod.run(payload, ctx);
	        if (result instanceof Promise) {
	            return result.then(handleReadonlyResult);
	        }
	        return handleReadonlyResult(result);
	    };
	});
	function handleReadonlyResult(payload) {
	    payload.value = Object.freeze(payload.value);
	    return payload;
	}
	exports.$ZodTemplateLiteral = core.$constructor("$ZodTemplateLiteral", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    const regexParts = [];
	    for (const part of def.parts) {
	        if (typeof part === "object" && part !== null) {
	            // is Zod schema
	            if (!part._zod.pattern) {
	                // if (!source)
	                throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
	            }
	            const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
	            if (!source)
	                throw new Error(`Invalid template literal part: ${part._zod.traits}`);
	            const start = source.startsWith("^") ? 1 : 0;
	            const end = source.endsWith("$") ? source.length - 1 : source.length;
	            regexParts.push(source.slice(start, end));
	        }
	        else if (part === null || util.primitiveTypes.has(typeof part)) {
	            regexParts.push(util.escapeRegex(`${part}`));
	        }
	        else {
	            throw new Error(`Invalid template literal part: ${part}`);
	        }
	    }
	    inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
	    inst._zod.parse = (payload, _ctx) => {
	        if (typeof payload.value !== "string") {
	            payload.issues.push({
	                input: payload.value,
	                inst,
	                expected: "template_literal",
	                code: "invalid_type",
	            });
	            return payload;
	        }
	        inst._zod.pattern.lastIndex = 0;
	        if (!inst._zod.pattern.test(payload.value)) {
	            payload.issues.push({
	                input: payload.value,
	                inst,
	                code: "invalid_format",
	                format: def.format ?? "template_literal",
	                pattern: inst._zod.pattern.source,
	            });
	            return payload;
	        }
	        return payload;
	    };
	});
	exports.$ZodFunction = core.$constructor("$ZodFunction", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._def = def;
	    inst._zod.def = def;
	    inst.implement = (func) => {
	        if (typeof func !== "function") {
	            throw new Error("implement() must be called with a function");
	        }
	        return function (...args) {
	            const parsedArgs = inst._def.input ? (0, parse_js_1.parse)(inst._def.input, args) : args;
	            const result = Reflect.apply(func, this, parsedArgs);
	            if (inst._def.output) {
	                return (0, parse_js_1.parse)(inst._def.output, result);
	            }
	            return result;
	        };
	    };
	    inst.implementAsync = (func) => {
	        if (typeof func !== "function") {
	            throw new Error("implementAsync() must be called with a function");
	        }
	        return async function (...args) {
	            const parsedArgs = inst._def.input ? await (0, parse_js_1.parseAsync)(inst._def.input, args) : args;
	            const result = await Reflect.apply(func, this, parsedArgs);
	            if (inst._def.output) {
	                return await (0, parse_js_1.parseAsync)(inst._def.output, result);
	            }
	            return result;
	        };
	    };
	    inst._zod.parse = (payload, _ctx) => {
	        if (typeof payload.value !== "function") {
	            payload.issues.push({
	                code: "invalid_type",
	                expected: "function",
	                input: payload.value,
	                inst,
	            });
	            return payload;
	        }
	        // Check if output is a promise type to determine if we should use async implementation
	        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
	        if (hasPromiseOutput) {
	            payload.value = inst.implementAsync(payload.value);
	        }
	        else {
	            payload.value = inst.implement(payload.value);
	        }
	        return payload;
	    };
	    inst.input = (...args) => {
	        const F = inst.constructor;
	        if (Array.isArray(args[0])) {
	            return new F({
	                type: "function",
	                input: new exports.$ZodTuple({
	                    type: "tuple",
	                    items: args[0],
	                    rest: args[1],
	                }),
	                output: inst._def.output,
	            });
	        }
	        return new F({
	            type: "function",
	            input: args[0],
	            output: inst._def.output,
	        });
	    };
	    inst.output = (output) => {
	        const F = inst.constructor;
	        return new F({
	            type: "function",
	            input: inst._def.input,
	            output,
	        });
	    };
	    return inst;
	});
	exports.$ZodPromise = core.$constructor("$ZodPromise", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, ctx) => {
	        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
	    };
	});
	exports.$ZodLazy = core.$constructor("$ZodLazy", (inst, def) => {
	    exports.$ZodType.init(inst, def);
	    // let _innerType!: any;
	    // util.defineLazy(def, "getter", () => {
	    //   if (!_innerType) {
	    //     _innerType = def.getter();
	    //   }
	    //   return () => _innerType;
	    // });
	    util.defineLazy(inst._zod, "innerType", () => def.getter());
	    util.defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
	    util.defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
	    util.defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
	    util.defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
	    inst._zod.parse = (payload, ctx) => {
	        const inner = inst._zod.innerType;
	        return inner._zod.run(payload, ctx);
	    };
	});
	exports.$ZodCustom = core.$constructor("$ZodCustom", (inst, def) => {
	    checks.$ZodCheck.init(inst, def);
	    exports.$ZodType.init(inst, def);
	    inst._zod.parse = (payload, _) => {
	        return payload;
	    };
	    inst._zod.check = (payload) => {
	        const input = payload.value;
	        const r = def.fn(input);
	        if (r instanceof Promise) {
	            return r.then((r) => handleRefineResult(r, payload, input, inst));
	        }
	        handleRefineResult(r, payload, input, inst);
	        return;
	    };
	});
	function handleRefineResult(result, payload, input, inst) {
	    if (!result) {
	        const _iss = {
	            code: "custom",
	            input,
	            inst, // incorporates params.error into issue reporting
	            path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting
	            continue: !inst._zod.def.abort,
	            // params: inst._zod.def.params,
	        };
	        if (inst._zod.def.params)
	            _iss.params = inst._zod.def.params;
	        payload.issues.push(util.issue(_iss));
	    }
	} 
} (schemas$4));

var schemas$3 = /*@__PURE__*/getDefaultExportFromCjs(schemas$4);

var locales = {};

var ar$2 = {exports: {}};

var ar = ar$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "حرف", verb: "أن يحوي" },
	        file: { unit: "بايت", verb: "أن يحوي" },
	        array: { unit: "عنصر", verb: "أن يحوي" },
	        set: { unit: "عنصر", verb: "أن يحوي" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "number";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "مدخل",
	        email: "بريد إلكتروني",
	        url: "رابط",
	        emoji: "إيموجي",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "تاريخ ووقت بمعيار ISO",
	        date: "تاريخ بمعيار ISO",
	        time: "وقت بمعيار ISO",
	        duration: "مدة بمعيار ISO",
	        ipv4: "عنوان IPv4",
	        ipv6: "عنوان IPv6",
	        cidrv4: "مدى عناوين بصيغة IPv4",
	        cidrv6: "مدى عناوين بصيغة IPv6",
	        base64: "نَص بترميز base64-encoded",
	        base64url: "نَص بترميز base64url-encoded",
	        json_string: "نَص على هيئة JSON",
	        e164: "رقم هاتف بمعيار E.164",
	        jwt: "JWT",
	        template_literal: "مدخل",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `مدخلات غير مقبولة: يفترض إدخال ${issue.expected}، ولكن تم إدخال ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `مدخلات غير مقبولة: يفترض إدخال ${util.stringifyPrimitive(issue.values[0])}`;
	                return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return ` أكبر من اللازم: يفترض أن تكون ${issue.origin ?? "القيمة"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "عنصر"}`;
	                return `أكبر من اللازم: يفترض أن تكون ${issue.origin ?? "القيمة"} ${adj} ${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `أصغر من اللازم: يفترض لـ ${issue.origin} أن يكون ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `أصغر من اللازم: يفترض لـ ${issue.origin} أن يكون ${adj} ${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `نَص غير مقبول: يجب أن يبدأ بـ "${issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `نَص غير مقبول: يجب أن ينتهي بـ "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `نَص غير مقبول: يجب أن يتضمَّن "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `نَص غير مقبول: يجب أن يطابق النمط ${_issue.pattern}`;
	                return `${Nouns[_issue.format] ?? issue.format} غير مقبول`;
	            }
	            case "not_multiple_of":
	                return `رقم غير مقبول: يجب أن يكون من مضاعفات ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `معرف${issue.keys.length > 1 ? "ات" : ""} غريب${issue.keys.length > 1 ? "ة" : ""}: ${util.joinValues(issue.keys, "، ")}`;
	            case "invalid_key":
	                return `معرف غير مقبول في ${issue.origin}`;
	            case "invalid_union":
	                return "مدخل غير مقبول";
	            case "invalid_element":
	                return `مدخل غير مقبول في ${issue.origin}`;
	            default:
	                return "مدخل غير مقبول";
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ar$2, ar$2.exports));

var arExports = ar$2.exports;
var ar$1 = /*@__PURE__*/getDefaultExportFromCjs(arExports);

var az$2 = {exports: {}};

var az = az$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "simvol", verb: "olmalıdır" },
	        file: { unit: "bayt", verb: "olmalıdır" },
	        array: { unit: "element", verb: "olmalıdır" },
	        set: { unit: "element", verb: "olmalıdır" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "number";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "input",
	        email: "email address",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO datetime",
	        date: "ISO date",
	        time: "ISO time",
	        duration: "ISO duration",
	        ipv4: "IPv4 address",
	        ipv6: "IPv6 address",
	        cidrv4: "IPv4 range",
	        cidrv6: "IPv6 range",
	        base64: "base64-encoded string",
	        base64url: "base64url-encoded string",
	        json_string: "JSON string",
	        e164: "E.164 number",
	        jwt: "JWT",
	        template_literal: "input",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Yanlış dəyər: gözlənilən ${issue.expected}, daxil olan ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Yanlış dəyər: gözlənilən ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Çox böyük: gözlənilən ${issue.origin ?? "dəyər"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element"}`;
	                return `Çox böyük: gözlənilən ${issue.origin ?? "dəyər"} ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Çox kiçik: gözlənilən ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                return `Çox kiçik: gözlənilən ${issue.origin} ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Yanlış mətn: "${_issue.prefix}" ilə başlamalıdır`;
	                if (_issue.format === "ends_with")
	                    return `Yanlış mətn: "${_issue.suffix}" ilə bitməlidir`;
	                if (_issue.format === "includes")
	                    return `Yanlış mətn: "${_issue.includes}" daxil olmalıdır`;
	                if (_issue.format === "regex")
	                    return `Yanlış mətn: ${_issue.pattern} şablonuna uyğun olmalıdır`;
	                return `Yanlış ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Yanlış ədəd: ${issue.divisor} ilə bölünə bilən olmalıdır`;
	            case "unrecognized_keys":
	                return `Tanınmayan açar${issue.keys.length > 1 ? "lar" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `${issue.origin} daxilində yanlış açar`;
	            case "invalid_union":
	                return "Yanlış dəyər";
	            case "invalid_element":
	                return `${issue.origin} daxilində yanlış dəyər`;
	            default:
	                return `Yanlış dəyər`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (az$2, az$2.exports));

var azExports = az$2.exports;
var az$1 = /*@__PURE__*/getDefaultExportFromCjs(azExports);

var be$2 = {exports: {}};

var be = be$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	function getBelarusianPlural(count, one, few, many) {
	    const absCount = Math.abs(count);
	    const lastDigit = absCount % 10;
	    const lastTwoDigits = absCount % 100;
	    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
	        return many;
	    }
	    if (lastDigit === 1) {
	        return one;
	    }
	    if (lastDigit >= 2 && lastDigit <= 4) {
	        return few;
	    }
	    return many;
	}
	const error = () => {
	    const Sizable = {
	        string: {
	            unit: {
	                one: "сімвал",
	                few: "сімвалы",
	                many: "сімвалаў",
	            },
	            verb: "мець",
	        },
	        array: {
	            unit: {
	                one: "элемент",
	                few: "элементы",
	                many: "элементаў",
	            },
	            verb: "мець",
	        },
	        set: {
	            unit: {
	                one: "элемент",
	                few: "элементы",
	                many: "элементаў",
	            },
	            verb: "мець",
	        },
	        file: {
	            unit: {
	                one: "байт",
	                few: "байты",
	                many: "байтаў",
	            },
	            verb: "мець",
	        },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "лік";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "масіў";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "увод",
	        email: "email адрас",
	        url: "URL",
	        emoji: "эмодзі",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO дата і час",
	        date: "ISO дата",
	        time: "ISO час",
	        duration: "ISO працягласць",
	        ipv4: "IPv4 адрас",
	        ipv6: "IPv6 адрас",
	        cidrv4: "IPv4 дыяпазон",
	        cidrv6: "IPv6 дыяпазон",
	        base64: "радок у фармаце base64",
	        base64url: "радок у фармаце base64url",
	        json_string: "JSON радок",
	        e164: "нумар E.164",
	        jwt: "JWT",
	        template_literal: "увод",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Няправільны ўвод: чакаўся ${issue.expected}, атрымана ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Няправільны ўвод: чакалася ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Няправільны варыянт: чакаўся адзін з ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    const maxValue = Number(issue.maximum);
	                    const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
	                    return `Занадта вялікі: чакалася, што ${issue.origin ?? "значэнне"} павінна ${sizing.verb} ${adj}${issue.maximum.toString()} ${unit}`;
	                }
	                return `Занадта вялікі: чакалася, што ${issue.origin ?? "значэнне"} павінна быць ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    const minValue = Number(issue.minimum);
	                    const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
	                    return `Занадта малы: чакалася, што ${issue.origin} павінна ${sizing.verb} ${adj}${issue.minimum.toString()} ${unit}`;
	                }
	                return `Занадта малы: чакалася, што ${issue.origin} павінна быць ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Няправільны радок: павінен пачынацца з "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Няправільны радок: павінен заканчвацца на "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Няправільны радок: павінен змяшчаць "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Няправільны радок: павінен адпавядаць шаблону ${_issue.pattern}`;
	                return `Няправільны ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Няправільны лік: павінен быць кратным ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Нераспазнаны ${issue.keys.length > 1 ? "ключы" : "ключ"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Няправільны ключ у ${issue.origin}`;
	            case "invalid_union":
	                return "Няправільны ўвод";
	            case "invalid_element":
	                return `Няправільнае значэнне ў ${issue.origin}`;
	            default:
	                return `Няправільны ўвод`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (be$2, be$2.exports));

var beExports = be$2.exports;
var be$1 = /*@__PURE__*/getDefaultExportFromCjs(beExports);

var ca$2 = {exports: {}};

var ca = ca$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "caràcters", verb: "contenir" },
	        file: { unit: "bytes", verb: "contenir" },
	        array: { unit: "elements", verb: "contenir" },
	        set: { unit: "elements", verb: "contenir" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "number";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "entrada",
	        email: "adreça electrònica",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "data i hora ISO",
	        date: "data ISO",
	        time: "hora ISO",
	        duration: "durada ISO",
	        ipv4: "adreça IPv4",
	        ipv6: "adreça IPv6",
	        cidrv4: "rang IPv4",
	        cidrv6: "rang IPv6",
	        base64: "cadena codificada en base64",
	        base64url: "cadena codificada en base64url",
	        json_string: "cadena JSON",
	        e164: "número E.164",
	        jwt: "JWT",
	        template_literal: "entrada",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${parsedType(issue.input)}`;
	            // return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Valor invàlid: s'esperava ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Opció invàlida: s'esperava una de ${util.joinValues(issue.values, " o ")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "com a màxim" : "menys de";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Massa gran: s'esperava que ${issue.origin ?? "el valor"} contingués ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
	                return `Massa gran: s'esperava que ${issue.origin ?? "el valor"} fos ${adj} ${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? "com a mínim" : "més de";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Massa petit: s'esperava que ${issue.origin} contingués ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Massa petit: s'esperava que ${issue.origin} fos ${adj} ${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `Format invàlid: ha de començar amb "${_issue.prefix}"`;
	                }
	                if (_issue.format === "ends_with")
	                    return `Format invàlid: ha d'acabar amb "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Format invàlid: ha d'incloure "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Format invàlid: ha de coincidir amb el patró ${_issue.pattern}`;
	                return `Format invàlid per a ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Número invàlid: ha de ser múltiple de ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Clau${issue.keys.length > 1 ? "s" : ""} no reconeguda${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Clau invàlida a ${issue.origin}`;
	            case "invalid_union":
	                return "Entrada invàlida"; // Could also be "Tipus d'unió invàlid" but "Entrada invàlida" is more general
	            case "invalid_element":
	                return `Element invàlid a ${issue.origin}`;
	            default:
	                return `Entrada invàlida`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ca$2, ca$2.exports));

var caExports = ca$2.exports;
var ca$1 = /*@__PURE__*/getDefaultExportFromCjs(caExports);

var cs$2 = {exports: {}};

var cs = cs$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "znaků", verb: "mít" },
	        file: { unit: "bajtů", verb: "mít" },
	        array: { unit: "prvků", verb: "mít" },
	        set: { unit: "prvků", verb: "mít" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "číslo";
	            }
	            case "string": {
	                return "řetězec";
	            }
	            case "boolean": {
	                return "boolean";
	            }
	            case "bigint": {
	                return "bigint";
	            }
	            case "function": {
	                return "funkce";
	            }
	            case "symbol": {
	                return "symbol";
	            }
	            case "undefined": {
	                return "undefined";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "pole";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "regulární výraz",
	        email: "e-mailová adresa",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "datum a čas ve formátu ISO",
	        date: "datum ve formátu ISO",
	        time: "čas ve formátu ISO",
	        duration: "doba trvání ISO",
	        ipv4: "IPv4 adresa",
	        ipv6: "IPv6 adresa",
	        cidrv4: "rozsah IPv4",
	        cidrv6: "rozsah IPv6",
	        base64: "řetězec zakódovaný ve formátu base64",
	        base64url: "řetězec zakódovaný ve formátu base64url",
	        json_string: "řetězec ve formátu JSON",
	        e164: "číslo E.164",
	        jwt: "JWT",
	        template_literal: "vstup",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Neplatný vstup: očekáváno ${issue.expected}, obdrženo ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Neplatný vstup: očekáváno ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Neplatná možnost: očekávána jedna z hodnot ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Hodnota je příliš velká: ${issue.origin ?? "hodnota"} musí mít ${adj}${issue.maximum.toString()} ${sizing.unit ?? "prvků"}`;
	                }
	                return `Hodnota je příliš velká: ${issue.origin ?? "hodnota"} musí být ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Hodnota je příliš malá: ${issue.origin ?? "hodnota"} musí mít ${adj}${issue.minimum.toString()} ${sizing.unit ?? "prvků"}`;
	                }
	                return `Hodnota je příliš malá: ${issue.origin ?? "hodnota"} musí být ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Neplatný řetězec: musí začínat na "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Neplatný řetězec: musí končit na "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Neplatný řetězec: musí obsahovat "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Neplatný řetězec: musí odpovídat vzoru ${_issue.pattern}`;
	                return `Neplatný formát ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Neplatné číslo: musí být násobkem ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Neznámé klíče: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Neplatný klíč v ${issue.origin}`;
	            case "invalid_union":
	                return "Neplatný vstup";
	            case "invalid_element":
	                return `Neplatná hodnota v ${issue.origin}`;
	            default:
	                return `Neplatný vstup`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (cs$2, cs$2.exports));

var csExports = cs$2.exports;
var cs$1 = /*@__PURE__*/getDefaultExportFromCjs(csExports);

var da$2 = {exports: {}};

var da = da$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "tegn", verb: "havde" },
	        file: { unit: "bytes", verb: "havde" },
	        array: { unit: "elementer", verb: "indeholdt" },
	        set: { unit: "elementer", verb: "indeholdt" },
	    };
	    const TypeNames = {
	        string: "streng",
	        number: "tal",
	        boolean: "boolean",
	        array: "liste",
	        object: "objekt",
	        set: "sæt",
	        file: "fil",
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    function getTypeName(type) {
	        return TypeNames[type] ?? type;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "tal";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "liste";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	                return "objekt";
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "input",
	        email: "e-mailadresse",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO dato- og klokkeslæt",
	        date: "ISO-dato",
	        time: "ISO-klokkeslæt",
	        duration: "ISO-varighed",
	        ipv4: "IPv4-område",
	        ipv6: "IPv6-område",
	        cidrv4: "IPv4-spektrum",
	        cidrv6: "IPv6-spektrum",
	        base64: "base64-kodet streng",
	        base64url: "base64url-kodet streng",
	        json_string: "JSON-streng",
	        e164: "E.164-nummer",
	        jwt: "JWT",
	        template_literal: "input",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Ugyldigt input: forventede ${getTypeName(issue.expected)}, fik ${getTypeName(parsedType(issue.input))}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Ugyldig værdi: forventede ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Ugyldigt valg: forventede en af følgende ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                const origin = getTypeName(issue.origin);
	                if (sizing)
	                    return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "elementer"}`;
	                return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                const origin = getTypeName(issue.origin);
	                if (sizing) {
	                    return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `For lille: forventede ${origin} havde ${adj} ${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Ugyldig streng: skal matche mønsteret ${_issue.pattern}`;
	                return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Ugyldigt tal: skal være deleligt med ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `${issue.keys.length > 1 ? "Ukendte nøgler" : "Ukendt nøgle"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Ugyldig nøgle i ${issue.origin}`;
	            case "invalid_union":
	                return "Ugyldigt input: matcher ingen af de tilladte typer";
	            case "invalid_element":
	                return `Ugyldig værdi i ${issue.origin}`;
	            default:
	                return `Ugyldigt input`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (da$2, da$2.exports));

var daExports = da$2.exports;
var da$1 = /*@__PURE__*/getDefaultExportFromCjs(daExports);

var de$2 = {exports: {}};

var de = de$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "Zeichen", verb: "zu haben" },
	        file: { unit: "Bytes", verb: "zu haben" },
	        array: { unit: "Elemente", verb: "zu haben" },
	        set: { unit: "Elemente", verb: "zu haben" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "Zahl";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "Array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "Eingabe",
	        email: "E-Mail-Adresse",
	        url: "URL",
	        emoji: "Emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO-Datum und -Uhrzeit",
	        date: "ISO-Datum",
	        time: "ISO-Uhrzeit",
	        duration: "ISO-Dauer",
	        ipv4: "IPv4-Adresse",
	        ipv6: "IPv6-Adresse",
	        cidrv4: "IPv4-Bereich",
	        cidrv6: "IPv6-Bereich",
	        base64: "Base64-codierter String",
	        base64url: "Base64-URL-codierter String",
	        json_string: "JSON-String",
	        e164: "E.164-Nummer",
	        jwt: "JWT",
	        template_literal: "Eingabe",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Ungültige Eingabe: erwartet ${issue.expected}, erhalten ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Ungültige Eingabe: erwartet ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Ungültige Option: erwartet eine von ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Zu groß: erwartet, dass ${issue.origin ?? "Wert"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
	                return `Zu groß: erwartet, dass ${issue.origin ?? "Wert"} ${adj}${issue.maximum.toString()} ist`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} hat`;
	                }
	                return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ist`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Ungültiger String: muss mit "${_issue.prefix}" beginnen`;
	                if (_issue.format === "ends_with")
	                    return `Ungültiger String: muss mit "${_issue.suffix}" enden`;
	                if (_issue.format === "includes")
	                    return `Ungültiger String: muss "${_issue.includes}" enthalten`;
	                if (_issue.format === "regex")
	                    return `Ungültiger String: muss dem Muster ${_issue.pattern} entsprechen`;
	                return `Ungültig: ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Ungültige Zahl: muss ein Vielfaches von ${issue.divisor} sein`;
	            case "unrecognized_keys":
	                return `${issue.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Ungültiger Schlüssel in ${issue.origin}`;
	            case "invalid_union":
	                return "Ungültige Eingabe";
	            case "invalid_element":
	                return `Ungültiger Wert in ${issue.origin}`;
	            default:
	                return `Ungültige Eingabe`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (de$2, de$2.exports));

var deExports = de$2.exports;
var de$1 = /*@__PURE__*/getDefaultExportFromCjs(deExports);

var en$1 = {};

(function (exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parsedType = void 0;
	exports.default = default_1;
	const util = __importStar(util$3);
	const parsedType = (data) => {
	    const t = typeof data;
	    switch (t) {
	        case "number": {
	            return Number.isNaN(data) ? "NaN" : "number";
	        }
	        case "object": {
	            if (Array.isArray(data)) {
	                return "array";
	            }
	            if (data === null) {
	                return "null";
	            }
	            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                return data.constructor.name;
	            }
	        }
	    }
	    return t;
	};
	exports.parsedType = parsedType;
	const error = () => {
	    const Sizable = {
	        string: { unit: "characters", verb: "to have" },
	        file: { unit: "bytes", verb: "to have" },
	        array: { unit: "items", verb: "to have" },
	        set: { unit: "items", verb: "to have" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const Nouns = {
	        regex: "input",
	        email: "email address",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO datetime",
	        date: "ISO date",
	        time: "ISO time",
	        duration: "ISO duration",
	        ipv4: "IPv4 address",
	        ipv6: "IPv6 address",
	        cidrv4: "IPv4 range",
	        cidrv6: "IPv6 range",
	        base64: "base64-encoded string",
	        base64url: "base64url-encoded string",
	        json_string: "JSON string",
	        e164: "E.164 number",
	        jwt: "JWT",
	        template_literal: "input",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Invalid input: expected ${issue.expected}, received ${(0, exports.parsedType)(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Invalid option: expected one of ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Too big: expected ${issue.origin ?? "value"} to have ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
	                return `Too big: expected ${issue.origin ?? "value"} to be ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Too small: expected ${issue.origin} to have ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Too small: expected ${issue.origin} to be ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `Invalid string: must start with "${_issue.prefix}"`;
	                }
	                if (_issue.format === "ends_with")
	                    return `Invalid string: must end with "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Invalid string: must include "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Invalid string: must match pattern ${_issue.pattern}`;
	                return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Invalid number: must be a multiple of ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Unrecognized key${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Invalid key in ${issue.origin}`;
	            case "invalid_union":
	                return "Invalid input";
	            case "invalid_element":
	                return `Invalid value in ${issue.origin}`;
	            default:
	                return `Invalid input`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	} 
} (en$1));

var en = /*@__PURE__*/getDefaultExportFromCjs(en$1);

var eo$1 = {};

(function (exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parsedType = void 0;
	exports.default = default_1;
	const util = __importStar(util$3);
	const parsedType = (data) => {
	    const t = typeof data;
	    switch (t) {
	        case "number": {
	            return Number.isNaN(data) ? "NaN" : "nombro";
	        }
	        case "object": {
	            if (Array.isArray(data)) {
	                return "tabelo";
	            }
	            if (data === null) {
	                return "senvalora";
	            }
	            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                return data.constructor.name;
	            }
	        }
	    }
	    return t;
	};
	exports.parsedType = parsedType;
	const error = () => {
	    const Sizable = {
	        string: { unit: "karaktrojn", verb: "havi" },
	        file: { unit: "bajtojn", verb: "havi" },
	        array: { unit: "elementojn", verb: "havi" },
	        set: { unit: "elementojn", verb: "havi" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const Nouns = {
	        regex: "enigo",
	        email: "retadreso",
	        url: "URL",
	        emoji: "emoĝio",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO-datotempo",
	        date: "ISO-dato",
	        time: "ISO-tempo",
	        duration: "ISO-daŭro",
	        ipv4: "IPv4-adreso",
	        ipv6: "IPv6-adreso",
	        cidrv4: "IPv4-rango",
	        cidrv6: "IPv6-rango",
	        base64: "64-ume kodita karaktraro",
	        base64url: "URL-64-ume kodita karaktraro",
	        json_string: "JSON-karaktraro",
	        e164: "E.164-nombro",
	        jwt: "JWT",
	        template_literal: "enigo",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Nevalida enigo: atendiĝis ${issue.expected}, riceviĝis ${(0, exports.parsedType)(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Nevalida enigo: atendiĝis ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Nevalida opcio: atendiĝis unu el ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Tro granda: atendiĝis ke ${issue.origin ?? "valoro"} havu ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
	                return `Tro granda: atendiĝis ke ${issue.origin ?? "valoro"} havu ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Tro malgranda: atendiĝis ke ${issue.origin} havu ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Tro malgranda: atendiĝis ke ${issue.origin} estu ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Nevalida karaktraro: devas komenciĝi per "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Nevalida karaktraro: devas finiĝi per "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
	                return `Nevalida ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Nevalida nombro: devas esti oblo de ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Nekonata${issue.keys.length > 1 ? "j" : ""} ŝlosilo${issue.keys.length > 1 ? "j" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Nevalida ŝlosilo en ${issue.origin}`;
	            case "invalid_union":
	                return "Nevalida enigo";
	            case "invalid_element":
	                return `Nevalida valoro en ${issue.origin}`;
	            default:
	                return `Nevalida enigo`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	} 
} (eo$1));

var eo = /*@__PURE__*/getDefaultExportFromCjs(eo$1);

var es$2 = {exports: {}};

var es = es$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "caracteres", verb: "tener" },
	        file: { unit: "bytes", verb: "tener" },
	        array: { unit: "elementos", verb: "tener" },
	        set: { unit: "elementos", verb: "tener" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "número";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "arreglo";
	                }
	                if (data === null) {
	                    return "nulo";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "entrada",
	        email: "dirección de correo electrónico",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "fecha y hora ISO",
	        date: "fecha ISO",
	        time: "hora ISO",
	        duration: "duración ISO",
	        ipv4: "dirección IPv4",
	        ipv6: "dirección IPv6",
	        cidrv4: "rango IPv4",
	        cidrv6: "rango IPv6",
	        base64: "cadena codificada en base64",
	        base64url: "URL codificada en base64",
	        json_string: "cadena JSON",
	        e164: "número E.164",
	        jwt: "JWT",
	        template_literal: "entrada",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Entrada inválida: se esperaba ${issue.expected}, recibido ${parsedType(issue.input)}`;
	            // return `Entrada inválida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Entrada inválida: se esperaba ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Opción inválida: se esperaba una de ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Demasiado grande: se esperaba que ${issue.origin ?? "valor"} tuviera ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementos"}`;
	                return `Demasiado grande: se esperaba que ${issue.origin ?? "valor"} fuera ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Demasiado pequeño: se esperaba que ${issue.origin} tuviera ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Demasiado pequeño: se esperaba que ${issue.origin} fuera ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Cadena inválida: debe comenzar con "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Cadena inválida: debe terminar en "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Cadena inválida: debe incluir "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Cadena inválida: debe coincidir con el patrón ${_issue.pattern}`;
	                return `Inválido ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Número inválido: debe ser múltiplo de ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Llave${issue.keys.length > 1 ? "s" : ""} desconocida${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Llave inválida en ${issue.origin}`;
	            case "invalid_union":
	                return "Entrada inválida";
	            case "invalid_element":
	                return `Valor inválido en ${issue.origin}`;
	            default:
	                return `Entrada inválida`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (es$2, es$2.exports));

var esExports = es$2.exports;
var es$1 = /*@__PURE__*/getDefaultExportFromCjs(esExports);

var fa$2 = {exports: {}};

var fa = fa$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "کاراکتر", verb: "داشته باشد" },
	        file: { unit: "بایت", verb: "داشته باشد" },
	        array: { unit: "آیتم", verb: "داشته باشد" },
	        set: { unit: "آیتم", verb: "داشته باشد" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "عدد";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "آرایه";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "ورودی",
	        email: "آدرس ایمیل",
	        url: "URL",
	        emoji: "ایموجی",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "تاریخ و زمان ایزو",
	        date: "تاریخ ایزو",
	        time: "زمان ایزو",
	        duration: "مدت زمان ایزو",
	        ipv4: "IPv4 آدرس",
	        ipv6: "IPv6 آدرس",
	        cidrv4: "IPv4 دامنه",
	        cidrv6: "IPv6 دامنه",
	        base64: "base64-encoded رشته",
	        base64url: "base64url-encoded رشته",
	        json_string: "JSON رشته",
	        e164: "E.164 عدد",
	        jwt: "JWT",
	        template_literal: "ورودی",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `ورودی نامعتبر: می‌بایست ${issue.expected} می‌بود، ${parsedType(issue.input)} دریافت شد`;
	            case "invalid_value":
	                if (issue.values.length === 1) {
	                    return `ورودی نامعتبر: می‌بایست ${util.stringifyPrimitive(issue.values[0])} می‌بود`;
	                }
	                return `گزینه نامعتبر: می‌بایست یکی از ${util.joinValues(issue.values, "|")} می‌بود`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `خیلی بزرگ: ${issue.origin ?? "مقدار"} باید ${adj}${issue.maximum.toString()} ${sizing.unit ?? "عنصر"} باشد`;
	                }
	                return `خیلی بزرگ: ${issue.origin ?? "مقدار"} باید ${adj}${issue.maximum.toString()} باشد`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `خیلی کوچک: ${issue.origin} باید ${adj}${issue.minimum.toString()} ${sizing.unit} باشد`;
	                }
	                return `خیلی کوچک: ${issue.origin} باید ${adj}${issue.minimum.toString()} باشد`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `رشته نامعتبر: باید با "${_issue.prefix}" شروع شود`;
	                }
	                if (_issue.format === "ends_with") {
	                    return `رشته نامعتبر: باید با "${_issue.suffix}" تمام شود`;
	                }
	                if (_issue.format === "includes") {
	                    return `رشته نامعتبر: باید شامل "${_issue.includes}" باشد`;
	                }
	                if (_issue.format === "regex") {
	                    return `رشته نامعتبر: باید با الگوی ${_issue.pattern} مطابقت داشته باشد`;
	                }
	                return `${Nouns[_issue.format] ?? issue.format} نامعتبر`;
	            }
	            case "not_multiple_of":
	                return `عدد نامعتبر: باید مضرب ${issue.divisor} باشد`;
	            case "unrecognized_keys":
	                return `کلید${issue.keys.length > 1 ? "های" : ""} ناشناس: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `کلید ناشناس در ${issue.origin}`;
	            case "invalid_union":
	                return `ورودی نامعتبر`;
	            case "invalid_element":
	                return `مقدار نامعتبر در ${issue.origin}`;
	            default:
	                return `ورودی نامعتبر`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (fa$2, fa$2.exports));

var faExports = fa$2.exports;
var fa$1 = /*@__PURE__*/getDefaultExportFromCjs(faExports);

var fi$2 = {exports: {}};

var fi = fi$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "merkkiä", subject: "merkkijonon" },
	        file: { unit: "tavua", subject: "tiedoston" },
	        array: { unit: "alkiota", subject: "listan" },
	        set: { unit: "alkiota", subject: "joukon" },
	        number: { unit: "", subject: "luvun" },
	        bigint: { unit: "", subject: "suuren kokonaisluvun" },
	        int: { unit: "", subject: "kokonaisluvun" },
	        date: { unit: "", subject: "päivämäärän" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "number";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "säännöllinen lauseke",
	        email: "sähköpostiosoite",
	        url: "URL-osoite",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO-aikaleima",
	        date: "ISO-päivämäärä",
	        time: "ISO-aika",
	        duration: "ISO-kesto",
	        ipv4: "IPv4-osoite",
	        ipv6: "IPv6-osoite",
	        cidrv4: "IPv4-alue",
	        cidrv6: "IPv6-alue",
	        base64: "base64-koodattu merkkijono",
	        base64url: "base64url-koodattu merkkijono",
	        json_string: "JSON-merkkijono",
	        e164: "E.164-luku",
	        jwt: "JWT",
	        template_literal: "templaattimerkkijono",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Virheellinen tyyppi: odotettiin ${issue.expected}, oli ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Virheellinen syöte: täytyy olla ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Virheellinen valinta: täytyy olla yksi seuraavista: ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Liian suuri: ${sizing.subject} täytyy olla ${adj}${issue.maximum.toString()} ${sizing.unit}`.trim();
	                }
	                return `Liian suuri: arvon täytyy olla ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Liian pieni: ${sizing.subject} täytyy olla ${adj}${issue.minimum.toString()} ${sizing.unit}`.trim();
	                }
	                return `Liian pieni: arvon täytyy olla ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Virheellinen syöte: täytyy alkaa "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Virheellinen syöte: täytyy loppua "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Virheellinen syöte: täytyy sisältää "${_issue.includes}"`;
	                if (_issue.format === "regex") {
	                    return `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${_issue.pattern}`;
	                }
	                return `Virheellinen ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Virheellinen luku: täytyy olla luvun ${issue.divisor} monikerta`;
	            case "unrecognized_keys":
	                return `${issue.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return "Virheellinen avain tietueessa";
	            case "invalid_union":
	                return "Virheellinen unioni";
	            case "invalid_element":
	                return "Virheellinen arvo joukossa";
	            default:
	                return `Virheellinen syöte`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (fi$2, fi$2.exports));

var fiExports = fi$2.exports;
var fi$1 = /*@__PURE__*/getDefaultExportFromCjs(fiExports);

var fr$2 = {exports: {}};

var fr = fr$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "caractères", verb: "avoir" },
	        file: { unit: "octets", verb: "avoir" },
	        array: { unit: "éléments", verb: "avoir" },
	        set: { unit: "éléments", verb: "avoir" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "nombre";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "tableau";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "entrée",
	        email: "adresse e-mail",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "date et heure ISO",
	        date: "date ISO",
	        time: "heure ISO",
	        duration: "durée ISO",
	        ipv4: "adresse IPv4",
	        ipv6: "adresse IPv6",
	        cidrv4: "plage IPv4",
	        cidrv6: "plage IPv6",
	        base64: "chaîne encodée en base64",
	        base64url: "chaîne encodée en base64url",
	        json_string: "chaîne JSON",
	        e164: "numéro E.164",
	        jwt: "JWT",
	        template_literal: "entrée",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Entrée invalide : ${issue.expected} attendu, ${parsedType(issue.input)} reçu`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Entrée invalide : ${util.stringifyPrimitive(issue.values[0])} attendu`;
	                return `Option invalide : une valeur parmi ${util.joinValues(issue.values, "|")} attendue`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Trop grand : ${issue.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "élément(s)"}`;
	                return `Trop grand : ${issue.origin ?? "valeur"} doit être ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Trop petit : ${issue.origin} doit ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Trop petit : ${issue.origin} doit être ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Chaîne invalide : doit inclure "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Chaîne invalide : doit correspondre au modèle ${_issue.pattern}`;
	                return `${Nouns[_issue.format] ?? issue.format} invalide`;
	            }
	            case "not_multiple_of":
	                return `Nombre invalide : doit être un multiple de ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Clé${issue.keys.length > 1 ? "s" : ""} non reconnue${issue.keys.length > 1 ? "s" : ""} : ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Clé invalide dans ${issue.origin}`;
	            case "invalid_union":
	                return "Entrée invalide";
	            case "invalid_element":
	                return `Valeur invalide dans ${issue.origin}`;
	            default:
	                return `Entrée invalide`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (fr$2, fr$2.exports));

var frExports = fr$2.exports;
var fr$1 = /*@__PURE__*/getDefaultExportFromCjs(frExports);

var frCA$2 = {exports: {}};

var frCA = frCA$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "caractères", verb: "avoir" },
	        file: { unit: "octets", verb: "avoir" },
	        array: { unit: "éléments", verb: "avoir" },
	        set: { unit: "éléments", verb: "avoir" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "number";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "entrée",
	        email: "adresse courriel",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "date-heure ISO",
	        date: "date ISO",
	        time: "heure ISO",
	        duration: "durée ISO",
	        ipv4: "adresse IPv4",
	        ipv6: "adresse IPv6",
	        cidrv4: "plage IPv4",
	        cidrv6: "plage IPv6",
	        base64: "chaîne encodée en base64",
	        base64url: "chaîne encodée en base64url",
	        json_string: "chaîne JSON",
	        e164: "numéro E.164",
	        jwt: "JWT",
	        template_literal: "entrée",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Entrée invalide : attendu ${issue.expected}, reçu ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Entrée invalide : attendu ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Option invalide : attendu l'une des valeurs suivantes ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "≤" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Trop grand : attendu que ${issue.origin ?? "la valeur"} ait ${adj}${issue.maximum.toString()} ${sizing.unit}`;
	                return `Trop grand : attendu que ${issue.origin ?? "la valeur"} soit ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? "≥" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Trop petit : attendu que ${issue.origin} ait ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Trop petit : attendu que ${issue.origin} soit ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
	                }
	                if (_issue.format === "ends_with")
	                    return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Chaîne invalide : doit inclure "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Chaîne invalide : doit correspondre au motif ${_issue.pattern}`;
	                return `${Nouns[_issue.format] ?? issue.format} invalide`;
	            }
	            case "not_multiple_of":
	                return `Nombre invalide : doit être un multiple de ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Clé${issue.keys.length > 1 ? "s" : ""} non reconnue${issue.keys.length > 1 ? "s" : ""} : ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Clé invalide dans ${issue.origin}`;
	            case "invalid_union":
	                return "Entrée invalide";
	            case "invalid_element":
	                return `Valeur invalide dans ${issue.origin}`;
	            default:
	                return `Entrée invalide`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (frCA$2, frCA$2.exports));

var frCAExports = frCA$2.exports;
var frCA$1 = /*@__PURE__*/getDefaultExportFromCjs(frCAExports);

var he$2 = {exports: {}};

var he = he$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "אותיות", verb: "לכלול" },
	        file: { unit: "בייטים", verb: "לכלול" },
	        array: { unit: "פריטים", verb: "לכלול" },
	        set: { unit: "פריטים", verb: "לכלול" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "number";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "קלט",
	        email: "כתובת אימייל",
	        url: "כתובת רשת",
	        emoji: "אימוג'י",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "תאריך וזמן ISO",
	        date: "תאריך ISO",
	        time: "זמן ISO",
	        duration: "משך זמן ISO",
	        ipv4: "כתובת IPv4",
	        ipv6: "כתובת IPv6",
	        cidrv4: "טווח IPv4",
	        cidrv6: "טווח IPv6",
	        base64: "מחרוזת בבסיס 64",
	        base64url: "מחרוזת בבסיס 64 לכתובות רשת",
	        json_string: "מחרוזת JSON",
	        e164: "מספר E.164",
	        jwt: "JWT",
	        template_literal: "קלט",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `קלט לא תקין: צריך ${issue.expected}, התקבל ${parsedType(issue.input)}`;
	            // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `קלט לא תקין: צריך ${util.stringifyPrimitive(issue.values[0])}`;
	                return `קלט לא תקין: צריך אחת מהאפשרויות  ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `גדול מדי: ${issue.origin ?? "value"} צריך להיות ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"}`;
	                return `גדול מדי: ${issue.origin ?? "value"} צריך להיות ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `קטן מדי: ${issue.origin} צריך להיות ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `קטן מדי: ${issue.origin} צריך להיות ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `מחרוזת לא תקינה: חייבת להתחיל ב"${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `מחרוזת לא תקינה: חייבת להסתיים ב "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `מחרוזת לא תקינה: חייבת לכלול "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${_issue.pattern}`;
	                return `${Nouns[_issue.format] ?? issue.format} לא תקין`;
	            }
	            case "not_multiple_of":
	                return `מספר לא תקין: חייב להיות מכפלה של ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `מפתח${issue.keys.length > 1 ? "ות" : ""} לא מזוה${issue.keys.length > 1 ? "ים" : "ה"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `מפתח לא תקין ב${issue.origin}`;
	            case "invalid_union":
	                return "קלט לא תקין";
	            case "invalid_element":
	                return `ערך לא תקין ב${issue.origin}`;
	            default:
	                return `קלט לא תקין`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (he$2, he$2.exports));

var heExports = he$2.exports;
var he$1 = /*@__PURE__*/getDefaultExportFromCjs(heExports);

var hu$2 = {exports: {}};

var hu = hu$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "karakter", verb: "legyen" },
	        file: { unit: "byte", verb: "legyen" },
	        array: { unit: "elem", verb: "legyen" },
	        set: { unit: "elem", verb: "legyen" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "szám";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "tömb";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "bemenet",
	        email: "email cím",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO időbélyeg",
	        date: "ISO dátum",
	        time: "ISO idő",
	        duration: "ISO időintervallum",
	        ipv4: "IPv4 cím",
	        ipv6: "IPv6 cím",
	        cidrv4: "IPv4 tartomány",
	        cidrv6: "IPv6 tartomány",
	        base64: "base64-kódolt string",
	        base64url: "base64url-kódolt string",
	        json_string: "JSON string",
	        e164: "E.164 szám",
	        jwt: "JWT",
	        template_literal: "bemenet",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Érvénytelen bemenet: a várt érték ${issue.expected}, a kapott érték ${parsedType(issue.input)}`;
	            // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Érvénytelen bemenet: a várt érték ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Érvénytelen opció: valamelyik érték várt ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Túl nagy: ${issue.origin ?? "érték"} mérete túl nagy ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elem"}`;
	                return `Túl nagy: a bemeneti érték ${issue.origin ?? "érték"} túl nagy: ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Túl kicsi: a bemeneti érték ${issue.origin} mérete túl kicsi ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Túl kicsi: a bemeneti érték ${issue.origin} túl kicsi ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Érvénytelen string: "${_issue.prefix}" értékkel kell kezdődnie`;
	                if (_issue.format === "ends_with")
	                    return `Érvénytelen string: "${_issue.suffix}" értékkel kell végződnie`;
	                if (_issue.format === "includes")
	                    return `Érvénytelen string: "${_issue.includes}" értéket kell tartalmaznia`;
	                if (_issue.format === "regex")
	                    return `Érvénytelen string: ${_issue.pattern} mintának kell megfelelnie`;
	                return `Érvénytelen ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Érvénytelen szám: ${issue.divisor} többszörösének kell lennie`;
	            case "unrecognized_keys":
	                return `Ismeretlen kulcs${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Érvénytelen kulcs ${issue.origin}`;
	            case "invalid_union":
	                return "Érvénytelen bemenet";
	            case "invalid_element":
	                return `Érvénytelen érték: ${issue.origin}`;
	            default:
	                return `Érvénytelen bemenet`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (hu$2, hu$2.exports));

var huExports = hu$2.exports;
var hu$1 = /*@__PURE__*/getDefaultExportFromCjs(huExports);

var id$2 = {exports: {}};

var id = id$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "karakter", verb: "memiliki" },
	        file: { unit: "byte", verb: "memiliki" },
	        array: { unit: "item", verb: "memiliki" },
	        set: { unit: "item", verb: "memiliki" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "number";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "input",
	        email: "alamat email",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "tanggal dan waktu format ISO",
	        date: "tanggal format ISO",
	        time: "jam format ISO",
	        duration: "durasi format ISO",
	        ipv4: "alamat IPv4",
	        ipv6: "alamat IPv6",
	        cidrv4: "rentang alamat IPv4",
	        cidrv6: "rentang alamat IPv6",
	        base64: "string dengan enkode base64",
	        base64url: "string dengan enkode base64url",
	        json_string: "string JSON",
	        e164: "angka E.164",
	        jwt: "JWT",
	        template_literal: "input",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Input tidak valid: diharapkan ${issue.expected}, diterima ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Input tidak valid: diharapkan ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Pilihan tidak valid: diharapkan salah satu dari ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Terlalu besar: diharapkan ${issue.origin ?? "value"} memiliki ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elemen"}`;
	                return `Terlalu besar: diharapkan ${issue.origin ?? "value"} menjadi ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Terlalu kecil: diharapkan ${issue.origin} memiliki ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Terlalu kecil: diharapkan ${issue.origin} menjadi ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `String tidak valid: harus menyertakan "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
	                return `${Nouns[_issue.format] ?? issue.format} tidak valid`;
	            }
	            case "not_multiple_of":
	                return `Angka tidak valid: harus kelipatan dari ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Kunci tidak dikenali ${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Kunci tidak valid di ${issue.origin}`;
	            case "invalid_union":
	                return "Input tidak valid";
	            case "invalid_element":
	                return `Nilai tidak valid di ${issue.origin}`;
	            default:
	                return `Input tidak valid`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (id$2, id$2.exports));

var idExports = id$2.exports;
var id$1 = /*@__PURE__*/getDefaultExportFromCjs(idExports);

var is$1 = {};

(function (exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parsedType = void 0;
	exports.default = default_1;
	const util = __importStar(util$3);
	const parsedType = (data) => {
	    const t = typeof data;
	    switch (t) {
	        case "number": {
	            return Number.isNaN(data) ? "NaN" : "númer";
	        }
	        case "object": {
	            if (Array.isArray(data)) {
	                return "fylki";
	            }
	            if (data === null) {
	                return "null";
	            }
	            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                return data.constructor.name;
	            }
	        }
	    }
	    return t;
	};
	exports.parsedType = parsedType;
	const error = () => {
	    const Sizable = {
	        string: { unit: "stafi", verb: "að hafa" },
	        file: { unit: "bæti", verb: "að hafa" },
	        array: { unit: "hluti", verb: "að hafa" },
	        set: { unit: "hluti", verb: "að hafa" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const Nouns = {
	        regex: "gildi",
	        email: "netfang",
	        url: "vefslóð",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO dagsetning og tími",
	        date: "ISO dagsetning",
	        time: "ISO tími",
	        duration: "ISO tímalengd",
	        ipv4: "IPv4 address",
	        ipv6: "IPv6 address",
	        cidrv4: "IPv4 range",
	        cidrv6: "IPv6 range",
	        base64: "base64-encoded strengur",
	        base64url: "base64url-encoded strengur",
	        json_string: "JSON strengur",
	        e164: "E.164 tölugildi",
	        jwt: "JWT",
	        template_literal: "gildi",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Rangt gildi: Þú slóst inn ${(0, exports.parsedType)(issue.input)} þar sem á að vera ${issue.expected}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Rangt gildi: gert ráð fyrir ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Ógilt val: má vera eitt af eftirfarandi ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Of stórt: gert er ráð fyrir að ${issue.origin ?? "gildi"} hafi ${adj}${issue.maximum.toString()} ${sizing.unit ?? "hluti"}`;
	                return `Of stórt: gert er ráð fyrir að ${issue.origin ?? "gildi"} sé ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Of lítið: gert er ráð fyrir að ${issue.origin} hafi ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Of lítið: gert er ráð fyrir að ${issue.origin} sé ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `Ógildur strengur: verður að byrja á "${_issue.prefix}"`;
	                }
	                if (_issue.format === "ends_with")
	                    return `Ógildur strengur: verður að enda á "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Ógildur strengur: verður að innihalda "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Ógildur strengur: verður að fylgja mynstri ${_issue.pattern}`;
	                return `Rangt ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Röng tala: verður að vera margfeldi af ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Óþekkt ${issue.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Rangur lykill í ${issue.origin}`;
	            case "invalid_union":
	                return "Rangt gildi";
	            case "invalid_element":
	                return `Rangt gildi í ${issue.origin}`;
	            default:
	                return `Rangt gildi`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	} 
} (is$1));

var is = /*@__PURE__*/getDefaultExportFromCjs(is$1);

var it$2 = {exports: {}};

var it = it$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "caratteri", verb: "avere" },
	        file: { unit: "byte", verb: "avere" },
	        array: { unit: "elementi", verb: "avere" },
	        set: { unit: "elementi", verb: "avere" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "numero";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "vettore";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "input",
	        email: "indirizzo email",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "data e ora ISO",
	        date: "data ISO",
	        time: "ora ISO",
	        duration: "durata ISO",
	        ipv4: "indirizzo IPv4",
	        ipv6: "indirizzo IPv6",
	        cidrv4: "intervallo IPv4",
	        cidrv6: "intervallo IPv6",
	        base64: "stringa codificata in base64",
	        base64url: "URL codificata in base64",
	        json_string: "stringa JSON",
	        e164: "numero E.164",
	        jwt: "JWT",
	        template_literal: "input",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Input non valido: atteso ${issue.expected}, ricevuto ${parsedType(issue.input)}`;
	            // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Input non valido: atteso ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Opzione non valida: atteso uno tra ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Troppo grande: ${issue.origin ?? "valore"} deve avere ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementi"}`;
	                return `Troppo grande: ${issue.origin ?? "valore"} deve essere ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Troppo piccolo: ${issue.origin} deve avere ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Troppo piccolo: ${issue.origin} deve essere ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Stringa non valida: deve includere "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
	                return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Numero non valido: deve essere un multiplo di ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Chiav${issue.keys.length > 1 ? "i" : "e"} non riconosciut${issue.keys.length > 1 ? "e" : "a"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Chiave non valida in ${issue.origin}`;
	            case "invalid_union":
	                return "Input non valido";
	            case "invalid_element":
	                return `Valore non valido in ${issue.origin}`;
	            default:
	                return `Input non valido`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (it$2, it$2.exports));

var itExports = it$2.exports;
var it$1 = /*@__PURE__*/getDefaultExportFromCjs(itExports);

var ja$2 = {exports: {}};

var ja = ja$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "文字", verb: "である" },
	        file: { unit: "バイト", verb: "である" },
	        array: { unit: "要素", verb: "である" },
	        set: { unit: "要素", verb: "である" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "数値";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "配列";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "入力値",
	        email: "メールアドレス",
	        url: "URL",
	        emoji: "絵文字",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO日時",
	        date: "ISO日付",
	        time: "ISO時刻",
	        duration: "ISO期間",
	        ipv4: "IPv4アドレス",
	        ipv6: "IPv6アドレス",
	        cidrv4: "IPv4範囲",
	        cidrv6: "IPv6範囲",
	        base64: "base64エンコード文字列",
	        base64url: "base64urlエンコード文字列",
	        json_string: "JSON文字列",
	        e164: "E.164番号",
	        jwt: "JWT",
	        template_literal: "入力値",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `無効な入力: ${issue.expected}が期待されましたが、${parsedType(issue.input)}が入力されました`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `無効な入力: ${util.stringifyPrimitive(issue.values[0])}が期待されました`;
	                return `無効な選択: ${util.joinValues(issue.values, "、")}のいずれかである必要があります`;
	            case "too_big": {
	                const adj = issue.inclusive ? "以下である" : "より小さい";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `大きすぎる値: ${issue.origin ?? "値"}は${issue.maximum.toString()}${sizing.unit ?? "要素"}${adj}必要があります`;
	                return `大きすぎる値: ${issue.origin ?? "値"}は${issue.maximum.toString()}${adj}必要があります`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? "以上である" : "より大きい";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `小さすぎる値: ${issue.origin}は${issue.minimum.toString()}${sizing.unit}${adj}必要があります`;
	                return `小さすぎる値: ${issue.origin}は${issue.minimum.toString()}${adj}必要があります`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `無効な文字列: "${_issue.prefix}"で始まる必要があります`;
	                if (_issue.format === "ends_with")
	                    return `無効な文字列: "${_issue.suffix}"で終わる必要があります`;
	                if (_issue.format === "includes")
	                    return `無効な文字列: "${_issue.includes}"を含む必要があります`;
	                if (_issue.format === "regex")
	                    return `無効な文字列: パターン${_issue.pattern}に一致する必要があります`;
	                return `無効な${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `無効な数値: ${issue.divisor}の倍数である必要があります`;
	            case "unrecognized_keys":
	                return `認識されていないキー${issue.keys.length > 1 ? "群" : ""}: ${util.joinValues(issue.keys, "、")}`;
	            case "invalid_key":
	                return `${issue.origin}内の無効なキー`;
	            case "invalid_union":
	                return "無効な入力";
	            case "invalid_element":
	                return `${issue.origin}内の無効な値`;
	            default:
	                return `無効な入力`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ja$2, ja$2.exports));

var jaExports = ja$2.exports;
var ja$1 = /*@__PURE__*/getDefaultExportFromCjs(jaExports);

var kh$2 = {exports: {}};

var kh = kh$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "តួអក្សរ", verb: "គួរមាន" },
	        file: { unit: "បៃ", verb: "គួរមាន" },
	        array: { unit: "ធាតុ", verb: "គួរមាន" },
	        set: { unit: "ធាតុ", verb: "គួរមាន" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "មិនមែនជាលេខ (NaN)" : "លេខ";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "អារេ (Array)";
	                }
	                if (data === null) {
	                    return "គ្មានតម្លៃ (null)";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "ទិន្នន័យបញ្ចូល",
	        email: "អាសយដ្ឋានអ៊ីមែល",
	        url: "URL",
	        emoji: "សញ្ញាអារម្មណ៍",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
	        date: "កាលបរិច្ឆេទ ISO",
	        time: "ម៉ោង ISO",
	        duration: "រយៈពេល ISO",
	        ipv4: "អាសយដ្ឋាន IPv4",
	        ipv6: "អាសយដ្ឋាន IPv6",
	        cidrv4: "ដែនអាសយដ្ឋាន IPv4",
	        cidrv6: "ដែនអាសយដ្ឋាន IPv6",
	        base64: "ខ្សែអក្សរអ៊ិកូដ base64",
	        base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
	        json_string: "ខ្សែអក្សរ JSON",
	        e164: "លេខ E.164",
	        jwt: "JWT",
	        template_literal: "ទិន្នន័យបញ្ចូល",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${issue.expected} ប៉ុន្តែទទួលបាន ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${util.stringifyPrimitive(issue.values[0])}`;
	                return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `ធំពេក៖ ត្រូវការ ${issue.origin ?? "តម្លៃ"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? "ធាតុ"}`;
	                return `ធំពេក៖ ត្រូវការ ${issue.origin ?? "តម្លៃ"} ${adj} ${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `តូចពេក៖ ត្រូវការ ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `តូចពេក៖ ត្រូវការ ${issue.origin} ${adj} ${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${_issue.prefix}"`;
	                }
	                if (_issue.format === "ends_with")
	                    return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${_issue.pattern}`;
	                return `មិនត្រឹមត្រូវ៖ ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `រកឃើញសោមិនស្គាល់៖ ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `សោមិនត្រឹមត្រូវនៅក្នុង ${issue.origin}`;
	            case "invalid_union":
	                return `ទិន្នន័យមិនត្រឹមត្រូវ`;
	            case "invalid_element":
	                return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${issue.origin}`;
	            default:
	                return `ទិន្នន័យមិនត្រឹមត្រូវ`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (kh$2, kh$2.exports));

var khExports = kh$2.exports;
var kh$1 = /*@__PURE__*/getDefaultExportFromCjs(khExports);

var ko$2 = {exports: {}};

var ko = ko$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "문자", verb: "to have" },
	        file: { unit: "바이트", verb: "to have" },
	        array: { unit: "개", verb: "to have" },
	        set: { unit: "개", verb: "to have" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "number";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "입력",
	        email: "이메일 주소",
	        url: "URL",
	        emoji: "이모지",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO 날짜시간",
	        date: "ISO 날짜",
	        time: "ISO 시간",
	        duration: "ISO 기간",
	        ipv4: "IPv4 주소",
	        ipv6: "IPv6 주소",
	        cidrv4: "IPv4 범위",
	        cidrv6: "IPv6 범위",
	        base64: "base64 인코딩 문자열",
	        base64url: "base64url 인코딩 문자열",
	        json_string: "JSON 문자열",
	        e164: "E.164 번호",
	        jwt: "JWT",
	        template_literal: "입력",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `잘못된 입력: 예상 타입은 ${issue.expected}, 받은 타입은 ${parsedType(issue.input)}입니다`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `잘못된 입력: 값은 ${util.stringifyPrimitive(issue.values[0])} 이어야 합니다`;
	                return `잘못된 옵션: ${util.joinValues(issue.values, "또는 ")} 중 하나여야 합니다`;
	            case "too_big": {
	                const adj = issue.inclusive ? "이하" : "미만";
	                const suffix = adj === "미만" ? "이어야 합니다" : "여야 합니다";
	                const sizing = getSizing(issue.origin);
	                const unit = sizing?.unit ?? "요소";
	                if (sizing)
	                    return `${issue.origin ?? "값"}이 너무 큽니다: ${issue.maximum.toString()}${unit} ${adj}${suffix}`;
	                return `${issue.origin ?? "값"}이 너무 큽니다: ${issue.maximum.toString()} ${adj}${suffix}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? "이상" : "초과";
	                const suffix = adj === "이상" ? "이어야 합니다" : "여야 합니다";
	                const sizing = getSizing(issue.origin);
	                const unit = sizing?.unit ?? "요소";
	                if (sizing) {
	                    return `${issue.origin ?? "값"}이 너무 작습니다: ${issue.minimum.toString()}${unit} ${adj}${suffix}`;
	                }
	                return `${issue.origin ?? "값"}이 너무 작습니다: ${issue.minimum.toString()} ${adj}${suffix}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `잘못된 문자열: "${_issue.prefix}"(으)로 시작해야 합니다`;
	                }
	                if (_issue.format === "ends_with")
	                    return `잘못된 문자열: "${_issue.suffix}"(으)로 끝나야 합니다`;
	                if (_issue.format === "includes")
	                    return `잘못된 문자열: "${_issue.includes}"을(를) 포함해야 합니다`;
	                if (_issue.format === "regex")
	                    return `잘못된 문자열: 정규식 ${_issue.pattern} 패턴과 일치해야 합니다`;
	                return `잘못된 ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `잘못된 숫자: ${issue.divisor}의 배수여야 합니다`;
	            case "unrecognized_keys":
	                return `인식할 수 없는 키: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `잘못된 키: ${issue.origin}`;
	            case "invalid_union":
	                return `잘못된 입력`;
	            case "invalid_element":
	                return `잘못된 값: ${issue.origin}`;
	            default:
	                return `잘못된 입력`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ko$2, ko$2.exports));

var koExports = ko$2.exports;
var ko$1 = /*@__PURE__*/getDefaultExportFromCjs(koExports);

var mk$2 = {exports: {}};

var mk = mk$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "знаци", verb: "да имаат" },
	        file: { unit: "бајти", verb: "да имаат" },
	        array: { unit: "ставки", verb: "да имаат" },
	        set: { unit: "ставки", verb: "да имаат" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "број";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "низа";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "внес",
	        email: "адреса на е-пошта",
	        url: "URL",
	        emoji: "емоџи",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO датум и време",
	        date: "ISO датум",
	        time: "ISO време",
	        duration: "ISO времетраење",
	        ipv4: "IPv4 адреса",
	        ipv6: "IPv6 адреса",
	        cidrv4: "IPv4 опсег",
	        cidrv6: "IPv6 опсег",
	        base64: "base64-енкодирана низа",
	        base64url: "base64url-енкодирана низа",
	        json_string: "JSON низа",
	        e164: "E.164 број",
	        jwt: "JWT",
	        template_literal: "внес",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Грешен внес: се очекува ${issue.expected}, примено ${parsedType(issue.input)}`;
	            // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Грешана опција: се очекува една ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Премногу голем: се очекува ${issue.origin ?? "вредноста"} да има ${adj}${issue.maximum.toString()} ${sizing.unit ?? "елементи"}`;
	                return `Премногу голем: се очекува ${issue.origin ?? "вредноста"} да биде ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Премногу мал: се очекува ${issue.origin} да има ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Премногу мал: се очекува ${issue.origin} да биде ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `Неважечка низа: мора да започнува со "${_issue.prefix}"`;
	                }
	                if (_issue.format === "ends_with")
	                    return `Неважечка низа: мора да завршува со "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Неважечка низа: мора да вклучува "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Неважечка низа: мора да одгоара на патернот ${_issue.pattern}`;
	                return `Invalid ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Грешен број: мора да биде делив со ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `${issue.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Грешен клуч во ${issue.origin}`;
	            case "invalid_union":
	                return "Грешен внес";
	            case "invalid_element":
	                return `Грешна вредност во ${issue.origin}`;
	            default:
	                return `Грешен внес`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (mk$2, mk$2.exports));

var mkExports = mk$2.exports;
var mk$1 = /*@__PURE__*/getDefaultExportFromCjs(mkExports);

var ms$2 = {exports: {}};

var ms = ms$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "aksara", verb: "mempunyai" },
	        file: { unit: "bait", verb: "mempunyai" },
	        array: { unit: "elemen", verb: "mempunyai" },
	        set: { unit: "elemen", verb: "mempunyai" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "nombor";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "input",
	        email: "alamat e-mel",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "tarikh masa ISO",
	        date: "tarikh ISO",
	        time: "masa ISO",
	        duration: "tempoh ISO",
	        ipv4: "alamat IPv4",
	        ipv6: "alamat IPv6",
	        cidrv4: "julat IPv4",
	        cidrv6: "julat IPv6",
	        base64: "string dikodkan base64",
	        base64url: "string dikodkan base64url",
	        json_string: "string JSON",
	        e164: "nombor E.164",
	        jwt: "JWT",
	        template_literal: "input",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Input tidak sah: dijangka ${issue.expected}, diterima ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Input tidak sah: dijangka ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Pilihan tidak sah: dijangka salah satu daripada ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Terlalu besar: dijangka ${issue.origin ?? "nilai"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elemen"}`;
	                return `Terlalu besar: dijangka ${issue.origin ?? "nilai"} adalah ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Terlalu kecil: dijangka ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Terlalu kecil: dijangka ${issue.origin} adalah ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
	                return `${Nouns[_issue.format] ?? issue.format} tidak sah`;
	            }
	            case "not_multiple_of":
	                return `Nombor tidak sah: perlu gandaan ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Kunci tidak dikenali: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Kunci tidak sah dalam ${issue.origin}`;
	            case "invalid_union":
	                return "Input tidak sah";
	            case "invalid_element":
	                return `Nilai tidak sah dalam ${issue.origin}`;
	            default:
	                return `Input tidak sah`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ms$2, ms$2.exports));

var msExports = ms$2.exports;
var ms$1 = /*@__PURE__*/getDefaultExportFromCjs(msExports);

var nl$2 = {exports: {}};

var nl = nl$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "tekens" },
	        file: { unit: "bytes" },
	        array: { unit: "elementen" },
	        set: { unit: "elementen" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "getal";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "invoer",
	        email: "emailadres",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO datum en tijd",
	        date: "ISO datum",
	        time: "ISO tijd",
	        duration: "ISO duur",
	        ipv4: "IPv4-adres",
	        ipv6: "IPv6-adres",
	        cidrv4: "IPv4-bereik",
	        cidrv6: "IPv6-bereik",
	        base64: "base64-gecodeerde tekst",
	        base64url: "base64 URL-gecodeerde tekst",
	        json_string: "JSON string",
	        e164: "E.164-nummer",
	        jwt: "JWT",
	        template_literal: "invoer",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Ongeldige invoer: verwacht ${issue.expected}, ontving ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Ongeldige invoer: verwacht ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Ongeldige optie: verwacht één van ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Te lang: verwacht dat ${issue.origin ?? "waarde"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
	                return `Te lang: verwacht dat ${issue.origin ?? "waarde"} ${adj}${issue.maximum.toString()} is`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} bevat`;
	                }
	                return `Te kort: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} is`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
	                }
	                if (_issue.format === "ends_with")
	                    return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
	                if (_issue.format === "includes")
	                    return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
	                if (_issue.format === "regex")
	                    return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
	                return `Ongeldig: ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Ongeldig getal: moet een veelvoud van ${issue.divisor} zijn`;
	            case "unrecognized_keys":
	                return `Onbekende key${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Ongeldige key in ${issue.origin}`;
	            case "invalid_union":
	                return "Ongeldige invoer";
	            case "invalid_element":
	                return `Ongeldige waarde in ${issue.origin}`;
	            default:
	                return `Ongeldige invoer`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (nl$2, nl$2.exports));

var nlExports = nl$2.exports;
var nl$1 = /*@__PURE__*/getDefaultExportFromCjs(nlExports);

var no$2 = {exports: {}};

var no = no$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "tegn", verb: "å ha" },
	        file: { unit: "bytes", verb: "å ha" },
	        array: { unit: "elementer", verb: "å inneholde" },
	        set: { unit: "elementer", verb: "å inneholde" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "tall";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "liste";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "input",
	        email: "e-postadresse",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO dato- og klokkeslett",
	        date: "ISO-dato",
	        time: "ISO-klokkeslett",
	        duration: "ISO-varighet",
	        ipv4: "IPv4-område",
	        ipv6: "IPv6-område",
	        cidrv4: "IPv4-spekter",
	        cidrv6: "IPv6-spekter",
	        base64: "base64-enkodet streng",
	        base64url: "base64url-enkodet streng",
	        json_string: "JSON-streng",
	        e164: "E.164-nummer",
	        jwt: "JWT",
	        template_literal: "input",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Ugyldig input: forventet ${issue.expected}, fikk ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Ugyldig verdi: forventet ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Ugyldig valg: forventet en av ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `For stor(t): forventet ${issue.origin ?? "value"} til å ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementer"}`;
	                return `For stor(t): forventet ${issue.origin ?? "value"} til å ha ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `For lite(n): forventet ${issue.origin} til å ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `For lite(n): forventet ${issue.origin} til å ha ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Ugyldig streng: må starte med "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Ugyldig streng: må ende med "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Ugyldig streng: må inneholde "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Ugyldig streng: må matche mønsteret ${_issue.pattern}`;
	                return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Ugyldig tall: må være et multiplum av ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `${issue.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Ugyldig nøkkel i ${issue.origin}`;
	            case "invalid_union":
	                return "Ugyldig input";
	            case "invalid_element":
	                return `Ugyldig verdi i ${issue.origin}`;
	            default:
	                return `Ugyldig input`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (no$2, no$2.exports));

var noExports = no$2.exports;
var no$1 = /*@__PURE__*/getDefaultExportFromCjs(noExports);

var ota$2 = {exports: {}};

var ota = ota$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "harf", verb: "olmalıdır" },
	        file: { unit: "bayt", verb: "olmalıdır" },
	        array: { unit: "unsur", verb: "olmalıdır" },
	        set: { unit: "unsur", verb: "olmalıdır" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "numara";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "saf";
	                }
	                if (data === null) {
	                    return "gayb";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "giren",
	        email: "epostagâh",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO hengâmı",
	        date: "ISO tarihi",
	        time: "ISO zamanı",
	        duration: "ISO müddeti",
	        ipv4: "IPv4 nişânı",
	        ipv6: "IPv6 nişânı",
	        cidrv4: "IPv4 menzili",
	        cidrv6: "IPv6 menzili",
	        base64: "base64-şifreli metin",
	        base64url: "base64url-şifreli metin",
	        json_string: "JSON metin",
	        e164: "E.164 sayısı",
	        jwt: "JWT",
	        template_literal: "giren",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Fâsit giren: umulan ${issue.expected}, alınan ${parsedType(issue.input)}`;
	            // return `Fâsit giren: umulan ${issue.expected}, alınan ${util.getParsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Fâsit giren: umulan ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Fâsit tercih: mûteberler ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Fazla büyük: ${issue.origin ?? "value"}, ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalıydı.`;
	                return `Fazla büyük: ${issue.origin ?? "value"}, ${adj}${issue.maximum.toString()} olmalıydı.`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Fazla küçük: ${issue.origin}, ${adj}${issue.minimum.toString()} ${sizing.unit} sahip olmalıydı.`;
	                }
	                return `Fazla küçük: ${issue.origin}, ${adj}${issue.minimum.toString()} olmalıydı.`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Fâsit metin: "${_issue.prefix}" ile başlamalı.`;
	                if (_issue.format === "ends_with")
	                    return `Fâsit metin: "${_issue.suffix}" ile bitmeli.`;
	                if (_issue.format === "includes")
	                    return `Fâsit metin: "${_issue.includes}" ihtivâ etmeli.`;
	                if (_issue.format === "regex")
	                    return `Fâsit metin: ${_issue.pattern} nakşına uymalı.`;
	                return `Fâsit ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Fâsit sayı: ${issue.divisor} katı olmalıydı.`;
	            case "unrecognized_keys":
	                return `Tanınmayan anahtar ${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `${issue.origin} için tanınmayan anahtar var.`;
	            case "invalid_union":
	                return "Giren tanınamadı.";
	            case "invalid_element":
	                return `${issue.origin} için tanınmayan kıymet var.`;
	            default:
	                return `Kıymet tanınamadı.`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ota$2, ota$2.exports));

var otaExports = ota$2.exports;
var ota$1 = /*@__PURE__*/getDefaultExportFromCjs(otaExports);

var ps$2 = {exports: {}};

var ps = ps$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "توکي", verb: "ولري" },
	        file: { unit: "بایټس", verb: "ولري" },
	        array: { unit: "توکي", verb: "ولري" },
	        set: { unit: "توکي", verb: "ولري" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "عدد";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "ارې";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "ورودي",
	        email: "بریښنالیک",
	        url: "یو آر ال",
	        emoji: "ایموجي",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "نیټه او وخت",
	        date: "نېټه",
	        time: "وخت",
	        duration: "موده",
	        ipv4: "د IPv4 پته",
	        ipv6: "د IPv6 پته",
	        cidrv4: "د IPv4 ساحه",
	        cidrv6: "د IPv6 ساحه",
	        base64: "base64-encoded متن",
	        base64url: "base64url-encoded متن",
	        json_string: "JSON متن",
	        e164: "د E.164 شمېره",
	        jwt: "JWT",
	        template_literal: "ورودي",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `ناسم ورودي: باید ${issue.expected} وای, مګر ${parsedType(issue.input)} ترلاسه شو`;
	            case "invalid_value":
	                if (issue.values.length === 1) {
	                    return `ناسم ورودي: باید ${util.stringifyPrimitive(issue.values[0])} وای`;
	                }
	                return `ناسم انتخاب: باید یو له ${util.joinValues(issue.values, "|")} څخه وای`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `ډیر لوی: ${issue.origin ?? "ارزښت"} باید ${adj}${issue.maximum.toString()} ${sizing.unit ?? "عنصرونه"} ولري`;
	                }
	                return `ډیر لوی: ${issue.origin ?? "ارزښت"} باید ${adj}${issue.maximum.toString()} وي`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `ډیر کوچنی: ${issue.origin} باید ${adj}${issue.minimum.toString()} ${sizing.unit} ولري`;
	                }
	                return `ډیر کوچنی: ${issue.origin} باید ${adj}${issue.minimum.toString()} وي`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `ناسم متن: باید د "${_issue.prefix}" سره پیل شي`;
	                }
	                if (_issue.format === "ends_with") {
	                    return `ناسم متن: باید د "${_issue.suffix}" سره پای ته ورسيږي`;
	                }
	                if (_issue.format === "includes") {
	                    return `ناسم متن: باید "${_issue.includes}" ولري`;
	                }
	                if (_issue.format === "regex") {
	                    return `ناسم متن: باید د ${_issue.pattern} سره مطابقت ولري`;
	                }
	                return `${Nouns[_issue.format] ?? issue.format} ناسم دی`;
	            }
	            case "not_multiple_of":
	                return `ناسم عدد: باید د ${issue.divisor} مضرب وي`;
	            case "unrecognized_keys":
	                return `ناسم ${issue.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `ناسم کلیډ په ${issue.origin} کې`;
	            case "invalid_union":
	                return `ناسمه ورودي`;
	            case "invalid_element":
	                return `ناسم عنصر په ${issue.origin} کې`;
	            default:
	                return `ناسمه ورودي`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ps$2, ps$2.exports));

var psExports = ps$2.exports;
var ps$1 = /*@__PURE__*/getDefaultExportFromCjs(psExports);

var pl$2 = {exports: {}};

var pl = pl$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "znaków", verb: "mieć" },
	        file: { unit: "bajtów", verb: "mieć" },
	        array: { unit: "elementów", verb: "mieć" },
	        set: { unit: "elementów", verb: "mieć" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "liczba";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "tablica";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "wyrażenie",
	        email: "adres email",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "data i godzina w formacie ISO",
	        date: "data w formacie ISO",
	        time: "godzina w formacie ISO",
	        duration: "czas trwania ISO",
	        ipv4: "adres IPv4",
	        ipv6: "adres IPv6",
	        cidrv4: "zakres IPv4",
	        cidrv6: "zakres IPv6",
	        base64: "ciąg znaków zakodowany w formacie base64",
	        base64url: "ciąg znaków zakodowany w formacie base64url",
	        json_string: "ciąg znaków w formacie JSON",
	        e164: "liczba E.164",
	        jwt: "JWT",
	        template_literal: "wejście",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Nieprawidłowe dane wejściowe: oczekiwano ${issue.expected}, otrzymano ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Nieprawidłowe dane wejściowe: oczekiwano ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Za duża wartość: oczekiwano, że ${issue.origin ?? "wartość"} będzie mieć ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementów"}`;
	                }
	                return `Zbyt duż(y/a/e): oczekiwano, że ${issue.origin ?? "wartość"} będzie wynosić ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Za mała wartość: oczekiwano, że ${issue.origin ?? "wartość"} będzie mieć ${adj}${issue.minimum.toString()} ${sizing.unit ?? "elementów"}`;
	                }
	                return `Zbyt mał(y/a/e): oczekiwano, że ${issue.origin ?? "wartość"} będzie wynosić ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Nieprawidłowy ciąg znaków: musi zaczynać się od "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Nieprawidłowy ciąg znaków: musi kończyć się na "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Nieprawidłowy ciąg znaków: musi zawierać "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${_issue.pattern}`;
	                return `Nieprawidłow(y/a/e) ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Nieprawidłowa liczba: musi być wielokrotnością ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Nierozpoznane klucze${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Nieprawidłowy klucz w ${issue.origin}`;
	            case "invalid_union":
	                return "Nieprawidłowe dane wejściowe";
	            case "invalid_element":
	                return `Nieprawidłowa wartość w ${issue.origin}`;
	            default:
	                return `Nieprawidłowe dane wejściowe`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (pl$2, pl$2.exports));

var plExports = pl$2.exports;
var pl$1 = /*@__PURE__*/getDefaultExportFromCjs(plExports);

var pt$2 = {exports: {}};

var pt = pt$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "caracteres", verb: "ter" },
	        file: { unit: "bytes", verb: "ter" },
	        array: { unit: "itens", verb: "ter" },
	        set: { unit: "itens", verb: "ter" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "número";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "nulo";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "padrão",
	        email: "endereço de e-mail",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "data e hora ISO",
	        date: "data ISO",
	        time: "hora ISO",
	        duration: "duração ISO",
	        ipv4: "endereço IPv4",
	        ipv6: "endereço IPv6",
	        cidrv4: "faixa de IPv4",
	        cidrv6: "faixa de IPv6",
	        base64: "texto codificado em base64",
	        base64url: "URL codificada em base64",
	        json_string: "texto JSON",
	        e164: "número E.164",
	        jwt: "JWT",
	        template_literal: "entrada",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Tipo inválido: esperado ${issue.expected}, recebido ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Entrada inválida: esperado ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Opção inválida: esperada uma das ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Muito grande: esperado que ${issue.origin ?? "valor"} tivesse ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementos"}`;
	                return `Muito grande: esperado que ${issue.origin ?? "valor"} fosse ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Muito pequeno: esperado que ${issue.origin} tivesse ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Muito pequeno: esperado que ${issue.origin} fosse ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Texto inválido: deve começar com "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Texto inválido: deve terminar com "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Texto inválido: deve incluir "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Texto inválido: deve corresponder ao padrão ${_issue.pattern}`;
	                return `${Nouns[_issue.format] ?? issue.format} inválido`;
	            }
	            case "not_multiple_of":
	                return `Número inválido: deve ser múltiplo de ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Chave${issue.keys.length > 1 ? "s" : ""} desconhecida${issue.keys.length > 1 ? "s" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Chave inválida em ${issue.origin}`;
	            case "invalid_union":
	                return "Entrada inválida";
	            case "invalid_element":
	                return `Valor inválido em ${issue.origin}`;
	            default:
	                return `Campo inválido`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (pt$2, pt$2.exports));

var ptExports = pt$2.exports;
var pt$1 = /*@__PURE__*/getDefaultExportFromCjs(ptExports);

var ru$2 = {exports: {}};

var ru = ru$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	function getRussianPlural(count, one, few, many) {
	    const absCount = Math.abs(count);
	    const lastDigit = absCount % 10;
	    const lastTwoDigits = absCount % 100;
	    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
	        return many;
	    }
	    if (lastDigit === 1) {
	        return one;
	    }
	    if (lastDigit >= 2 && lastDigit <= 4) {
	        return few;
	    }
	    return many;
	}
	const error = () => {
	    const Sizable = {
	        string: {
	            unit: {
	                one: "символ",
	                few: "символа",
	                many: "символов",
	            },
	            verb: "иметь",
	        },
	        file: {
	            unit: {
	                one: "байт",
	                few: "байта",
	                many: "байт",
	            },
	            verb: "иметь",
	        },
	        array: {
	            unit: {
	                one: "элемент",
	                few: "элемента",
	                many: "элементов",
	            },
	            verb: "иметь",
	        },
	        set: {
	            unit: {
	                one: "элемент",
	                few: "элемента",
	                many: "элементов",
	            },
	            verb: "иметь",
	        },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "число";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "массив";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "ввод",
	        email: "email адрес",
	        url: "URL",
	        emoji: "эмодзи",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO дата и время",
	        date: "ISO дата",
	        time: "ISO время",
	        duration: "ISO длительность",
	        ipv4: "IPv4 адрес",
	        ipv6: "IPv6 адрес",
	        cidrv4: "IPv4 диапазон",
	        cidrv6: "IPv6 диапазон",
	        base64: "строка в формате base64",
	        base64url: "строка в формате base64url",
	        json_string: "JSON строка",
	        e164: "номер E.164",
	        jwt: "JWT",
	        template_literal: "ввод",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Неверный ввод: ожидалось ${issue.expected}, получено ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Неверный ввод: ожидалось ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Неверный вариант: ожидалось одно из ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    const maxValue = Number(issue.maximum);
	                    const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
	                    return `Слишком большое значение: ожидалось, что ${issue.origin ?? "значение"} будет иметь ${adj}${issue.maximum.toString()} ${unit}`;
	                }
	                return `Слишком большое значение: ожидалось, что ${issue.origin ?? "значение"} будет ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    const minValue = Number(issue.minimum);
	                    const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
	                    return `Слишком маленькое значение: ожидалось, что ${issue.origin} будет иметь ${adj}${issue.minimum.toString()} ${unit}`;
	                }
	                return `Слишком маленькое значение: ожидалось, что ${issue.origin} будет ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Неверная строка: должна начинаться с "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Неверная строка: должна заканчиваться на "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Неверная строка: должна содержать "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Неверная строка: должна соответствовать шаблону ${_issue.pattern}`;
	                return `Неверный ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Неверное число: должно быть кратным ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Нераспознанн${issue.keys.length > 1 ? "ые" : "ый"} ключ${issue.keys.length > 1 ? "и" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Неверный ключ в ${issue.origin}`;
	            case "invalid_union":
	                return "Неверные входные данные";
	            case "invalid_element":
	                return `Неверное значение в ${issue.origin}`;
	            default:
	                return `Неверные входные данные`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ru$2, ru$2.exports));

var ruExports = ru$2.exports;
var ru$1 = /*@__PURE__*/getDefaultExportFromCjs(ruExports);

var sl$2 = {exports: {}};

var sl = sl$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "znakov", verb: "imeti" },
	        file: { unit: "bajtov", verb: "imeti" },
	        array: { unit: "elementov", verb: "imeti" },
	        set: { unit: "elementov", verb: "imeti" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "število";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "tabela";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "vnos",
	        email: "e-poštni naslov",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO datum in čas",
	        date: "ISO datum",
	        time: "ISO čas",
	        duration: "ISO trajanje",
	        ipv4: "IPv4 naslov",
	        ipv6: "IPv6 naslov",
	        cidrv4: "obseg IPv4",
	        cidrv6: "obseg IPv6",
	        base64: "base64 kodiran niz",
	        base64url: "base64url kodiran niz",
	        json_string: "JSON niz",
	        e164: "E.164 številka",
	        jwt: "JWT",
	        template_literal: "vnos",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Neveljaven vnos: pričakovano ${issue.expected}, prejeto ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Neveljaven vnos: pričakovano ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Neveljavna možnost: pričakovano eno izmed ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Preveliko: pričakovano, da bo ${issue.origin ?? "vrednost"} imelo ${adj}${issue.maximum.toString()} ${sizing.unit ?? "elementov"}`;
	                return `Preveliko: pričakovano, da bo ${issue.origin ?? "vrednost"} ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Premajhno: pričakovano, da bo ${issue.origin} imelo ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Premajhno: pričakovano, da bo ${issue.origin} ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `Neveljaven niz: mora se začeti z "${_issue.prefix}"`;
	                }
	                if (_issue.format === "ends_with")
	                    return `Neveljaven niz: mora se končati z "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
	                return `Neveljaven ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Neveljavno število: mora biti večkratnik ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Neprepoznan${issue.keys.length > 1 ? "i ključi" : " ključ"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Neveljaven ključ v ${issue.origin}`;
	            case "invalid_union":
	                return "Neveljaven vnos";
	            case "invalid_element":
	                return `Neveljavna vrednost v ${issue.origin}`;
	            default:
	                return "Neveljaven vnos";
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (sl$2, sl$2.exports));

var slExports = sl$2.exports;
var sl$1 = /*@__PURE__*/getDefaultExportFromCjs(slExports);

var sv$2 = {exports: {}};

var sv = sv$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "tecken", verb: "att ha" },
	        file: { unit: "bytes", verb: "att ha" },
	        array: { unit: "objekt", verb: "att innehålla" },
	        set: { unit: "objekt", verb: "att innehålla" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "antal";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "lista";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "reguljärt uttryck",
	        email: "e-postadress",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO-datum och tid",
	        date: "ISO-datum",
	        time: "ISO-tid",
	        duration: "ISO-varaktighet",
	        ipv4: "IPv4-intervall",
	        ipv6: "IPv6-intervall",
	        cidrv4: "IPv4-spektrum",
	        cidrv6: "IPv6-spektrum",
	        base64: "base64-kodad sträng",
	        base64url: "base64url-kodad sträng",
	        json_string: "JSON-sträng",
	        e164: "E.164-nummer",
	        jwt: "JWT",
	        template_literal: "mall-literal",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Ogiltig inmatning: förväntat ${issue.expected}, fick ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Ogiltig inmatning: förväntat ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Ogiltigt val: förväntade en av ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `För stor(t): förväntade ${issue.origin ?? "värdet"} att ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? "element"}`;
	                }
	                return `För stor(t): förväntat ${issue.origin ?? "värdet"} att ha ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `För lite(t): förväntade ${issue.origin ?? "värdet"} att ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `För lite(t): förväntade ${issue.origin ?? "värdet"} att ha ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `Ogiltig sträng: måste börja med "${_issue.prefix}"`;
	                }
	                if (_issue.format === "ends_with")
	                    return `Ogiltig sträng: måste sluta med "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Ogiltig sträng: måste innehålla "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Ogiltig sträng: måste matcha mönstret "${_issue.pattern}"`;
	                return `Ogiltig(t) ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Ogiltigt tal: måste vara en multipel av ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `${issue.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Ogiltig nyckel i ${issue.origin ?? "värdet"}`;
	            case "invalid_union":
	                return "Ogiltig input";
	            case "invalid_element":
	                return `Ogiltigt värde i ${issue.origin ?? "värdet"}`;
	            default:
	                return `Ogiltig input`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (sv$2, sv$2.exports));

var svExports = sv$2.exports;
var sv$1 = /*@__PURE__*/getDefaultExportFromCjs(svExports);

var ta$2 = {exports: {}};

var ta = ta$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
	        file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
	        array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
	        set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "எண் அல்லாதது" : "எண்";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "அணி";
	                }
	                if (data === null) {
	                    return "வெறுமை";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "உள்ளீடு",
	        email: "மின்னஞ்சல் முகவரி",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO தேதி நேரம்",
	        date: "ISO தேதி",
	        time: "ISO நேரம்",
	        duration: "ISO கால அளவு",
	        ipv4: "IPv4 முகவரி",
	        ipv6: "IPv6 முகவரி",
	        cidrv4: "IPv4 வரம்பு",
	        cidrv6: "IPv6 வரம்பு",
	        base64: "base64-encoded சரம்",
	        base64url: "base64url-encoded சரம்",
	        json_string: "JSON சரம்",
	        e164: "E.164 எண்",
	        jwt: "JWT",
	        template_literal: "input",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${issue.expected}, பெறப்பட்டது ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${util.stringifyPrimitive(issue.values[0])}`;
	                return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${util.joinValues(issue.values, "|")} இல் ஒன்று`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue.origin ?? "மதிப்பு"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்`;
	                }
	                return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue.origin ?? "மதிப்பு"} ${adj}${issue.maximum.toString()} ஆக இருக்க வேண்டும்`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} ஆக இருக்க வேண்டும்`; //
	                }
	                return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue.origin} ${adj}${issue.minimum.toString()} ஆக இருக்க வேண்டும்`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `தவறான சரம்: "${_issue.prefix}" இல் தொடங்க வேண்டும்`;
	                if (_issue.format === "ends_with")
	                    return `தவறான சரம்: "${_issue.suffix}" இல் முடிவடைய வேண்டும்`;
	                if (_issue.format === "includes")
	                    return `தவறான சரம்: "${_issue.includes}" ஐ உள்ளடக்க வேண்டும்`;
	                if (_issue.format === "regex")
	                    return `தவறான சரம்: ${_issue.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
	                return `தவறான ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `தவறான எண்: ${issue.divisor} இன் பலமாக இருக்க வேண்டும்`;
	            case "unrecognized_keys":
	                return `அடையாளம் தெரியாத விசை${issue.keys.length > 1 ? "கள்" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `${issue.origin} இல் தவறான விசை`;
	            case "invalid_union":
	                return "தவறான உள்ளீடு";
	            case "invalid_element":
	                return `${issue.origin} இல் தவறான மதிப்பு`;
	            default:
	                return `தவறான உள்ளீடு`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ta$2, ta$2.exports));

var taExports = ta$2.exports;
var ta$1 = /*@__PURE__*/getDefaultExportFromCjs(taExports);

var th$2 = {exports: {}};

var th = th$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "ตัวอักษร", verb: "ควรมี" },
	        file: { unit: "ไบต์", verb: "ควรมี" },
	        array: { unit: "รายการ", verb: "ควรมี" },
	        set: { unit: "รายการ", verb: "ควรมี" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "อาร์เรย์ (Array)";
	                }
	                if (data === null) {
	                    return "ไม่มีค่า (null)";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "ข้อมูลที่ป้อน",
	        email: "ที่อยู่อีเมล",
	        url: "URL",
	        emoji: "อิโมจิ",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "วันที่เวลาแบบ ISO",
	        date: "วันที่แบบ ISO",
	        time: "เวลาแบบ ISO",
	        duration: "ช่วงเวลาแบบ ISO",
	        ipv4: "ที่อยู่ IPv4",
	        ipv6: "ที่อยู่ IPv6",
	        cidrv4: "ช่วง IP แบบ IPv4",
	        cidrv6: "ช่วง IP แบบ IPv6",
	        base64: "ข้อความแบบ Base64",
	        base64url: "ข้อความแบบ Base64 สำหรับ URL",
	        json_string: "ข้อความแบบ JSON",
	        e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
	        jwt: "โทเคน JWT",
	        template_literal: "ข้อมูลที่ป้อน",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${issue.expected} แต่ได้รับ ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `ค่าไม่ถูกต้อง: ควรเป็น ${util.stringifyPrimitive(issue.values[0])}`;
	                return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "ไม่เกิน" : "น้อยกว่า";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `เกินกำหนด: ${issue.origin ?? "ค่า"} ควรมี${adj} ${issue.maximum.toString()} ${sizing.unit ?? "รายการ"}`;
	                return `เกินกำหนด: ${issue.origin ?? "ค่า"} ควรมี${adj} ${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? "อย่างน้อย" : "มากกว่า";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `น้อยกว่ากำหนด: ${issue.origin} ควรมี${adj} ${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `น้อยกว่ากำหนด: ${issue.origin} ควรมี${adj} ${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${_issue.prefix}"`;
	                }
	                if (_issue.format === "ends_with")
	                    return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${_issue.includes}" อยู่ในข้อความ`;
	                if (_issue.format === "regex")
	                    return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${_issue.pattern}`;
	                return `รูปแบบไม่ถูกต้อง: ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${issue.divisor} ได้ลงตัว`;
	            case "unrecognized_keys":
	                return `พบคีย์ที่ไม่รู้จัก: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `คีย์ไม่ถูกต้องใน ${issue.origin}`;
	            case "invalid_union":
	                return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
	            case "invalid_element":
	                return `ข้อมูลไม่ถูกต้องใน ${issue.origin}`;
	            default:
	                return `ข้อมูลไม่ถูกต้อง`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (th$2, th$2.exports));

var thExports = th$2.exports;
var th$1 = /*@__PURE__*/getDefaultExportFromCjs(thExports);

var tr$1 = {};

(function (exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parsedType = void 0;
	exports.default = default_1;
	const util = __importStar(util$3);
	const parsedType = (data) => {
	    const t = typeof data;
	    switch (t) {
	        case "number": {
	            return Number.isNaN(data) ? "NaN" : "number";
	        }
	        case "object": {
	            if (Array.isArray(data)) {
	                return "array";
	            }
	            if (data === null) {
	                return "null";
	            }
	            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                return data.constructor.name;
	            }
	        }
	    }
	    return t;
	};
	exports.parsedType = parsedType;
	const error = () => {
	    const Sizable = {
	        string: { unit: "karakter", verb: "olmalı" },
	        file: { unit: "bayt", verb: "olmalı" },
	        array: { unit: "öğe", verb: "olmalı" },
	        set: { unit: "öğe", verb: "olmalı" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const Nouns = {
	        regex: "girdi",
	        email: "e-posta adresi",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO tarih ve saat",
	        date: "ISO tarih",
	        time: "ISO saat",
	        duration: "ISO süre",
	        ipv4: "IPv4 adresi",
	        ipv6: "IPv6 adresi",
	        cidrv4: "IPv4 aralığı",
	        cidrv6: "IPv6 aralığı",
	        base64: "base64 ile şifrelenmiş metin",
	        base64url: "base64url ile şifrelenmiş metin",
	        json_string: "JSON dizesi",
	        e164: "E.164 sayısı",
	        jwt: "JWT",
	        template_literal: "Şablon dizesi",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Geçersiz değer: beklenen ${issue.expected}, alınan ${(0, exports.parsedType)(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Geçersiz değer: beklenen ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Çok büyük: beklenen ${issue.origin ?? "değer"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "öğe"}`;
	                return `Çok büyük: beklenen ${issue.origin ?? "değer"} ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Çok küçük: beklenen ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                return `Çok küçük: beklenen ${issue.origin} ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Geçersiz metin: "${_issue.prefix}" ile başlamalı`;
	                if (_issue.format === "ends_with")
	                    return `Geçersiz metin: "${_issue.suffix}" ile bitmeli`;
	                if (_issue.format === "includes")
	                    return `Geçersiz metin: "${_issue.includes}" içermeli`;
	                if (_issue.format === "regex")
	                    return `Geçersiz metin: ${_issue.pattern} desenine uymalı`;
	                return `Geçersiz ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Geçersiz sayı: ${issue.divisor} ile tam bölünebilmeli`;
	            case "unrecognized_keys":
	                return `Tanınmayan anahtar${issue.keys.length > 1 ? "lar" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `${issue.origin} içinde geçersiz anahtar`;
	            case "invalid_union":
	                return "Geçersiz değer";
	            case "invalid_element":
	                return `${issue.origin} içinde geçersiz değer`;
	            default:
	                return `Geçersiz değer`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	} 
} (tr$1));

var tr = /*@__PURE__*/getDefaultExportFromCjs(tr$1);

var ua$2 = {exports: {}};

var ua = ua$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "символів", verb: "матиме" },
	        file: { unit: "байтів", verb: "матиме" },
	        array: { unit: "елементів", verb: "матиме" },
	        set: { unit: "елементів", verb: "матиме" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "число";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "масив";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "вхідні дані",
	        email: "адреса електронної пошти",
	        url: "URL",
	        emoji: "емодзі",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "дата та час ISO",
	        date: "дата ISO",
	        time: "час ISO",
	        duration: "тривалість ISO",
	        ipv4: "адреса IPv4",
	        ipv6: "адреса IPv6",
	        cidrv4: "діапазон IPv4",
	        cidrv6: "діапазон IPv6",
	        base64: "рядок у кодуванні base64",
	        base64url: "рядок у кодуванні base64url",
	        json_string: "рядок JSON",
	        e164: "номер E.164",
	        jwt: "JWT",
	        template_literal: "вхідні дані",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${parsedType(issue.input)}`;
	            // return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${util.getParsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Неправильні вхідні дані: очікується ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Неправильна опція: очікується одне з ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Занадто велике: очікується, що ${issue.origin ?? "значення"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "елементів"}`;
	                return `Занадто велике: очікується, що ${issue.origin ?? "значення"} буде ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Занадто мале: очікується, що ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Занадто мале: очікується, що ${issue.origin} буде ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Неправильний рядок: повинен починатися з "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Неправильний рядок: повинен закінчуватися на "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Неправильний рядок: повинен містити "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Неправильний рядок: повинен відповідати шаблону ${_issue.pattern}`;
	                return `Неправильний ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Неправильне число: повинно бути кратним ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Нерозпізнаний ключ${issue.keys.length > 1 ? "і" : ""}: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Неправильний ключ у ${issue.origin}`;
	            case "invalid_union":
	                return "Неправильні вхідні дані";
	            case "invalid_element":
	                return `Неправильне значення у ${issue.origin}`;
	            default:
	                return `Неправильні вхідні дані`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ua$2, ua$2.exports));

var uaExports = ua$2.exports;
var ua$1 = /*@__PURE__*/getDefaultExportFromCjs(uaExports);

var ur$2 = {exports: {}};

var ur = ur$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "حروف", verb: "ہونا" },
	        file: { unit: "بائٹس", verb: "ہونا" },
	        array: { unit: "آئٹمز", verb: "ہونا" },
	        set: { unit: "آئٹمز", verb: "ہونا" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "نمبر";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "آرے";
	                }
	                if (data === null) {
	                    return "نل";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "ان پٹ",
	        email: "ای میل ایڈریس",
	        url: "یو آر ایل",
	        emoji: "ایموجی",
	        uuid: "یو یو آئی ڈی",
	        uuidv4: "یو یو آئی ڈی وی 4",
	        uuidv6: "یو یو آئی ڈی وی 6",
	        nanoid: "نینو آئی ڈی",
	        guid: "جی یو آئی ڈی",
	        cuid: "سی یو آئی ڈی",
	        cuid2: "سی یو آئی ڈی 2",
	        ulid: "یو ایل آئی ڈی",
	        xid: "ایکس آئی ڈی",
	        ksuid: "کے ایس یو آئی ڈی",
	        datetime: "آئی ایس او ڈیٹ ٹائم",
	        date: "آئی ایس او تاریخ",
	        time: "آئی ایس او وقت",
	        duration: "آئی ایس او مدت",
	        ipv4: "آئی پی وی 4 ایڈریس",
	        ipv6: "آئی پی وی 6 ایڈریس",
	        cidrv4: "آئی پی وی 4 رینج",
	        cidrv6: "آئی پی وی 6 رینج",
	        base64: "بیس 64 ان کوڈڈ سٹرنگ",
	        base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
	        json_string: "جے ایس او این سٹرنگ",
	        e164: "ای 164 نمبر",
	        jwt: "جے ڈبلیو ٹی",
	        template_literal: "ان پٹ",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `غلط ان پٹ: ${issue.expected} متوقع تھا، ${parsedType(issue.input)} موصول ہوا`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `غلط ان پٹ: ${util.stringifyPrimitive(issue.values[0])} متوقع تھا`;
	                return `غلط آپشن: ${util.joinValues(issue.values, "|")} میں سے ایک متوقع تھا`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `بہت بڑا: ${issue.origin ?? "ویلیو"} کے ${adj}${issue.maximum.toString()} ${sizing.unit ?? "عناصر"} ہونے متوقع تھے`;
	                return `بہت بڑا: ${issue.origin ?? "ویلیو"} کا ${adj}${issue.maximum.toString()} ہونا متوقع تھا`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `بہت چھوٹا: ${issue.origin} کے ${adj}${issue.minimum.toString()} ${sizing.unit} ہونے متوقع تھے`;
	                }
	                return `بہت چھوٹا: ${issue.origin} کا ${adj}${issue.minimum.toString()} ہونا متوقع تھا`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `غلط سٹرنگ: "${_issue.prefix}" سے شروع ہونا چاہیے`;
	                }
	                if (_issue.format === "ends_with")
	                    return `غلط سٹرنگ: "${_issue.suffix}" پر ختم ہونا چاہیے`;
	                if (_issue.format === "includes")
	                    return `غلط سٹرنگ: "${_issue.includes}" شامل ہونا چاہیے`;
	                if (_issue.format === "regex")
	                    return `غلط سٹرنگ: پیٹرن ${_issue.pattern} سے میچ ہونا چاہیے`;
	                return `غلط ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `غلط نمبر: ${issue.divisor} کا مضاعف ہونا چاہیے`;
	            case "unrecognized_keys":
	                return `غیر تسلیم شدہ کی${issue.keys.length > 1 ? "ز" : ""}: ${util.joinValues(issue.keys, "، ")}`;
	            case "invalid_key":
	                return `${issue.origin} میں غلط کی`;
	            case "invalid_union":
	                return "غلط ان پٹ";
	            case "invalid_element":
	                return `${issue.origin} میں غلط ویلیو`;
	            default:
	                return `غلط ان پٹ`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (ur$2, ur$2.exports));

var urExports = ur$2.exports;
var ur$1 = /*@__PURE__*/getDefaultExportFromCjs(urExports);

var vi$2 = {exports: {}};

var vi = vi$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "ký tự", verb: "có" },
	        file: { unit: "byte", verb: "có" },
	        array: { unit: "phần tử", verb: "có" },
	        set: { unit: "phần tử", verb: "có" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "số";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "mảng";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "đầu vào",
	        email: "địa chỉ email",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ngày giờ ISO",
	        date: "ngày ISO",
	        time: "giờ ISO",
	        duration: "khoảng thời gian ISO",
	        ipv4: "địa chỉ IPv4",
	        ipv6: "địa chỉ IPv6",
	        cidrv4: "dải IPv4",
	        cidrv6: "dải IPv6",
	        base64: "chuỗi mã hóa base64",
	        base64url: "chuỗi mã hóa base64url",
	        json_string: "chuỗi JSON",
	        e164: "số E.164",
	        jwt: "JWT",
	        template_literal: "đầu vào",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Đầu vào không hợp lệ: mong đợi ${issue.expected}, nhận được ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Đầu vào không hợp lệ: mong đợi ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Quá lớn: mong đợi ${issue.origin ?? "giá trị"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "phần tử"}`;
	                return `Quá lớn: mong đợi ${issue.origin ?? "giá trị"} ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `Quá nhỏ: mong đợi ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `Quá nhỏ: mong đợi ${issue.origin} ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Chuỗi không hợp lệ: phải bắt đầu bằng "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Chuỗi không hợp lệ: phải kết thúc bằng "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Chuỗi không hợp lệ: phải bao gồm "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Chuỗi không hợp lệ: phải khớp với mẫu ${_issue.pattern}`;
	                return `${Nouns[_issue.format] ?? issue.format} không hợp lệ`;
	            }
	            case "not_multiple_of":
	                return `Số không hợp lệ: phải là bội số của ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Khóa không được nhận dạng: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Khóa không hợp lệ trong ${issue.origin}`;
	            case "invalid_union":
	                return "Đầu vào không hợp lệ";
	            case "invalid_element":
	                return `Giá trị không hợp lệ trong ${issue.origin}`;
	            default:
	                return `Đầu vào không hợp lệ`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (vi$2, vi$2.exports));

var viExports = vi$2.exports;
var vi$1 = /*@__PURE__*/getDefaultExportFromCjs(viExports);

var zhCN$2 = {exports: {}};

var zhCN = zhCN$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "字符", verb: "包含" },
	        file: { unit: "字节", verb: "包含" },
	        array: { unit: "项", verb: "包含" },
	        set: { unit: "项", verb: "包含" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "非数字(NaN)" : "数字";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "数组";
	                }
	                if (data === null) {
	                    return "空值(null)";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "输入",
	        email: "电子邮件",
	        url: "URL",
	        emoji: "表情符号",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO日期时间",
	        date: "ISO日期",
	        time: "ISO时间",
	        duration: "ISO时长",
	        ipv4: "IPv4地址",
	        ipv6: "IPv6地址",
	        cidrv4: "IPv4网段",
	        cidrv6: "IPv6网段",
	        base64: "base64编码字符串",
	        base64url: "base64url编码字符串",
	        json_string: "JSON字符串",
	        e164: "E.164号码",
	        jwt: "JWT",
	        template_literal: "输入",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `无效输入：期望 ${issue.expected}，实际接收 ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `无效输入：期望 ${util.stringifyPrimitive(issue.values[0])}`;
	                return `无效选项：期望以下之一 ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `数值过大：期望 ${issue.origin ?? "值"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? "个元素"}`;
	                return `数值过大：期望 ${issue.origin ?? "值"} ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `数值过小：期望 ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `数值过小：期望 ${issue.origin} ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `无效字符串：必须以 "${_issue.prefix}" 开头`;
	                if (_issue.format === "ends_with")
	                    return `无效字符串：必须以 "${_issue.suffix}" 结尾`;
	                if (_issue.format === "includes")
	                    return `无效字符串：必须包含 "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;
	                return `无效${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `无效数字：必须是 ${issue.divisor} 的倍数`;
	            case "unrecognized_keys":
	                return `出现未知的键(key): ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `${issue.origin} 中的键(key)无效`;
	            case "invalid_union":
	                return "无效输入";
	            case "invalid_element":
	                return `${issue.origin} 中包含无效值(value)`;
	            default:
	                return `无效输入`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (zhCN$2, zhCN$2.exports));

var zhCNExports = zhCN$2.exports;
var zhCN$1 = /*@__PURE__*/getDefaultExportFromCjs(zhCNExports);

var zhTW$2 = {exports: {}};

var zhTW = zhTW$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "字元", verb: "擁有" },
	        file: { unit: "位元組", verb: "擁有" },
	        array: { unit: "項目", verb: "擁有" },
	        set: { unit: "項目", verb: "擁有" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "number";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "array";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "輸入",
	        email: "郵件地址",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "ISO 日期時間",
	        date: "ISO 日期",
	        time: "ISO 時間",
	        duration: "ISO 期間",
	        ipv4: "IPv4 位址",
	        ipv6: "IPv6 位址",
	        cidrv4: "IPv4 範圍",
	        cidrv6: "IPv6 範圍",
	        base64: "base64 編碼字串",
	        base64url: "base64url 編碼字串",
	        json_string: "JSON 字串",
	        e164: "E.164 數值",
	        jwt: "JWT",
	        template_literal: "輸入",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `無效的輸入值：預期為 ${issue.expected}，但收到 ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `無效的輸入值：預期為 ${util.stringifyPrimitive(issue.values[0])}`;
	                return `無效的選項：預期為以下其中之一 ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `數值過大：預期 ${issue.origin ?? "值"} 應為 ${adj}${issue.maximum.toString()} ${sizing.unit ?? "個元素"}`;
	                return `數值過大：預期 ${issue.origin ?? "值"} 應為 ${adj}${issue.maximum.toString()}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing) {
	                    return `數值過小：預期 ${issue.origin} 應為 ${adj}${issue.minimum.toString()} ${sizing.unit}`;
	                }
	                return `數值過小：預期 ${issue.origin} 應為 ${adj}${issue.minimum.toString()}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with") {
	                    return `無效的字串：必須以 "${_issue.prefix}" 開頭`;
	                }
	                if (_issue.format === "ends_with")
	                    return `無效的字串：必須以 "${_issue.suffix}" 結尾`;
	                if (_issue.format === "includes")
	                    return `無效的字串：必須包含 "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `無效的字串：必須符合格式 ${_issue.pattern}`;
	                return `無效的 ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `無效的數字：必須為 ${issue.divisor} 的倍數`;
	            case "unrecognized_keys":
	                return `無法識別的鍵值${issue.keys.length > 1 ? "們" : ""}：${util.joinValues(issue.keys, "、")}`;
	            case "invalid_key":
	                return `${issue.origin} 中有無效的鍵值`;
	            case "invalid_union":
	                return "無效的輸入值";
	            case "invalid_element":
	                return `${issue.origin} 中有無效的值`;
	            default:
	                return `無效的輸入值`;
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (zhTW$2, zhTW$2.exports));

var zhTWExports = zhTW$2.exports;
var zhTW$1 = /*@__PURE__*/getDefaultExportFromCjs(zhTWExports);

var yo$2 = {exports: {}};

var yo = yo$2.exports;

(function (module, exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = default_1;
	const util = __importStar(util$3);
	const error = () => {
	    const Sizable = {
	        string: { unit: "àmi", verb: "ní" },
	        file: { unit: "bytes", verb: "ní" },
	        array: { unit: "nkan", verb: "ní" },
	        set: { unit: "nkan", verb: "ní" },
	    };
	    function getSizing(origin) {
	        return Sizable[origin] ?? null;
	    }
	    const parsedType = (data) => {
	        const t = typeof data;
	        switch (t) {
	            case "number": {
	                return Number.isNaN(data) ? "NaN" : "nọ́mbà";
	            }
	            case "object": {
	                if (Array.isArray(data)) {
	                    return "akopọ";
	                }
	                if (data === null) {
	                    return "null";
	                }
	                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
	                    return data.constructor.name;
	                }
	            }
	        }
	        return t;
	    };
	    const Nouns = {
	        regex: "ẹ̀rọ ìbáwọlé",
	        email: "àdírẹ́sì ìmẹ́lì",
	        url: "URL",
	        emoji: "emoji",
	        uuid: "UUID",
	        uuidv4: "UUIDv4",
	        uuidv6: "UUIDv6",
	        nanoid: "nanoid",
	        guid: "GUID",
	        cuid: "cuid",
	        cuid2: "cuid2",
	        ulid: "ULID",
	        xid: "XID",
	        ksuid: "KSUID",
	        datetime: "àkókò ISO",
	        date: "ọjọ́ ISO",
	        time: "àkókò ISO",
	        duration: "àkókò tó pé ISO",
	        ipv4: "àdírẹ́sì IPv4",
	        ipv6: "àdírẹ́sì IPv6",
	        cidrv4: "àgbègbè IPv4",
	        cidrv6: "àgbègbè IPv6",
	        base64: "ọ̀rọ̀ tí a kọ́ ní base64",
	        base64url: "ọ̀rọ̀ base64url",
	        json_string: "ọ̀rọ̀ JSON",
	        e164: "nọ́mbà E.164",
	        jwt: "JWT",
	        template_literal: "ẹ̀rọ ìbáwọlé",
	    };
	    return (issue) => {
	        switch (issue.code) {
	            case "invalid_type":
	                return `Ìbáwọlé aṣìṣe: a ní láti fi ${issue.expected}, àmọ̀ a rí ${parsedType(issue.input)}`;
	            case "invalid_value":
	                if (issue.values.length === 1)
	                    return `Ìbáwọlé aṣìṣe: a ní láti fi ${util.stringifyPrimitive(issue.values[0])}`;
	                return `Àṣàyàn aṣìṣe: yan ọ̀kan lára ${util.joinValues(issue.values, "|")}`;
	            case "too_big": {
	                const adj = issue.inclusive ? "<=" : "<";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Tó pọ̀ jù: a ní láti jẹ́ pé ${issue.origin ?? "iye"} ${sizing.verb} ${adj}${issue.maximum} ${sizing.unit}`;
	                return `Tó pọ̀ jù: a ní láti jẹ́ ${adj}${issue.maximum}`;
	            }
	            case "too_small": {
	                const adj = issue.inclusive ? ">=" : ">";
	                const sizing = getSizing(issue.origin);
	                if (sizing)
	                    return `Kéré ju: a ní láti jẹ́ pé ${issue.origin} ${sizing.verb} ${adj}${issue.minimum} ${sizing.unit}`;
	                return `Kéré ju: a ní láti jẹ́ ${adj}${issue.minimum}`;
	            }
	            case "invalid_format": {
	                const _issue = issue;
	                if (_issue.format === "starts_with")
	                    return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀lú "${_issue.prefix}"`;
	                if (_issue.format === "ends_with")
	                    return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ parí pẹ̀lú "${_issue.suffix}"`;
	                if (_issue.format === "includes")
	                    return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ ní "${_issue.includes}"`;
	                if (_issue.format === "regex")
	                    return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bá àpẹẹrẹ mu ${_issue.pattern}`;
	                return `Aṣìṣe: ${Nouns[_issue.format] ?? issue.format}`;
	            }
	            case "not_multiple_of":
	                return `Nọ́mbà aṣìṣe: gbọ́dọ̀ jẹ́ èyà pípín ti ${issue.divisor}`;
	            case "unrecognized_keys":
	                return `Bọtìnì àìmọ̀: ${util.joinValues(issue.keys, ", ")}`;
	            case "invalid_key":
	                return `Bọtìnì aṣìṣe nínú ${issue.origin}`;
	            case "invalid_union":
	                return "Ìbáwọlé aṣìṣe";
	            case "invalid_element":
	                return `Iye aṣìṣe nínú ${issue.origin}`;
	            default:
	                return "Ìbáwọlé aṣìṣe";
	        }
	    };
	};
	function default_1() {
	    return {
	        localeError: error(),
	    };
	}
	module.exports = exports.default; 
} (yo$2, yo$2.exports));

var yoExports = yo$2.exports;
var yo$1 = /*@__PURE__*/getDefaultExportFromCjs(yoExports);

(function (exports) {
	"use strict";
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.yo = exports.zhTW = exports.zhCN = exports.vi = exports.ur = exports.ua = exports.tr = exports.th = exports.ta = exports.sv = exports.sl = exports.ru = exports.pt = exports.pl = exports.ps = exports.ota = exports.no = exports.nl = exports.ms = exports.mk = exports.ko = exports.kh = exports.ja = exports.it = exports.is = exports.id = exports.hu = exports.he = exports.frCA = exports.fr = exports.fi = exports.fa = exports.es = exports.eo = exports.en = exports.de = exports.da = exports.cs = exports.ca = exports.be = exports.az = exports.ar = void 0;
	var ar_js_1 = arExports;
	Object.defineProperty(exports, "ar", { enumerable: true, get: function () { return __importDefault(ar_js_1).default; } });
	var az_js_1 = azExports;
	Object.defineProperty(exports, "az", { enumerable: true, get: function () { return __importDefault(az_js_1).default; } });
	var be_js_1 = beExports;
	Object.defineProperty(exports, "be", { enumerable: true, get: function () { return __importDefault(be_js_1).default; } });
	var ca_js_1 = caExports;
	Object.defineProperty(exports, "ca", { enumerable: true, get: function () { return __importDefault(ca_js_1).default; } });
	var cs_js_1 = csExports;
	Object.defineProperty(exports, "cs", { enumerable: true, get: function () { return __importDefault(cs_js_1).default; } });
	var da_js_1 = daExports;
	Object.defineProperty(exports, "da", { enumerable: true, get: function () { return __importDefault(da_js_1).default; } });
	var de_js_1 = deExports;
	Object.defineProperty(exports, "de", { enumerable: true, get: function () { return __importDefault(de_js_1).default; } });
	var en_js_1 = en$1;
	Object.defineProperty(exports, "en", { enumerable: true, get: function () { return __importDefault(en_js_1).default; } });
	var eo_js_1 = eo$1;
	Object.defineProperty(exports, "eo", { enumerable: true, get: function () { return __importDefault(eo_js_1).default; } });
	var es_js_1 = esExports;
	Object.defineProperty(exports, "es", { enumerable: true, get: function () { return __importDefault(es_js_1).default; } });
	var fa_js_1 = faExports;
	Object.defineProperty(exports, "fa", { enumerable: true, get: function () { return __importDefault(fa_js_1).default; } });
	var fi_js_1 = fiExports;
	Object.defineProperty(exports, "fi", { enumerable: true, get: function () { return __importDefault(fi_js_1).default; } });
	var fr_js_1 = frExports;
	Object.defineProperty(exports, "fr", { enumerable: true, get: function () { return __importDefault(fr_js_1).default; } });
	var fr_CA_js_1 = frCAExports;
	Object.defineProperty(exports, "frCA", { enumerable: true, get: function () { return __importDefault(fr_CA_js_1).default; } });
	var he_js_1 = heExports;
	Object.defineProperty(exports, "he", { enumerable: true, get: function () { return __importDefault(he_js_1).default; } });
	var hu_js_1 = huExports;
	Object.defineProperty(exports, "hu", { enumerable: true, get: function () { return __importDefault(hu_js_1).default; } });
	var id_js_1 = idExports;
	Object.defineProperty(exports, "id", { enumerable: true, get: function () { return __importDefault(id_js_1).default; } });
	var is_js_1 = is$1;
	Object.defineProperty(exports, "is", { enumerable: true, get: function () { return __importDefault(is_js_1).default; } });
	var it_js_1 = itExports;
	Object.defineProperty(exports, "it", { enumerable: true, get: function () { return __importDefault(it_js_1).default; } });
	var ja_js_1 = jaExports;
	Object.defineProperty(exports, "ja", { enumerable: true, get: function () { return __importDefault(ja_js_1).default; } });
	var kh_js_1 = khExports;
	Object.defineProperty(exports, "kh", { enumerable: true, get: function () { return __importDefault(kh_js_1).default; } });
	var ko_js_1 = koExports;
	Object.defineProperty(exports, "ko", { enumerable: true, get: function () { return __importDefault(ko_js_1).default; } });
	var mk_js_1 = mkExports;
	Object.defineProperty(exports, "mk", { enumerable: true, get: function () { return __importDefault(mk_js_1).default; } });
	var ms_js_1 = msExports;
	Object.defineProperty(exports, "ms", { enumerable: true, get: function () { return __importDefault(ms_js_1).default; } });
	var nl_js_1 = nlExports;
	Object.defineProperty(exports, "nl", { enumerable: true, get: function () { return __importDefault(nl_js_1).default; } });
	var no_js_1 = noExports;
	Object.defineProperty(exports, "no", { enumerable: true, get: function () { return __importDefault(no_js_1).default; } });
	var ota_js_1 = otaExports;
	Object.defineProperty(exports, "ota", { enumerable: true, get: function () { return __importDefault(ota_js_1).default; } });
	var ps_js_1 = psExports;
	Object.defineProperty(exports, "ps", { enumerable: true, get: function () { return __importDefault(ps_js_1).default; } });
	var pl_js_1 = plExports;
	Object.defineProperty(exports, "pl", { enumerable: true, get: function () { return __importDefault(pl_js_1).default; } });
	var pt_js_1 = ptExports;
	Object.defineProperty(exports, "pt", { enumerable: true, get: function () { return __importDefault(pt_js_1).default; } });
	var ru_js_1 = ruExports;
	Object.defineProperty(exports, "ru", { enumerable: true, get: function () { return __importDefault(ru_js_1).default; } });
	var sl_js_1 = slExports;
	Object.defineProperty(exports, "sl", { enumerable: true, get: function () { return __importDefault(sl_js_1).default; } });
	var sv_js_1 = svExports;
	Object.defineProperty(exports, "sv", { enumerable: true, get: function () { return __importDefault(sv_js_1).default; } });
	var ta_js_1 = taExports;
	Object.defineProperty(exports, "ta", { enumerable: true, get: function () { return __importDefault(ta_js_1).default; } });
	var th_js_1 = thExports;
	Object.defineProperty(exports, "th", { enumerable: true, get: function () { return __importDefault(th_js_1).default; } });
	var tr_js_1 = tr$1;
	Object.defineProperty(exports, "tr", { enumerable: true, get: function () { return __importDefault(tr_js_1).default; } });
	var ua_js_1 = uaExports;
	Object.defineProperty(exports, "ua", { enumerable: true, get: function () { return __importDefault(ua_js_1).default; } });
	var ur_js_1 = urExports;
	Object.defineProperty(exports, "ur", { enumerable: true, get: function () { return __importDefault(ur_js_1).default; } });
	var vi_js_1 = viExports;
	Object.defineProperty(exports, "vi", { enumerable: true, get: function () { return __importDefault(vi_js_1).default; } });
	var zh_CN_js_1 = zhCNExports;
	Object.defineProperty(exports, "zhCN", { enumerable: true, get: function () { return __importDefault(zh_CN_js_1).default; } });
	var zh_TW_js_1 = zhTWExports;
	Object.defineProperty(exports, "zhTW", { enumerable: true, get: function () { return __importDefault(zh_TW_js_1).default; } });
	var yo_js_1 = yoExports;
	Object.defineProperty(exports, "yo", { enumerable: true, get: function () { return __importDefault(yo_js_1).default; } }); 
} (locales));

var index$4 = /*@__PURE__*/getDefaultExportFromCjs(locales);

var registries = {};

"use strict";
Object.defineProperty(registries, "__esModule", { value: true });
var globalRegistry = registries.globalRegistry = $ZodRegistry_1 = registries.$ZodRegistry = $input = registries.$input = $output = registries.$output = void 0;
var registry_1 = registries.registry = registry;
var $output = registries.$output = Symbol("ZodOutput");
var $input = registries.$input = Symbol("ZodInput");
class $ZodRegistry {
    constructor() {
        this._map = new Map();
        this._idmap = new Map();
    }
    add(schema, ..._meta) {
        const meta = _meta[0];
        this._map.set(schema, meta);
        if (meta && typeof meta === "object" && "id" in meta) {
            if (this._idmap.has(meta.id)) {
                throw new Error(`ID ${meta.id} already exists in the registry`);
            }
            this._idmap.set(meta.id, schema);
        }
        return this;
    }
    clear() {
        this._map = new Map();
        this._idmap = new Map();
        return this;
    }
    remove(schema) {
        const meta = this._map.get(schema);
        if (meta && typeof meta === "object" && "id" in meta) {
            this._idmap.delete(meta.id);
        }
        this._map.delete(schema);
        return this;
    }
    get(schema) {
        // return this._map.get(schema) as any;
        // inherit metadata
        const p = schema._zod.parent;
        if (p) {
            const pm = { ...(this.get(p) ?? {}) };
            delete pm.id; // do not inherit id
            const f = { ...pm, ...this._map.get(schema) };
            return Object.keys(f).length ? f : undefined;
        }
        return this._map.get(schema);
    }
    has(schema) {
        return this._map.has(schema);
    }
}
var $ZodRegistry_1 = registries.$ZodRegistry = $ZodRegistry;
// registries
function registry() {
    return new $ZodRegistry();
}
globalRegistry = registries.globalRegistry = registry();

var api = {};

"use strict";
var __createBinding$3 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$3 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$3 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
    __setModuleDefault$3(result, mod);
    return result;
};
Object.defineProperty(api, "__esModule", { value: true });
var TimePrecision = api.TimePrecision = void 0;
var _string_1 = api._string = _string;
var _coercedString_1 = api._coercedString = _coercedString;
var _email_1 = api._email = _email;
var _guid_1 = api._guid = _guid;
var _uuid_1 = api._uuid = _uuid;
var _uuidv4_1 = api._uuidv4 = _uuidv4;
var _uuidv6_1 = api._uuidv6 = _uuidv6;
var _uuidv7_1 = api._uuidv7 = _uuidv7;
var _url_1 = api._url = _url;
var _emoji_1 = api._emoji = _emoji;
var _nanoid_1 = api._nanoid = _nanoid;
var _cuid_1 = api._cuid = _cuid;
var _cuid2_1 = api._cuid2 = _cuid2;
var _ulid_1 = api._ulid = _ulid;
var _xid_1 = api._xid = _xid;
var _ksuid_1 = api._ksuid = _ksuid;
var _ipv4_1 = api._ipv4 = _ipv4;
var _ipv6_1 = api._ipv6 = _ipv6;
var _cidrv4_1 = api._cidrv4 = _cidrv4;
var _cidrv6_1 = api._cidrv6 = _cidrv6;
var _base64_1 = api._base64 = _base64;
var _base64url_1 = api._base64url = _base64url;
var _e164_1 = api._e164 = _e164;
var _jwt_1 = api._jwt = _jwt;
var _isoDateTime_1 = api._isoDateTime = _isoDateTime;
var _isoDate_1 = api._isoDate = _isoDate;
var _isoTime_1 = api._isoTime = _isoTime;
var _isoDuration_1 = api._isoDuration = _isoDuration;
var _number_1 = api._number = _number;
var _coercedNumber_1 = api._coercedNumber = _coercedNumber;
var _int_1 = api._int = _int;
var _float32_1 = api._float32 = _float32;
var _float64_1 = api._float64 = _float64;
var _int32_1 = api._int32 = _int32;
var _uint32_1 = api._uint32 = _uint32;
var _boolean_1 = api._boolean = _boolean;
var _coercedBoolean_1 = api._coercedBoolean = _coercedBoolean;
var _bigint_1 = api._bigint = _bigint;
var _coercedBigint_1 = api._coercedBigint = _coercedBigint;
var _int64_1 = api._int64 = _int64;
var _uint64_1 = api._uint64 = _uint64;
var _symbol_1 = api._symbol = _symbol;
var _undefined_1 = api._undefined = _undefined;
var _null_1 = api._null = _null;
var _any_1 = api._any = _any;
var _unknown_1 = api._unknown = _unknown;
var _never_1 = api._never = _never;
var _void_1 = api._void = _void;
var _date_1 = api._date = _date;
var _coercedDate_1 = api._coercedDate = _coercedDate;
var _nan_1 = api._nan = _nan;
var _lt_1 = api._lt = _lt;
var _lte_1 = api._lte = _lte;
var _max = api._max = _lte;
_lte_1 = api._lte = _lte;
_max = api._max = _lte;
var _gt_1 = api._gt = _gt;
var _gte_1 = api._gte = _gte;
var _min = api._min = _gte;
_gte_1 = api._gte = _gte;
_min = api._min = _gte;
var _positive_1 = api._positive = _positive;
var _negative_1 = api._negative = _negative;
var _nonpositive_1 = api._nonpositive = _nonpositive;
var _nonnegative_1 = api._nonnegative = _nonnegative;
var _multipleOf_1 = api._multipleOf = _multipleOf;
var _maxSize_1 = api._maxSize = _maxSize;
var _minSize_1 = api._minSize = _minSize;
var _size_1 = api._size = _size;
var _maxLength_1 = api._maxLength = _maxLength;
var _minLength_1 = api._minLength = _minLength;
var _length_1 = api._length = _length;
var _regex_1 = api._regex = _regex;
var _lowercase_1 = api._lowercase = _lowercase;
var _uppercase_1 = api._uppercase = _uppercase;
var _includes_1 = api._includes = _includes;
var _startsWith_1 = api._startsWith = _startsWith;
var _endsWith_1 = api._endsWith = _endsWith;
var _property_1 = api._property = _property;
var _mime_1 = api._mime = _mime;
var _overwrite_1 = api._overwrite = _overwrite;
var _normalize_1 = api._normalize = _normalize;
var _trim_1 = api._trim = _trim;
var _toLowerCase_1 = api._toLowerCase = _toLowerCase;
var _toUpperCase_1 = api._toUpperCase = _toUpperCase;
var _array_1 = api._array = _array;
var _union_1 = api._union = _union;
var _discriminatedUnion_1 = api._discriminatedUnion = _discriminatedUnion;
var _intersection_1 = api._intersection = _intersection;
var _tuple_1 = api._tuple = _tuple;
var _record_1 = api._record = _record;
var _map_1 = api._map = _map;
var _set_1 = api._set = _set;
var _enum_1 = api._enum = _enum;
var _nativeEnum_1 = api._nativeEnum = _nativeEnum;
var _literal_1 = api._literal = _literal;
var _file_1 = api._file = _file;
var _transform_1 = api._transform = _transform;
var _optional_1 = api._optional = _optional;
var _nullable_1 = api._nullable = _nullable;
var _default_1 = api._default = _default;
var _nonoptional_1 = api._nonoptional = _nonoptional;
var _success_1 = api._success = _success;
var _catch_1 = api._catch = _catch;
var _pipe_1 = api._pipe = _pipe;
var _readonly_1 = api._readonly = _readonly;
var _templateLiteral_1 = api._templateLiteral = _templateLiteral;
var _lazy_1 = api._lazy = _lazy;
var _promise_1 = api._promise = _promise;
var _custom_1 = api._custom = _custom;
var _refine_1 = api._refine = _refine;
var _superRefine_1 = api._superRefine = _superRefine;
var _check_1 = api._check = _check;
var _stringbool_1 = api._stringbool = _stringbool;
var _stringFormat_1 = api._stringFormat = _stringFormat;
const checks$2 = __importStar$3(checks$4);
const schemas$2 = __importStar$3(schemas$4);
const util$1 = __importStar$3(util$3);
function _string(Class, params) {
    return new Class({
        type: "string",
        ...util$1.normalizeParams(params),
    });
}
function _coercedString(Class, params) {
    return new Class({
        type: "string",
        coerce: true,
        ...util$1.normalizeParams(params),
    });
}
function _email(Class, params) {
    return new Class({
        type: "string",
        format: "email",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _guid(Class, params) {
    return new Class({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _uuid(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _uuidv4(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v4",
        ...util$1.normalizeParams(params),
    });
}
function _uuidv6(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v6",
        ...util$1.normalizeParams(params),
    });
}
function _uuidv7(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v7",
        ...util$1.normalizeParams(params),
    });
}
function _url(Class, params) {
    return new Class({
        type: "string",
        format: "url",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _emoji(Class, params) {
    return new Class({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _nanoid(Class, params) {
    return new Class({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _cuid(Class, params) {
    return new Class({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _cuid2(Class, params) {
    return new Class({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _ulid(Class, params) {
    return new Class({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _xid(Class, params) {
    return new Class({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _ksuid(Class, params) {
    return new Class({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _ipv4(Class, params) {
    return new Class({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _ipv6(Class, params) {
    return new Class({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _cidrv4(Class, params) {
    return new Class({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _cidrv6(Class, params) {
    return new Class({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _base64(Class, params) {
    return new Class({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _base64url(Class, params) {
    return new Class({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _e164(Class, params) {
    return new Class({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
function _jwt(Class, params) {
    return new Class({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: false,
        ...util$1.normalizeParams(params),
    });
}
TimePrecision = api.TimePrecision = {
    Any: null,
    Minute: -1,
    Second: 0,
    Millisecond: 3,
    Microsecond: 6,
};
function _isoDateTime(Class, params) {
    return new Class({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: false,
        local: false,
        precision: null,
        ...util$1.normalizeParams(params),
    });
}
function _isoDate(Class, params) {
    return new Class({
        type: "string",
        format: "date",
        check: "string_format",
        ...util$1.normalizeParams(params),
    });
}
function _isoTime(Class, params) {
    return new Class({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ...util$1.normalizeParams(params),
    });
}
function _isoDuration(Class, params) {
    return new Class({
        type: "string",
        format: "duration",
        check: "string_format",
        ...util$1.normalizeParams(params),
    });
}
function _number(Class, params) {
    return new Class({
        type: "number",
        checks: [],
        ...util$1.normalizeParams(params),
    });
}
function _coercedNumber(Class, params) {
    return new Class({
        type: "number",
        coerce: true,
        checks: [],
        ...util$1.normalizeParams(params),
    });
}
function _int(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "safeint",
        ...util$1.normalizeParams(params),
    });
}
function _float32(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float32",
        ...util$1.normalizeParams(params),
    });
}
function _float64(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "float64",
        ...util$1.normalizeParams(params),
    });
}
function _int32(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "int32",
        ...util$1.normalizeParams(params),
    });
}
function _uint32(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "uint32",
        ...util$1.normalizeParams(params),
    });
}
function _boolean(Class, params) {
    return new Class({
        type: "boolean",
        ...util$1.normalizeParams(params),
    });
}
function _coercedBoolean(Class, params) {
    return new Class({
        type: "boolean",
        coerce: true,
        ...util$1.normalizeParams(params),
    });
}
function _bigint(Class, params) {
    return new Class({
        type: "bigint",
        ...util$1.normalizeParams(params),
    });
}
function _coercedBigint(Class, params) {
    return new Class({
        type: "bigint",
        coerce: true,
        ...util$1.normalizeParams(params),
    });
}
function _int64(Class, params) {
    return new Class({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "int64",
        ...util$1.normalizeParams(params),
    });
}
function _uint64(Class, params) {
    return new Class({
        type: "bigint",
        check: "bigint_format",
        abort: false,
        format: "uint64",
        ...util$1.normalizeParams(params),
    });
}
function _symbol(Class, params) {
    return new Class({
        type: "symbol",
        ...util$1.normalizeParams(params),
    });
}
function _undefined(Class, params) {
    return new Class({
        type: "undefined",
        ...util$1.normalizeParams(params),
    });
}
function _null(Class, params) {
    return new Class({
        type: "null",
        ...util$1.normalizeParams(params),
    });
}
function _any(Class) {
    return new Class({
        type: "any",
    });
}
function _unknown(Class) {
    return new Class({
        type: "unknown",
    });
}
function _never(Class, params) {
    return new Class({
        type: "never",
        ...util$1.normalizeParams(params),
    });
}
function _void(Class, params) {
    return new Class({
        type: "void",
        ...util$1.normalizeParams(params),
    });
}
function _date(Class, params) {
    return new Class({
        type: "date",
        ...util$1.normalizeParams(params),
    });
}
function _coercedDate(Class, params) {
    return new Class({
        type: "date",
        coerce: true,
        ...util$1.normalizeParams(params),
    });
}
function _nan(Class, params) {
    return new Class({
        type: "nan",
        ...util$1.normalizeParams(params),
    });
}
function _lt(value, params) {
    return new checks$2.$ZodCheckLessThan({
        check: "less_than",
        ...util$1.normalizeParams(params),
        value,
        inclusive: false,
    });
}
function _lte(value, params) {
    return new checks$2.$ZodCheckLessThan({
        check: "less_than",
        ...util$1.normalizeParams(params),
        value,
        inclusive: true,
    });
}
function _gt(value, params) {
    return new checks$2.$ZodCheckGreaterThan({
        check: "greater_than",
        ...util$1.normalizeParams(params),
        value,
        inclusive: false,
    });
}
function _gte(value, params) {
    return new checks$2.$ZodCheckGreaterThan({
        check: "greater_than",
        ...util$1.normalizeParams(params),
        value,
        inclusive: true,
    });
}
function _positive(params) {
    return _gt(0, params);
}
// negative
function _negative(params) {
    return _lt(0, params);
}
// nonpositive
function _nonpositive(params) {
    return _lte(0, params);
}
// nonnegative
function _nonnegative(params) {
    return _gte(0, params);
}
function _multipleOf(value, params) {
    return new checks$2.$ZodCheckMultipleOf({
        check: "multiple_of",
        ...util$1.normalizeParams(params),
        value,
    });
}
function _maxSize(maximum, params) {
    return new checks$2.$ZodCheckMaxSize({
        check: "max_size",
        ...util$1.normalizeParams(params),
        maximum,
    });
}
function _minSize(minimum, params) {
    return new checks$2.$ZodCheckMinSize({
        check: "min_size",
        ...util$1.normalizeParams(params),
        minimum,
    });
}
function _size(size, params) {
    return new checks$2.$ZodCheckSizeEquals({
        check: "size_equals",
        ...util$1.normalizeParams(params),
        size,
    });
}
function _maxLength(maximum, params) {
    const ch = new checks$2.$ZodCheckMaxLength({
        check: "max_length",
        ...util$1.normalizeParams(params),
        maximum,
    });
    return ch;
}
function _minLength(minimum, params) {
    return new checks$2.$ZodCheckMinLength({
        check: "min_length",
        ...util$1.normalizeParams(params),
        minimum,
    });
}
function _length(length, params) {
    return new checks$2.$ZodCheckLengthEquals({
        check: "length_equals",
        ...util$1.normalizeParams(params),
        length,
    });
}
function _regex(pattern, params) {
    return new checks$2.$ZodCheckRegex({
        check: "string_format",
        format: "regex",
        ...util$1.normalizeParams(params),
        pattern,
    });
}
function _lowercase(params) {
    return new checks$2.$ZodCheckLowerCase({
        check: "string_format",
        format: "lowercase",
        ...util$1.normalizeParams(params),
    });
}
function _uppercase(params) {
    return new checks$2.$ZodCheckUpperCase({
        check: "string_format",
        format: "uppercase",
        ...util$1.normalizeParams(params),
    });
}
function _includes(includes, params) {
    return new checks$2.$ZodCheckIncludes({
        check: "string_format",
        format: "includes",
        ...util$1.normalizeParams(params),
        includes,
    });
}
function _startsWith(prefix, params) {
    return new checks$2.$ZodCheckStartsWith({
        check: "string_format",
        format: "starts_with",
        ...util$1.normalizeParams(params),
        prefix,
    });
}
function _endsWith(suffix, params) {
    return new checks$2.$ZodCheckEndsWith({
        check: "string_format",
        format: "ends_with",
        ...util$1.normalizeParams(params),
        suffix,
    });
}
function _property(property, schema, params) {
    return new checks$2.$ZodCheckProperty({
        check: "property",
        property,
        schema,
        ...util$1.normalizeParams(params),
    });
}
function _mime(types, params) {
    return new checks$2.$ZodCheckMimeType({
        check: "mime_type",
        mime: types,
        ...util$1.normalizeParams(params),
    });
}
function _overwrite(tx) {
    return new checks$2.$ZodCheckOverwrite({
        check: "overwrite",
        tx,
    });
}
// normalize
function _normalize(form) {
    return _overwrite((input) => input.normalize(form));
}
// trim
function _trim() {
    return _overwrite((input) => input.trim());
}
// toLowerCase
function _toLowerCase() {
    return _overwrite((input) => input.toLowerCase());
}
// toUpperCase
function _toUpperCase() {
    return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element, params) {
    return new Class({
        type: "array",
        element,
        // get element() {
        //   return element;
        // },
        ...util$1.normalizeParams(params),
    });
}
function _union(Class, options, params) {
    return new Class({
        type: "union",
        options,
        ...util$1.normalizeParams(params),
    });
}
function _discriminatedUnion(Class, discriminator, options, params) {
    return new Class({
        type: "union",
        options,
        discriminator,
        ...util$1.normalizeParams(params),
    });
}
function _intersection(Class, left, right) {
    return new Class({
        type: "intersection",
        left,
        right,
    });
}
// export function _tuple(
//   Class: util.SchemaClass<schemas.$ZodTuple>,
//   items: [],
//   params?: string | $ZodTupleParams
// ): schemas.$ZodTuple<[], null>;
function _tuple(Class, items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof schemas$2.$ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new Class({
        type: "tuple",
        items,
        rest,
        ...util$1.normalizeParams(params),
    });
}
function _record(Class, keyType, valueType, params) {
    return new Class({
        type: "record",
        keyType,
        valueType,
        ...util$1.normalizeParams(params),
    });
}
function _map(Class, keyType, valueType, params) {
    return new Class({
        type: "map",
        keyType,
        valueType,
        ...util$1.normalizeParams(params),
    });
}
function _set(Class, valueType, params) {
    return new Class({
        type: "set",
        valueType,
        ...util$1.normalizeParams(params),
    });
}
function _enum(Class, values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    // if (Array.isArray(values)) {
    //   for (const value of values) {
    //     entries[value] = value;
    //   }
    // } else {
    //   Object.assign(entries, values);
    // }
    // const entries: util.EnumLike = {};
    // for (const val of values) {
    //   entries[val] = val;
    // }
    return new Class({
        type: "enum",
        entries,
        ...util$1.normalizeParams(params),
    });
}
/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
 *
 * ```ts
 * enum Colors { red, green, blue }
 * z.enum(Colors);
 * ```
 */
function _nativeEnum(Class, entries, params) {
    return new Class({
        type: "enum",
        entries,
        ...util$1.normalizeParams(params),
    });
}
function _literal(Class, value, params) {
    return new Class({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ...util$1.normalizeParams(params),
    });
}
function _file(Class, params) {
    return new Class({
        type: "file",
        ...util$1.normalizeParams(params),
    });
}
function _transform(Class, fn) {
    return new Class({
        type: "transform",
        transform: fn,
    });
}
function _optional(Class, innerType) {
    return new Class({
        type: "optional",
        innerType,
    });
}
function _nullable(Class, innerType) {
    return new Class({
        type: "nullable",
        innerType,
    });
}
function _default(Class, innerType, defaultValue) {
    return new Class({
        type: "default",
        innerType,
        get defaultValue() {
            return typeof defaultValue === "function" ? defaultValue() : util$1.shallowClone(defaultValue);
        },
    });
}
function _nonoptional(Class, innerType, params) {
    return new Class({
        type: "nonoptional",
        innerType,
        ...util$1.normalizeParams(params),
    });
}
function _success(Class, innerType) {
    return new Class({
        type: "success",
        innerType,
    });
}
function _catch(Class, innerType, catchValue) {
    return new Class({
        type: "catch",
        innerType,
        catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue),
    });
}
function _pipe(Class, in_, out) {
    return new Class({
        type: "pipe",
        in: in_,
        out,
    });
}
function _readonly(Class, innerType) {
    return new Class({
        type: "readonly",
        innerType,
    });
}
function _templateLiteral(Class, parts, params) {
    return new Class({
        type: "template_literal",
        parts,
        ...util$1.normalizeParams(params),
    });
}
function _lazy(Class, getter) {
    return new Class({
        type: "lazy",
        getter,
    });
}
function _promise(Class, innerType) {
    return new Class({
        type: "promise",
        innerType,
    });
}
function _custom(Class, fn, _params) {
    const norm = util$1.normalizeParams(_params);
    norm.abort ?? (norm.abort = true); // default to abort:false
    const schema = new Class({
        type: "custom",
        check: "custom",
        fn: fn,
        ...norm,
    });
    return schema;
}
// same as _custom but defaults to abort:false
function _refine(Class, fn, _params) {
    const schema = new Class({
        type: "custom",
        check: "custom",
        fn: fn,
        ...util$1.normalizeParams(_params),
    });
    return schema;
}
function _superRefine(fn) {
    const ch = _check((payload) => {
        payload.addIssue = (issue) => {
            if (typeof issue === "string") {
                payload.issues.push(util$1.issue(issue, payload.value, ch._zod.def));
            }
            else {
                // for Zod 3 backwards compatibility
                const _issue = issue;
                if (_issue.fatal)
                    _issue.continue = false;
                _issue.code ?? (_issue.code = "custom");
                _issue.input ?? (_issue.input = payload.value);
                _issue.inst ?? (_issue.inst = ch);
                _issue.continue ?? (_issue.continue = !ch._zod.def.abort); // abort is always undefined, so this is always true...
                payload.issues.push(util$1.issue(_issue));
            }
        };
        return fn(payload.value, payload);
    });
    return ch;
}
function _check(fn, params) {
    const ch = new checks$2.$ZodCheck({
        check: "custom",
        ...util$1.normalizeParams(params),
    });
    ch._zod.check = fn;
    return ch;
}
function _stringbool(Classes, _params) {
    const params = util$1.normalizeParams(_params);
    let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
    let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
    if (params.case !== "sensitive") {
        truthyArray = truthyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
        falsyArray = falsyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
    }
    const truthySet = new Set(truthyArray);
    const falsySet = new Set(falsyArray);
    const _Codec = Classes.Codec ?? schemas$2.$ZodCodec;
    const _Boolean = Classes.Boolean ?? schemas$2.$ZodBoolean;
    const _String = Classes.String ?? schemas$2.$ZodString;
    const stringSchema = new _String({ type: "string", error: params.error });
    const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
    const codec = new _Codec({
        type: "pipe",
        in: stringSchema,
        out: booleanSchema,
        transform: ((input, payload) => {
            let data = input;
            if (params.case !== "sensitive")
                data = data.toLowerCase();
            if (truthySet.has(data)) {
                return true;
            }
            else if (falsySet.has(data)) {
                return false;
            }
            else {
                payload.issues.push({
                    code: "invalid_value",
                    expected: "stringbool",
                    values: [...truthySet, ...falsySet],
                    input: payload.value,
                    inst: codec,
                    continue: false,
                });
                return {};
            }
        }),
        reverseTransform: ((input, _payload) => {
            if (input === true) {
                return truthyArray[0] || "true";
            }
            else {
                return falsyArray[0] || "false";
            }
        }),
        error: params.error,
    });
    return codec;
}
function _stringFormat(Class, format, fnOrRegex, _params = {}) {
    const params = util$1.normalizeParams(_params);
    const def = {
        ...util$1.normalizeParams(_params),
        check: "string_format",
        type: "string",
        format,
        fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
        ...params,
    };
    if (fnOrRegex instanceof RegExp) {
        def.pattern = fnOrRegex;
    }
    const inst = new Class(def);
    return inst;
}

var toJsonSchema = {};

"use strict";
Object.defineProperty(toJsonSchema, "__esModule", { value: true });
var JSONSchemaGenerator_1 = toJsonSchema.JSONSchemaGenerator = void 0;
var toJSONSchema_1 = toJsonSchema.toJSONSchema = toJSONSchema;
const registries_js_1 = registries;
const util_js_1 = util$3;
class JSONSchemaGenerator {
    constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? registries_js_1.globalRegistry;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => { });
        this.io = params?.io ?? "output";
        this.seen = new Map();
    }
    process(schema, _params = { path: [], schemaPath: [] }) {
        var _a;
        const def = schema._zod.def;
        const formatMap = {
            guid: "uuid",
            url: "uri",
            datetime: "date-time",
            json_string: "json-string",
            regex: "", // do not set
        };
        // check for schema in seens
        const seen = this.seen.get(schema);
        if (seen) {
            seen.count++;
            // check if cycle
            const isCycle = _params.schemaPath.includes(schema);
            if (isCycle) {
                seen.cycle = _params.path;
            }
            return seen.schema;
        }
        // initialize
        const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
        this.seen.set(schema, result);
        // custom method overrides default behavior
        const overrideSchema = schema._zod.toJSONSchema?.();
        if (overrideSchema) {
            result.schema = overrideSchema;
        }
        else {
            const params = {
                ..._params,
                schemaPath: [..._params.schemaPath, schema],
                path: _params.path,
            };
            const parent = schema._zod.parent;
            if (parent) {
                // schema was cloned from another schema
                result.ref = parent;
                this.process(parent, params);
                this.seen.get(parent).isParent = true;
            }
            else {
                const _json = result.schema;
                switch (def.type) {
                    case "string": {
                        const json = _json;
                        json.type = "string";
                        const { minimum, maximum, format, patterns, contentEncoding } = schema._zod
                            .bag;
                        if (typeof minimum === "number")
                            json.minLength = minimum;
                        if (typeof maximum === "number")
                            json.maxLength = maximum;
                        // custom pattern overrides format
                        if (format) {
                            json.format = formatMap[format] ?? format;
                            if (json.format === "")
                                delete json.format; // empty format is not valid
                        }
                        if (contentEncoding)
                            json.contentEncoding = contentEncoding;
                        if (patterns && patterns.size > 0) {
                            const regexes = [...patterns];
                            if (regexes.length === 1)
                                json.pattern = regexes[0].source;
                            else if (regexes.length > 1) {
                                result.schema.allOf = [
                                    ...regexes.map((regex) => ({
                                        ...(this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0"
                                            ? { type: "string" }
                                            : {}),
                                        pattern: regex.source,
                                    })),
                                ];
                            }
                        }
                        break;
                    }
                    case "number": {
                        const json = _json;
                        const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                        if (typeof format === "string" && format.includes("int"))
                            json.type = "integer";
                        else
                            json.type = "number";
                        if (typeof exclusiveMinimum === "number") {
                            if (this.target === "draft-4" || this.target === "openapi-3.0") {
                                json.minimum = exclusiveMinimum;
                                json.exclusiveMinimum = true;
                            }
                            else {
                                json.exclusiveMinimum = exclusiveMinimum;
                            }
                        }
                        if (typeof minimum === "number") {
                            json.minimum = minimum;
                            if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                                if (exclusiveMinimum >= minimum)
                                    delete json.minimum;
                                else
                                    delete json.exclusiveMinimum;
                            }
                        }
                        if (typeof exclusiveMaximum === "number") {
                            if (this.target === "draft-4" || this.target === "openapi-3.0") {
                                json.maximum = exclusiveMaximum;
                                json.exclusiveMaximum = true;
                            }
                            else {
                                json.exclusiveMaximum = exclusiveMaximum;
                            }
                        }
                        if (typeof maximum === "number") {
                            json.maximum = maximum;
                            if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                                if (exclusiveMaximum <= maximum)
                                    delete json.maximum;
                                else
                                    delete json.exclusiveMaximum;
                            }
                        }
                        if (typeof multipleOf === "number")
                            json.multipleOf = multipleOf;
                        break;
                    }
                    case "boolean": {
                        const json = _json;
                        json.type = "boolean";
                        break;
                    }
                    case "bigint": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("BigInt cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "symbol": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Symbols cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "null": {
                        if (this.target === "openapi-3.0") {
                            _json.type = "string";
                            _json.nullable = true;
                            _json.enum = [null];
                        }
                        else
                            _json.type = "null";
                        break;
                    }
                    case "any": {
                        break;
                    }
                    case "unknown": {
                        break;
                    }
                    case "undefined": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Undefined cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "void": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Void cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "never": {
                        _json.not = {};
                        break;
                    }
                    case "date": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Date cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "array": {
                        const json = _json;
                        const { minimum, maximum } = schema._zod.bag;
                        if (typeof minimum === "number")
                            json.minItems = minimum;
                        if (typeof maximum === "number")
                            json.maxItems = maximum;
                        json.type = "array";
                        json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                        break;
                    }
                    case "object": {
                        const json = _json;
                        json.type = "object";
                        json.properties = {};
                        const shape = def.shape; // params.shapeCache.get(schema)!;
                        for (const key in shape) {
                            json.properties[key] = this.process(shape[key], {
                                ...params,
                                path: [...params.path, "properties", key],
                            });
                        }
                        // required keys
                        const allKeys = new Set(Object.keys(shape));
                        // const optionalKeys = new Set(def.optional);
                        const requiredKeys = new Set([...allKeys].filter((key) => {
                            const v = def.shape[key]._zod;
                            if (this.io === "input") {
                                return v.optin === undefined;
                            }
                            else {
                                return v.optout === undefined;
                            }
                        }));
                        if (requiredKeys.size > 0) {
                            json.required = Array.from(requiredKeys);
                        }
                        // catchall
                        if (def.catchall?._zod.def.type === "never") {
                            // strict
                            json.additionalProperties = false;
                        }
                        else if (!def.catchall) {
                            // regular
                            if (this.io === "output")
                                json.additionalProperties = false;
                        }
                        else if (def.catchall) {
                            json.additionalProperties = this.process(def.catchall, {
                                ...params,
                                path: [...params.path, "additionalProperties"],
                            });
                        }
                        break;
                    }
                    case "union": {
                        const json = _json;
                        const options = def.options.map((x, i) => this.process(x, {
                            ...params,
                            path: [...params.path, "anyOf", i],
                        }));
                        json.anyOf = options;
                        break;
                    }
                    case "intersection": {
                        const json = _json;
                        const a = this.process(def.left, {
                            ...params,
                            path: [...params.path, "allOf", 0],
                        });
                        const b = this.process(def.right, {
                            ...params,
                            path: [...params.path, "allOf", 1],
                        });
                        const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                        const allOf = [
                            ...(isSimpleIntersection(a) ? a.allOf : [a]),
                            ...(isSimpleIntersection(b) ? b.allOf : [b]),
                        ];
                        json.allOf = allOf;
                        break;
                    }
                    case "tuple": {
                        const json = _json;
                        json.type = "array";
                        const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
                        const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
                        const prefixItems = def.items.map((x, i) => this.process(x, {
                            ...params,
                            path: [...params.path, prefixPath, i],
                        }));
                        const rest = def.rest
                            ? this.process(def.rest, {
                                ...params,
                                path: [...params.path, restPath, ...(this.target === "openapi-3.0" ? [def.items.length] : [])],
                            })
                            : null;
                        if (this.target === "draft-2020-12") {
                            json.prefixItems = prefixItems;
                            if (rest) {
                                json.items = rest;
                            }
                        }
                        else if (this.target === "openapi-3.0") {
                            json.items = {
                                anyOf: prefixItems,
                            };
                            if (rest) {
                                json.items.anyOf.push(rest);
                            }
                            json.minItems = prefixItems.length;
                            if (!rest) {
                                json.maxItems = prefixItems.length;
                            }
                        }
                        else {
                            json.items = prefixItems;
                            if (rest) {
                                json.additionalItems = rest;
                            }
                        }
                        // length
                        const { minimum, maximum } = schema._zod.bag;
                        if (typeof minimum === "number")
                            json.minItems = minimum;
                        if (typeof maximum === "number")
                            json.maxItems = maximum;
                        break;
                    }
                    case "record": {
                        const json = _json;
                        json.type = "object";
                        if (this.target === "draft-7" || this.target === "draft-2020-12") {
                            json.propertyNames = this.process(def.keyType, {
                                ...params,
                                path: [...params.path, "propertyNames"],
                            });
                        }
                        json.additionalProperties = this.process(def.valueType, {
                            ...params,
                            path: [...params.path, "additionalProperties"],
                        });
                        break;
                    }
                    case "map": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Map cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "set": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Set cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "enum": {
                        const json = _json;
                        const values = (0, util_js_1.getEnumValues)(def.entries);
                        // Number enums can have both string and number values
                        if (values.every((v) => typeof v === "number"))
                            json.type = "number";
                        if (values.every((v) => typeof v === "string"))
                            json.type = "string";
                        json.enum = values;
                        break;
                    }
                    case "literal": {
                        const json = _json;
                        const vals = [];
                        for (const val of def.values) {
                            if (val === undefined) {
                                if (this.unrepresentable === "throw") {
                                    throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                                }
                                else {
                                    // do not add to vals
                                }
                            }
                            else if (typeof val === "bigint") {
                                if (this.unrepresentable === "throw") {
                                    throw new Error("BigInt literals cannot be represented in JSON Schema");
                                }
                                else {
                                    vals.push(Number(val));
                                }
                            }
                            else {
                                vals.push(val);
                            }
                        }
                        if (vals.length === 0) {
                            // do nothing (an undefined literal was stripped)
                        }
                        else if (vals.length === 1) {
                            const val = vals[0];
                            json.type = val === null ? "null" : typeof val;
                            if (this.target === "draft-4" || this.target === "openapi-3.0") {
                                json.enum = [val];
                            }
                            else {
                                json.const = val;
                            }
                        }
                        else {
                            if (vals.every((v) => typeof v === "number"))
                                json.type = "number";
                            if (vals.every((v) => typeof v === "string"))
                                json.type = "string";
                            if (vals.every((v) => typeof v === "boolean"))
                                json.type = "string";
                            if (vals.every((v) => v === null))
                                json.type = "null";
                            json.enum = vals;
                        }
                        break;
                    }
                    case "file": {
                        const json = _json;
                        const file = {
                            type: "string",
                            format: "binary",
                            contentEncoding: "binary",
                        };
                        const { minimum, maximum, mime } = schema._zod.bag;
                        if (minimum !== undefined)
                            file.minLength = minimum;
                        if (maximum !== undefined)
                            file.maxLength = maximum;
                        if (mime) {
                            if (mime.length === 1) {
                                file.contentMediaType = mime[0];
                                Object.assign(json, file);
                            }
                            else {
                                json.anyOf = mime.map((m) => {
                                    const mFile = { ...file, contentMediaType: m };
                                    return mFile;
                                });
                            }
                        }
                        else {
                            Object.assign(json, file);
                        }
                        // if (this.unrepresentable === "throw") {
                        //   throw new Error("File cannot be represented in JSON Schema");
                        // }
                        break;
                    }
                    case "transform": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Transforms cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "nullable": {
                        const inner = this.process(def.innerType, params);
                        if (this.target === "openapi-3.0") {
                            result.ref = def.innerType;
                            _json.nullable = true;
                        }
                        else {
                            _json.anyOf = [inner, { type: "null" }];
                        }
                        break;
                    }
                    case "nonoptional": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        break;
                    }
                    case "success": {
                        const json = _json;
                        json.type = "boolean";
                        break;
                    }
                    case "default": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                        break;
                    }
                    case "prefault": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        if (this.io === "input")
                            _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                        break;
                    }
                    case "catch": {
                        // use conditionals
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        let catchValue;
                        try {
                            catchValue = def.catchValue(undefined);
                        }
                        catch {
                            throw new Error("Dynamic catch values are not supported in JSON Schema");
                        }
                        _json.default = catchValue;
                        break;
                    }
                    case "nan": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("NaN cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "template_literal": {
                        const json = _json;
                        const pattern = schema._zod.pattern;
                        if (!pattern)
                            throw new Error("Pattern not found in template literal");
                        json.type = "string";
                        json.pattern = pattern.source;
                        break;
                    }
                    case "pipe": {
                        const innerType = this.io === "input" ? (def.in._zod.def.type === "transform" ? def.out : def.in) : def.out;
                        this.process(innerType, params);
                        result.ref = innerType;
                        break;
                    }
                    case "readonly": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        _json.readOnly = true;
                        break;
                    }
                    // passthrough types
                    case "promise": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        break;
                    }
                    case "optional": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        break;
                    }
                    case "lazy": {
                        const innerType = schema._zod.innerType;
                        this.process(innerType, params);
                        result.ref = innerType;
                        break;
                    }
                    case "custom": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Custom types cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "function": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Function types cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    default: {
                        def;
                    }
                }
            }
        }
        // metadata
        const meta = this.metadataRegistry.get(schema);
        if (meta)
            Object.assign(result.schema, meta);
        if (this.io === "input" && isTransforming(schema)) {
            // examples/defaults only apply to output type of pipe
            delete result.schema.examples;
            delete result.schema.default;
        }
        // set prefault as default
        if (this.io === "input" && result.schema._prefault)
            (_a = result.schema).default ?? (_a.default = result.schema._prefault);
        delete result.schema._prefault;
        // pulling fresh from this.seen in case it was overwritten
        const _result = this.seen.get(schema);
        return _result.schema;
    }
    emit(schema, _params) {
        const params = {
            cycles: _params?.cycles ?? "ref",
            reused: _params?.reused ?? "inline",
            // unrepresentable: _params?.unrepresentable ?? "throw",
            // uri: _params?.uri ?? ((id) => `${id}`),
            external: _params?.external ?? undefined,
        };
        // iterate over seen map;
        const root = this.seen.get(schema);
        if (!root)
            throw new Error("Unprocessed schema. This is a bug in Zod.");
        // initialize result with root schema fields
        // Object.assign(result, seen.cached);
        // returns a ref to the schema
        // defId will be empty if the ref points to an external schema (or #)
        const makeURI = (entry) => {
            // comparing the seen objects because sometimes
            // multiple schemas map to the same seen object.
            // e.g. lazy
            // external is configured
            const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
            if (params.external) {
                const externalId = params.external.registry.get(entry[0])?.id; // ?? "__shared";// `__schema${this.counter++}`;
                // check if schema is in the external registry
                const uriGenerator = params.external.uri ?? ((id) => id);
                if (externalId) {
                    return { ref: uriGenerator(externalId) };
                }
                // otherwise, add to __shared
                const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
                entry[1].defId = id; // set defId so it will be reused if needed
                return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
            }
            if (entry[1] === root) {
                return { ref: "#" };
            }
            // self-contained schema
            const uriPrefix = `#`;
            const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
            const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
            return { defId, ref: defUriPrefix + defId };
        };
        // stored cached version in `def` property
        // remove all properties, set $ref
        const extractToDef = (entry) => {
            // if the schema is already a reference, do not extract it
            if (entry[1].schema.$ref) {
                return;
            }
            const seen = entry[1];
            const { ref, defId } = makeURI(entry);
            seen.def = { ...seen.schema };
            // defId won't be set if the schema is a reference to an external schema
            if (defId)
                seen.defId = defId;
            // wipe away all properties except $ref
            const schema = seen.schema;
            for (const key in schema) {
                delete schema[key];
            }
            schema.$ref = ref;
        };
        // throw on cycles
        // break cycles
        if (params.cycles === "throw") {
            for (const entry of this.seen.entries()) {
                const seen = entry[1];
                if (seen.cycle) {
                    throw new Error("Cycle detected: " +
                        `#/${seen.cycle?.join("/")}/<root>` +
                        '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
                }
            }
        }
        // extract schemas into $defs
        for (const entry of this.seen.entries()) {
            const seen = entry[1];
            // convert root schema to # $ref
            if (schema === entry[0]) {
                extractToDef(entry); // this has special handling for the root schema
                continue;
            }
            // extract schemas that are in the external registry
            if (params.external) {
                const ext = params.external.registry.get(entry[0])?.id;
                if (schema !== entry[0] && ext) {
                    extractToDef(entry);
                    continue;
                }
            }
            // extract schemas with `id` meta
            const id = this.metadataRegistry.get(entry[0])?.id;
            if (id) {
                extractToDef(entry);
                continue;
            }
            // break cycles
            if (seen.cycle) {
                // any
                extractToDef(entry);
                continue;
            }
            // extract reused schemas
            if (seen.count > 1) {
                if (params.reused === "ref") {
                    extractToDef(entry);
                    // biome-ignore lint:
                    continue;
                }
            }
        }
        // flatten _refs
        const flattenRef = (zodSchema, params) => {
            const seen = this.seen.get(zodSchema);
            const schema = seen.def ?? seen.schema;
            const _cached = { ...schema };
            // already seen
            if (seen.ref === null) {
                return;
            }
            // flatten ref if defined
            const ref = seen.ref;
            seen.ref = null; // prevent recursion
            if (ref) {
                flattenRef(ref, params);
                // merge referenced schema into current
                const refSchema = this.seen.get(ref).schema;
                if (refSchema.$ref &&
                    (params.target === "draft-7" || params.target === "draft-4" || params.target === "openapi-3.0")) {
                    schema.allOf = schema.allOf ?? [];
                    schema.allOf.push(refSchema);
                }
                else {
                    Object.assign(schema, refSchema);
                    Object.assign(schema, _cached); // prevent overwriting any fields in the original schema
                }
            }
            // execute overrides
            if (!seen.isParent)
                this.override({
                    zodSchema: zodSchema,
                    jsonSchema: schema,
                    path: seen.path ?? [],
                });
        };
        for (const entry of [...this.seen.entries()].reverse()) {
            flattenRef(entry[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
            result.$schema = "https://json-schema.org/draft/2020-12/schema";
        }
        else if (this.target === "draft-7") {
            result.$schema = "http://json-schema.org/draft-07/schema#";
        }
        else if (this.target === "draft-4") {
            result.$schema = "http://json-schema.org/draft-04/schema#";
        }
        else if (this.target === "openapi-3.0") {
            // OpenAPI 3.0 schema objects should not include a $schema property
        }
        else {
            // @ts-ignore
            console.warn(`Invalid target: ${this.target}`);
        }
        if (params.external?.uri) {
            const id = params.external.registry.get(schema)?.id;
            if (!id)
                throw new Error("Schema is missing an `id` property");
            result.$id = params.external.uri(id);
        }
        Object.assign(result, root.def);
        // build defs object
        const defs = params.external?.defs ?? {};
        for (const entry of this.seen.entries()) {
            const seen = entry[1];
            if (seen.def && seen.defId) {
                defs[seen.defId] = seen.def;
            }
        }
        // set definitions in result
        if (params.external) {
        }
        else {
            if (Object.keys(defs).length > 0) {
                if (this.target === "draft-2020-12") {
                    result.$defs = defs;
                }
                else {
                    result.definitions = defs;
                }
            }
        }
        try {
            // this "finalizes" this schema and ensures all cycles are removed
            // each call to .emit() is functionally independent
            // though the seen map is shared
            return JSON.parse(JSON.stringify(result));
        }
        catch (_err) {
            throw new Error("Error converting schema to JSON.");
        }
    }
}
JSONSchemaGenerator_1 = toJsonSchema.JSONSchemaGenerator = JSONSchemaGenerator;
function toJSONSchema(input, _params) {
    if (input instanceof registries_js_1.$ZodRegistry) {
        const gen = new JSONSchemaGenerator(_params);
        const defs = {};
        for (const entry of input._idmap.entries()) {
            const [_, schema] = entry;
            gen.process(schema);
        }
        const schemas = {};
        const external = {
            registry: input,
            uri: _params?.uri,
            defs,
        };
        for (const entry of input._idmap.entries()) {
            const [key, schema] = entry;
            schemas[key] = gen.emit(schema, {
                ..._params,
                external,
            });
        }
        if (Object.keys(defs).length > 0) {
            const defsSegment = gen.target === "draft-2020-12" ? "$defs" : "definitions";
            schemas.__shared = {
                [defsSegment]: defs,
            };
        }
        return { schemas };
    }
    const gen = new JSONSchemaGenerator(_params);
    gen.process(input);
    return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
    const ctx = _ctx ?? { seen: new Set() };
    if (ctx.seen.has(_schema))
        return false;
    ctx.seen.add(_schema);
    const schema = _schema;
    const def = schema._zod.def;
    switch (def.type) {
        case "string":
        case "number":
        case "bigint":
        case "boolean":
        case "date":
        case "symbol":
        case "undefined":
        case "null":
        case "any":
        case "unknown":
        case "never":
        case "void":
        case "literal":
        case "enum":
        case "nan":
        case "file":
        case "template_literal":
            return false;
        case "array": {
            return isTransforming(def.element, ctx);
        }
        case "object": {
            for (const key in def.shape) {
                if (isTransforming(def.shape[key], ctx))
                    return true;
            }
            return false;
        }
        case "union": {
            for (const option of def.options) {
                if (isTransforming(option, ctx))
                    return true;
            }
            return false;
        }
        case "intersection": {
            return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
        }
        case "tuple": {
            for (const item of def.items) {
                if (isTransforming(item, ctx))
                    return true;
            }
            if (def.rest && isTransforming(def.rest, ctx))
                return true;
            return false;
        }
        case "record": {
            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "map": {
            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "set": {
            return isTransforming(def.valueType, ctx);
        }
        // inner types
        case "promise":
        case "optional":
        case "nonoptional":
        case "nullable":
        case "readonly":
            return isTransforming(def.innerType, ctx);
        case "lazy":
            return isTransforming(def.getter(), ctx);
        case "default": {
            return isTransforming(def.innerType, ctx);
        }
        case "prefault": {
            return isTransforming(def.innerType, ctx);
        }
        case "custom": {
            return false;
        }
        case "transform": {
            return true;
        }
        case "pipe": {
            return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
        }
        case "success": {
            return false;
        }
        case "catch": {
            return false;
        }
        case "function": {
            return false;
        }
        default:
            def;
    }
    throw new Error(`Unknown schema type: ${def.type}`);
}

var jsonSchema = {};

"use strict";
Object.defineProperty(jsonSchema, "__esModule", { value: true });

(function (exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSONSchema = exports.locales = exports.regexes = exports.util = void 0;
	__exportStar(core$4, exports);
	__exportStar(parse$4, exports);
	__exportStar(errors$6, exports);
	__exportStar(schemas$4, exports);
	__exportStar(checks$4, exports);
	__exportStar(versions, exports);
	exports.util = __importStar(util$3);
	exports.regexes = __importStar(regexes$1);
	exports.locales = __importStar(locales);
	__exportStar(registries, exports);
	__exportStar(doc, exports);
	__exportStar(api, exports);
	__exportStar(toJsonSchema, exports);
	exports.JSONSchema = __importStar(jsonSchema); 
} (core$5));

var index$3 = /*@__PURE__*/getDefaultExportFromCjs(core$5);

var schemas$1 = {};

var checks$1 = {};

(function (exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toUpperCase = exports.toLowerCase = exports.trim = exports.normalize = exports.overwrite = exports.mime = exports.property = exports.endsWith = exports.startsWith = exports.includes = exports.uppercase = exports.lowercase = exports.regex = exports.length = exports.minLength = exports.maxLength = exports.size = exports.minSize = exports.maxSize = exports.multipleOf = exports.nonnegative = exports.nonpositive = exports.negative = exports.positive = exports.gte = exports.gt = exports.lte = exports.lt = void 0;
	var index_js_1 = core$5;
	Object.defineProperty(exports, "lt", { enumerable: true, get: function () { return index_js_1._lt; } });
	Object.defineProperty(exports, "lte", { enumerable: true, get: function () { return index_js_1._lte; } });
	Object.defineProperty(exports, "gt", { enumerable: true, get: function () { return index_js_1._gt; } });
	Object.defineProperty(exports, "gte", { enumerable: true, get: function () { return index_js_1._gte; } });
	Object.defineProperty(exports, "positive", { enumerable: true, get: function () { return index_js_1._positive; } });
	Object.defineProperty(exports, "negative", { enumerable: true, get: function () { return index_js_1._negative; } });
	Object.defineProperty(exports, "nonpositive", { enumerable: true, get: function () { return index_js_1._nonpositive; } });
	Object.defineProperty(exports, "nonnegative", { enumerable: true, get: function () { return index_js_1._nonnegative; } });
	Object.defineProperty(exports, "multipleOf", { enumerable: true, get: function () { return index_js_1._multipleOf; } });
	Object.defineProperty(exports, "maxSize", { enumerable: true, get: function () { return index_js_1._maxSize; } });
	Object.defineProperty(exports, "minSize", { enumerable: true, get: function () { return index_js_1._minSize; } });
	Object.defineProperty(exports, "size", { enumerable: true, get: function () { return index_js_1._size; } });
	Object.defineProperty(exports, "maxLength", { enumerable: true, get: function () { return index_js_1._maxLength; } });
	Object.defineProperty(exports, "minLength", { enumerable: true, get: function () { return index_js_1._minLength; } });
	Object.defineProperty(exports, "length", { enumerable: true, get: function () { return index_js_1._length; } });
	Object.defineProperty(exports, "regex", { enumerable: true, get: function () { return index_js_1._regex; } });
	Object.defineProperty(exports, "lowercase", { enumerable: true, get: function () { return index_js_1._lowercase; } });
	Object.defineProperty(exports, "uppercase", { enumerable: true, get: function () { return index_js_1._uppercase; } });
	Object.defineProperty(exports, "includes", { enumerable: true, get: function () { return index_js_1._includes; } });
	Object.defineProperty(exports, "startsWith", { enumerable: true, get: function () { return index_js_1._startsWith; } });
	Object.defineProperty(exports, "endsWith", { enumerable: true, get: function () { return index_js_1._endsWith; } });
	Object.defineProperty(exports, "property", { enumerable: true, get: function () { return index_js_1._property; } });
	Object.defineProperty(exports, "mime", { enumerable: true, get: function () { return index_js_1._mime; } });
	Object.defineProperty(exports, "overwrite", { enumerable: true, get: function () { return index_js_1._overwrite; } });
	Object.defineProperty(exports, "normalize", { enumerable: true, get: function () { return index_js_1._normalize; } });
	Object.defineProperty(exports, "trim", { enumerable: true, get: function () { return index_js_1._trim; } });
	Object.defineProperty(exports, "toLowerCase", { enumerable: true, get: function () { return index_js_1._toLowerCase; } });
	Object.defineProperty(exports, "toUpperCase", { enumerable: true, get: function () { return index_js_1._toUpperCase; } }); 
} (checks$1));

var checks = /*@__PURE__*/getDefaultExportFromCjs(checks$1);

var iso = {};

var hasRequiredIso;

function requireIso () {
	if (hasRequiredIso) return iso;
	hasRequiredIso = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ZodISODuration = exports.ZodISOTime = exports.ZodISODate = exports.ZodISODateTime = void 0;
		exports.datetime = datetime;
		exports.date = date;
		exports.time = time;
		exports.duration = duration;
		const core = __importStar(core$5);
		const schemas = __importStar(requireSchemas());
		exports.ZodISODateTime = core.$constructor("ZodISODateTime", (inst, def) => {
		    core.$ZodISODateTime.init(inst, def);
		    schemas.ZodStringFormat.init(inst, def);
		});
		function datetime(params) {
		    return core._isoDateTime(exports.ZodISODateTime, params);
		}
		exports.ZodISODate = core.$constructor("ZodISODate", (inst, def) => {
		    core.$ZodISODate.init(inst, def);
		    schemas.ZodStringFormat.init(inst, def);
		});
		function date(params) {
		    return core._isoDate(exports.ZodISODate, params);
		}
		exports.ZodISOTime = core.$constructor("ZodISOTime", (inst, def) => {
		    core.$ZodISOTime.init(inst, def);
		    schemas.ZodStringFormat.init(inst, def);
		});
		function time(params) {
		    return core._isoTime(exports.ZodISOTime, params);
		}
		exports.ZodISODuration = core.$constructor("ZodISODuration", (inst, def) => {
		    core.$ZodISODuration.init(inst, def);
		    schemas.ZodStringFormat.init(inst, def);
		});
		function duration(params) {
		    return core._isoDuration(exports.ZodISODuration, params);
		} 
	} (iso));
	return iso;
}

var parse$2 = {};

var errors$5 = {};

"use strict";
var __createBinding$2 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$2 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$2 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
    __setModuleDefault$2(result, mod);
    return result;
};
Object.defineProperty(errors$5, "__esModule", { value: true });
var ZodRealError = errors$5.ZodRealError = ZodError = errors$5.ZodError = void 0;
const core$2 = __importStar$2(core$5);
const index_js_1 = core$5;
const util = __importStar$2(util$3);
const initializer = (inst, issues) => {
    index_js_1.$ZodError.init(inst, issues);
    inst.name = "ZodError";
    Object.defineProperties(inst, {
        format: {
            value: (mapper) => core$2.formatError(inst, mapper),
            // enumerable: false,
        },
        flatten: {
            value: (mapper) => core$2.flattenError(inst, mapper),
            // enumerable: false,
        },
        addIssue: {
            value: (issue) => {
                inst.issues.push(issue);
                inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);
            },
            // enumerable: false,
        },
        addIssues: {
            value: (issues) => {
                inst.issues.push(...issues);
                inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);
            },
            // enumerable: false,
        },
        isEmpty: {
            get() {
                return inst.issues.length === 0;
            },
            // enumerable: false,
        },
    });
    // Object.defineProperty(inst, "isEmpty", {
    //   get() {
    //     return inst.issues.length === 0;
    //   },
    // });
};
var ZodError = errors$5.ZodError = core$2.$constructor("ZodError", initializer);
ZodRealError = errors$5.ZodRealError = core$2.$constructor("ZodError", initializer, {
    Parent: Error,
});

"use strict";
var __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(parse$2, "__esModule", { value: true });
var safeDecodeAsync = parse$2.safeDecodeAsync = safeEncodeAsync = parse$2.safeEncodeAsync = safeDecode = parse$2.safeDecode = safeEncode = parse$2.safeEncode = decodeAsync = parse$2.decodeAsync = encodeAsync = parse$2.encodeAsync = decode$2 = parse$2.decode = encode$1 = parse$2.encode = safeParseAsync = parse$2.safeParseAsync = safeParse = parse$2.safeParse = parseAsync = parse$2.parseAsync = parse_1 = parse$2.parse = void 0;
const core$1 = __importStar$1(core$5);
const errors_js_1 = errors$5;
var parse_1 = parse$2.parse = core$1._parse(errors_js_1.ZodRealError);
var parseAsync = parse$2.parseAsync = core$1._parseAsync(errors_js_1.ZodRealError);
var safeParse = parse$2.safeParse = core$1._safeParse(errors_js_1.ZodRealError);
var safeParseAsync = parse$2.safeParseAsync = core$1._safeParseAsync(errors_js_1.ZodRealError);
// Codec functions
var encode$1 = parse$2.encode = core$1._encode(errors_js_1.ZodRealError);
var decode$2 = parse$2.decode = core$1._decode(errors_js_1.ZodRealError);
var encodeAsync = parse$2.encodeAsync = core$1._encodeAsync(errors_js_1.ZodRealError);
var decodeAsync = parse$2.decodeAsync = core$1._decodeAsync(errors_js_1.ZodRealError);
var safeEncode = parse$2.safeEncode = core$1._safeEncode(errors_js_1.ZodRealError);
var safeDecode = parse$2.safeDecode = core$1._safeDecode(errors_js_1.ZodRealError);
var safeEncodeAsync = parse$2.safeEncodeAsync = core$1._safeEncodeAsync(errors_js_1.ZodRealError);
safeDecodeAsync = parse$2.safeDecodeAsync = core$1._safeDecodeAsync(errors_js_1.ZodRealError);

var hasRequiredSchemas;

function requireSchemas () {
	if (hasRequiredSchemas) return schemas$1;
	hasRequiredSchemas = 1;
	(function (exports) {
		"use strict";
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ZodTransform = exports.ZodFile = exports.ZodLiteral = exports.ZodEnum = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodDate = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodBigIntFormat = exports.ZodBigInt = exports.ZodBoolean = exports.ZodNumberFormat = exports.ZodNumber = exports.ZodCustomStringFormat = exports.ZodJWT = exports.ZodE164 = exports.ZodBase64URL = exports.ZodBase64 = exports.ZodCIDRv6 = exports.ZodCIDRv4 = exports.ZodIPv6 = exports.ZodIPv4 = exports.ZodKSUID = exports.ZodXID = exports.ZodULID = exports.ZodCUID2 = exports.ZodCUID = exports.ZodNanoID = exports.ZodEmoji = exports.ZodURL = exports.ZodUUID = exports.ZodGUID = exports.ZodEmail = exports.ZodStringFormat = exports.ZodString = exports._ZodString = exports.ZodType = void 0;
		exports.stringbool = exports.ZodCustom = exports.ZodFunction = exports.ZodPromise = exports.ZodLazy = exports.ZodTemplateLiteral = exports.ZodReadonly = exports.ZodCodec = exports.ZodPipe = exports.ZodNaN = exports.ZodCatch = exports.ZodSuccess = exports.ZodNonOptional = exports.ZodPrefault = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = void 0;
		exports.string = string;
		exports.email = email;
		exports.guid = guid;
		exports.uuid = uuid;
		exports.uuidv4 = uuidv4;
		exports.uuidv6 = uuidv6;
		exports.uuidv7 = uuidv7;
		exports.url = url;
		exports.httpUrl = httpUrl;
		exports.emoji = emoji;
		exports.nanoid = nanoid;
		exports.cuid = cuid;
		exports.cuid2 = cuid2;
		exports.ulid = ulid;
		exports.xid = xid;
		exports.ksuid = ksuid;
		exports.ipv4 = ipv4;
		exports.ipv6 = ipv6;
		exports.cidrv4 = cidrv4;
		exports.cidrv6 = cidrv6;
		exports.base64 = base64;
		exports.base64url = base64url;
		exports.e164 = e164;
		exports.jwt = jwt;
		exports.stringFormat = stringFormat;
		exports.hostname = hostname;
		exports.hex = hex;
		exports.hash = hash;
		exports.number = number;
		exports.int = int;
		exports.float32 = float32;
		exports.float64 = float64;
		exports.int32 = int32;
		exports.uint32 = uint32;
		exports.boolean = boolean;
		exports.bigint = bigint;
		exports.int64 = int64;
		exports.uint64 = uint64;
		exports.symbol = symbol;
		exports.undefined = _undefined;
		exports.null = _null;
		exports.any = any;
		exports.unknown = unknown;
		exports.never = never;
		exports.void = _void;
		exports.date = date;
		exports.array = array;
		exports.keyof = keyof;
		exports.object = object;
		exports.strictObject = strictObject;
		exports.looseObject = looseObject;
		exports.union = union;
		exports.discriminatedUnion = discriminatedUnion;
		exports.intersection = intersection;
		exports.tuple = tuple;
		exports.record = record;
		exports.partialRecord = partialRecord;
		exports.map = map;
		exports.set = set;
		exports.enum = _enum;
		exports.nativeEnum = nativeEnum;
		exports.literal = literal;
		exports.file = file;
		exports.transform = transform;
		exports.optional = optional;
		exports.nullable = nullable;
		exports.nullish = nullish;
		exports._default = _default;
		exports.prefault = prefault;
		exports.nonoptional = nonoptional;
		exports.success = success;
		exports.catch = _catch;
		exports.nan = nan;
		exports.pipe = pipe;
		exports.codec = codec;
		exports.readonly = readonly;
		exports.templateLiteral = templateLiteral;
		exports.lazy = lazy;
		exports.promise = promise;
		exports._function = _function;
		exports.function = _function;
		exports._function = _function;
		exports.function = _function;
		exports.check = check;
		exports.custom = custom;
		exports.refine = refine;
		exports.superRefine = superRefine;
		exports.instanceof = _instanceof;
		exports.json = json;
		exports.preprocess = preprocess;
		const core = __importStar(core$5);
		const index_js_1 = core$5;
		const checks = __importStar(checks$1);
		const iso = __importStar(requireIso());
		const parse = __importStar(parse$2);
		exports.ZodType = core.$constructor("ZodType", (inst, def) => {
		    core.$ZodType.init(inst, def);
		    inst.def = def;
		    inst.type = def.type;
		    Object.defineProperty(inst, "_def", { value: def });
		    // base methods
		    inst.check = (...checks) => {
		        return inst.clone({
		            ...def,
		            checks: [
		                ...(def.checks ?? []),
		                ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch),
		            ],
		        }
		        // { parent: true }
		        );
		    };
		    inst.clone = (def, params) => core.clone(inst, def, params);
		    inst.brand = () => inst;
		    inst.register = ((reg, meta) => {
		        reg.add(inst, meta);
		        return inst;
		    });
		    // parsing
		    inst.parse = (data, params) => parse.parse(inst, data, params, { callee: inst.parse });
		    inst.safeParse = (data, params) => parse.safeParse(inst, data, params);
		    inst.parseAsync = async (data, params) => parse.parseAsync(inst, data, params, { callee: inst.parseAsync });
		    inst.safeParseAsync = async (data, params) => parse.safeParseAsync(inst, data, params);
		    inst.spa = inst.safeParseAsync;
		    // encoding/decoding
		    inst.encode = (data, params) => parse.encode(inst, data, params);
		    inst.decode = (data, params) => parse.decode(inst, data, params);
		    inst.encodeAsync = async (data, params) => parse.encodeAsync(inst, data, params);
		    inst.decodeAsync = async (data, params) => parse.decodeAsync(inst, data, params);
		    inst.safeEncode = (data, params) => parse.safeEncode(inst, data, params);
		    inst.safeDecode = (data, params) => parse.safeDecode(inst, data, params);
		    inst.safeEncodeAsync = async (data, params) => parse.safeEncodeAsync(inst, data, params);
		    inst.safeDecodeAsync = async (data, params) => parse.safeDecodeAsync(inst, data, params);
		    // refinements
		    inst.refine = (check, params) => inst.check(refine(check, params));
		    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
		    inst.overwrite = (fn) => inst.check(checks.overwrite(fn));
		    // wrappers
		    inst.optional = () => optional(inst);
		    inst.nullable = () => nullable(inst);
		    inst.nullish = () => optional(nullable(inst));
		    inst.nonoptional = (params) => nonoptional(inst, params);
		    inst.array = () => array(inst);
		    inst.or = (arg) => union([inst, arg]);
		    inst.and = (arg) => intersection(inst, arg);
		    inst.transform = (tx) => pipe(inst, transform(tx));
		    inst.default = (def) => _default(inst, def);
		    inst.prefault = (def) => prefault(inst, def);
		    // inst.coalesce = (def, params) => coalesce(inst, def, params);
		    inst.catch = (params) => _catch(inst, params);
		    inst.pipe = (target) => pipe(inst, target);
		    inst.readonly = () => readonly(inst);
		    // meta
		    inst.describe = (description) => {
		        const cl = inst.clone();
		        core.globalRegistry.add(cl, { description });
		        return cl;
		    };
		    Object.defineProperty(inst, "description", {
		        get() {
		            return core.globalRegistry.get(inst)?.description;
		        },
		        configurable: true,
		    });
		    inst.meta = (...args) => {
		        if (args.length === 0) {
		            return core.globalRegistry.get(inst);
		        }
		        const cl = inst.clone();
		        core.globalRegistry.add(cl, args[0]);
		        return cl;
		    };
		    // helpers
		    inst.isOptional = () => inst.safeParse(undefined).success;
		    inst.isNullable = () => inst.safeParse(null).success;
		    return inst;
		});
		/** @internal */
		exports._ZodString = core.$constructor("_ZodString", (inst, def) => {
		    core.$ZodString.init(inst, def);
		    exports.ZodType.init(inst, def);
		    const bag = inst._zod.bag;
		    inst.format = bag.format ?? null;
		    inst.minLength = bag.minimum ?? null;
		    inst.maxLength = bag.maximum ?? null;
		    // validations
		    inst.regex = (...args) => inst.check(checks.regex(...args));
		    inst.includes = (...args) => inst.check(checks.includes(...args));
		    inst.startsWith = (...args) => inst.check(checks.startsWith(...args));
		    inst.endsWith = (...args) => inst.check(checks.endsWith(...args));
		    inst.min = (...args) => inst.check(checks.minLength(...args));
		    inst.max = (...args) => inst.check(checks.maxLength(...args));
		    inst.length = (...args) => inst.check(checks.length(...args));
		    inst.nonempty = (...args) => inst.check(checks.minLength(1, ...args));
		    inst.lowercase = (params) => inst.check(checks.lowercase(params));
		    inst.uppercase = (params) => inst.check(checks.uppercase(params));
		    // transforms
		    inst.trim = () => inst.check(checks.trim());
		    inst.normalize = (...args) => inst.check(checks.normalize(...args));
		    inst.toLowerCase = () => inst.check(checks.toLowerCase());
		    inst.toUpperCase = () => inst.check(checks.toUpperCase());
		});
		exports.ZodString = core.$constructor("ZodString", (inst, def) => {
		    core.$ZodString.init(inst, def);
		    exports._ZodString.init(inst, def);
		    inst.email = (params) => inst.check(core._email(exports.ZodEmail, params));
		    inst.url = (params) => inst.check(core._url(exports.ZodURL, params));
		    inst.jwt = (params) => inst.check(core._jwt(exports.ZodJWT, params));
		    inst.emoji = (params) => inst.check(core._emoji(exports.ZodEmoji, params));
		    inst.guid = (params) => inst.check(core._guid(exports.ZodGUID, params));
		    inst.uuid = (params) => inst.check(core._uuid(exports.ZodUUID, params));
		    inst.uuidv4 = (params) => inst.check(core._uuidv4(exports.ZodUUID, params));
		    inst.uuidv6 = (params) => inst.check(core._uuidv6(exports.ZodUUID, params));
		    inst.uuidv7 = (params) => inst.check(core._uuidv7(exports.ZodUUID, params));
		    inst.nanoid = (params) => inst.check(core._nanoid(exports.ZodNanoID, params));
		    inst.guid = (params) => inst.check(core._guid(exports.ZodGUID, params));
		    inst.cuid = (params) => inst.check(core._cuid(exports.ZodCUID, params));
		    inst.cuid2 = (params) => inst.check(core._cuid2(exports.ZodCUID2, params));
		    inst.ulid = (params) => inst.check(core._ulid(exports.ZodULID, params));
		    inst.base64 = (params) => inst.check(core._base64(exports.ZodBase64, params));
		    inst.base64url = (params) => inst.check(core._base64url(exports.ZodBase64URL, params));
		    inst.xid = (params) => inst.check(core._xid(exports.ZodXID, params));
		    inst.ksuid = (params) => inst.check(core._ksuid(exports.ZodKSUID, params));
		    inst.ipv4 = (params) => inst.check(core._ipv4(exports.ZodIPv4, params));
		    inst.ipv6 = (params) => inst.check(core._ipv6(exports.ZodIPv6, params));
		    inst.cidrv4 = (params) => inst.check(core._cidrv4(exports.ZodCIDRv4, params));
		    inst.cidrv6 = (params) => inst.check(core._cidrv6(exports.ZodCIDRv6, params));
		    inst.e164 = (params) => inst.check(core._e164(exports.ZodE164, params));
		    // iso
		    inst.datetime = (params) => inst.check(iso.datetime(params));
		    inst.date = (params) => inst.check(iso.date(params));
		    inst.time = (params) => inst.check(iso.time(params));
		    inst.duration = (params) => inst.check(iso.duration(params));
		});
		function string(params) {
		    return core._string(exports.ZodString, params);
		}
		exports.ZodStringFormat = core.$constructor("ZodStringFormat", (inst, def) => {
		    core.$ZodStringFormat.init(inst, def);
		    exports._ZodString.init(inst, def);
		});
		exports.ZodEmail = core.$constructor("ZodEmail", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodEmail.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function email(params) {
		    return core._email(exports.ZodEmail, params);
		}
		exports.ZodGUID = core.$constructor("ZodGUID", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodGUID.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function guid(params) {
		    return core._guid(exports.ZodGUID, params);
		}
		exports.ZodUUID = core.$constructor("ZodUUID", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodUUID.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function uuid(params) {
		    return core._uuid(exports.ZodUUID, params);
		}
		function uuidv4(params) {
		    return core._uuidv4(exports.ZodUUID, params);
		}
		// ZodUUIDv6
		function uuidv6(params) {
		    return core._uuidv6(exports.ZodUUID, params);
		}
		// ZodUUIDv7
		function uuidv7(params) {
		    return core._uuidv7(exports.ZodUUID, params);
		}
		exports.ZodURL = core.$constructor("ZodURL", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodURL.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function url(params) {
		    return core._url(exports.ZodURL, params);
		}
		function httpUrl(params) {
		    return core._url(exports.ZodURL, {
		        protocol: /^https?$/,
		        hostname: core.regexes.domain,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodEmoji = core.$constructor("ZodEmoji", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodEmoji.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function emoji(params) {
		    return core._emoji(exports.ZodEmoji, params);
		}
		exports.ZodNanoID = core.$constructor("ZodNanoID", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodNanoID.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function nanoid(params) {
		    return core._nanoid(exports.ZodNanoID, params);
		}
		exports.ZodCUID = core.$constructor("ZodCUID", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodCUID.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function cuid(params) {
		    return core._cuid(exports.ZodCUID, params);
		}
		exports.ZodCUID2 = core.$constructor("ZodCUID2", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodCUID2.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function cuid2(params) {
		    return core._cuid2(exports.ZodCUID2, params);
		}
		exports.ZodULID = core.$constructor("ZodULID", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodULID.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function ulid(params) {
		    return core._ulid(exports.ZodULID, params);
		}
		exports.ZodXID = core.$constructor("ZodXID", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodXID.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function xid(params) {
		    return core._xid(exports.ZodXID, params);
		}
		exports.ZodKSUID = core.$constructor("ZodKSUID", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodKSUID.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function ksuid(params) {
		    return core._ksuid(exports.ZodKSUID, params);
		}
		exports.ZodIPv4 = core.$constructor("ZodIPv4", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodIPv4.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function ipv4(params) {
		    return core._ipv4(exports.ZodIPv4, params);
		}
		exports.ZodIPv6 = core.$constructor("ZodIPv6", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodIPv6.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function ipv6(params) {
		    return core._ipv6(exports.ZodIPv6, params);
		}
		exports.ZodCIDRv4 = core.$constructor("ZodCIDRv4", (inst, def) => {
		    core.$ZodCIDRv4.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function cidrv4(params) {
		    return core._cidrv4(exports.ZodCIDRv4, params);
		}
		exports.ZodCIDRv6 = core.$constructor("ZodCIDRv6", (inst, def) => {
		    core.$ZodCIDRv6.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function cidrv6(params) {
		    return core._cidrv6(exports.ZodCIDRv6, params);
		}
		exports.ZodBase64 = core.$constructor("ZodBase64", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodBase64.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function base64(params) {
		    return core._base64(exports.ZodBase64, params);
		}
		exports.ZodBase64URL = core.$constructor("ZodBase64URL", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodBase64URL.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function base64url(params) {
		    return core._base64url(exports.ZodBase64URL, params);
		}
		exports.ZodE164 = core.$constructor("ZodE164", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodE164.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function e164(params) {
		    return core._e164(exports.ZodE164, params);
		}
		exports.ZodJWT = core.$constructor("ZodJWT", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodJWT.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function jwt(params) {
		    return core._jwt(exports.ZodJWT, params);
		}
		exports.ZodCustomStringFormat = core.$constructor("ZodCustomStringFormat", (inst, def) => {
		    // ZodStringFormat.init(inst, def);
		    core.$ZodCustomStringFormat.init(inst, def);
		    exports.ZodStringFormat.init(inst, def);
		});
		function stringFormat(format, fnOrRegex, _params = {}) {
		    return core._stringFormat(exports.ZodCustomStringFormat, format, fnOrRegex, _params);
		}
		function hostname(_params) {
		    return core._stringFormat(exports.ZodCustomStringFormat, "hostname", core.regexes.hostname, _params);
		}
		function hex(_params) {
		    return core._stringFormat(exports.ZodCustomStringFormat, "hex", core.regexes.hex, _params);
		}
		function hash(alg, params) {
		    const enc = params?.enc ?? "hex";
		    const format = `${alg}_${enc}`;
		    const regex = core.regexes[format];
		    if (!regex)
		        throw new Error(`Unrecognized hash format: ${format}`);
		    return core._stringFormat(exports.ZodCustomStringFormat, format, regex, params);
		}
		exports.ZodNumber = core.$constructor("ZodNumber", (inst, def) => {
		    core.$ZodNumber.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.gt = (value, params) => inst.check(checks.gt(value, params));
		    inst.gte = (value, params) => inst.check(checks.gte(value, params));
		    inst.min = (value, params) => inst.check(checks.gte(value, params));
		    inst.lt = (value, params) => inst.check(checks.lt(value, params));
		    inst.lte = (value, params) => inst.check(checks.lte(value, params));
		    inst.max = (value, params) => inst.check(checks.lte(value, params));
		    inst.int = (params) => inst.check(int(params));
		    inst.safe = (params) => inst.check(int(params));
		    inst.positive = (params) => inst.check(checks.gt(0, params));
		    inst.nonnegative = (params) => inst.check(checks.gte(0, params));
		    inst.negative = (params) => inst.check(checks.lt(0, params));
		    inst.nonpositive = (params) => inst.check(checks.lte(0, params));
		    inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));
		    inst.step = (value, params) => inst.check(checks.multipleOf(value, params));
		    // inst.finite = (params) => inst.check(core.finite(params));
		    inst.finite = () => inst;
		    const bag = inst._zod.bag;
		    inst.minValue =
		        Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
		    inst.maxValue =
		        Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
		    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
		    inst.isFinite = true;
		    inst.format = bag.format ?? null;
		});
		function number(params) {
		    return core._number(exports.ZodNumber, params);
		}
		exports.ZodNumberFormat = core.$constructor("ZodNumberFormat", (inst, def) => {
		    core.$ZodNumberFormat.init(inst, def);
		    exports.ZodNumber.init(inst, def);
		});
		function int(params) {
		    return core._int(exports.ZodNumberFormat, params);
		}
		function float32(params) {
		    return core._float32(exports.ZodNumberFormat, params);
		}
		function float64(params) {
		    return core._float64(exports.ZodNumberFormat, params);
		}
		function int32(params) {
		    return core._int32(exports.ZodNumberFormat, params);
		}
		function uint32(params) {
		    return core._uint32(exports.ZodNumberFormat, params);
		}
		exports.ZodBoolean = core.$constructor("ZodBoolean", (inst, def) => {
		    core.$ZodBoolean.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function boolean(params) {
		    return core._boolean(exports.ZodBoolean, params);
		}
		exports.ZodBigInt = core.$constructor("ZodBigInt", (inst, def) => {
		    core.$ZodBigInt.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.gte = (value, params) => inst.check(checks.gte(value, params));
		    inst.min = (value, params) => inst.check(checks.gte(value, params));
		    inst.gt = (value, params) => inst.check(checks.gt(value, params));
		    inst.gte = (value, params) => inst.check(checks.gte(value, params));
		    inst.min = (value, params) => inst.check(checks.gte(value, params));
		    inst.lt = (value, params) => inst.check(checks.lt(value, params));
		    inst.lte = (value, params) => inst.check(checks.lte(value, params));
		    inst.max = (value, params) => inst.check(checks.lte(value, params));
		    inst.positive = (params) => inst.check(checks.gt(BigInt(0), params));
		    inst.negative = (params) => inst.check(checks.lt(BigInt(0), params));
		    inst.nonpositive = (params) => inst.check(checks.lte(BigInt(0), params));
		    inst.nonnegative = (params) => inst.check(checks.gte(BigInt(0), params));
		    inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));
		    const bag = inst._zod.bag;
		    inst.minValue = bag.minimum ?? null;
		    inst.maxValue = bag.maximum ?? null;
		    inst.format = bag.format ?? null;
		});
		function bigint(params) {
		    return core._bigint(exports.ZodBigInt, params);
		}
		exports.ZodBigIntFormat = core.$constructor("ZodBigIntFormat", (inst, def) => {
		    core.$ZodBigIntFormat.init(inst, def);
		    exports.ZodBigInt.init(inst, def);
		});
		// int64
		function int64(params) {
		    return core._int64(exports.ZodBigIntFormat, params);
		}
		// uint64
		function uint64(params) {
		    return core._uint64(exports.ZodBigIntFormat, params);
		}
		exports.ZodSymbol = core.$constructor("ZodSymbol", (inst, def) => {
		    core.$ZodSymbol.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function symbol(params) {
		    return core._symbol(exports.ZodSymbol, params);
		}
		exports.ZodUndefined = core.$constructor("ZodUndefined", (inst, def) => {
		    core.$ZodUndefined.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function _undefined(params) {
		    return core._undefined(exports.ZodUndefined, params);
		}
		exports.ZodNull = core.$constructor("ZodNull", (inst, def) => {
		    core.$ZodNull.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function _null(params) {
		    return core._null(exports.ZodNull, params);
		}
		exports.ZodAny = core.$constructor("ZodAny", (inst, def) => {
		    core.$ZodAny.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function any() {
		    return core._any(exports.ZodAny);
		}
		exports.ZodUnknown = core.$constructor("ZodUnknown", (inst, def) => {
		    core.$ZodUnknown.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function unknown() {
		    return core._unknown(exports.ZodUnknown);
		}
		exports.ZodNever = core.$constructor("ZodNever", (inst, def) => {
		    core.$ZodNever.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function never(params) {
		    return core._never(exports.ZodNever, params);
		}
		exports.ZodVoid = core.$constructor("ZodVoid", (inst, def) => {
		    core.$ZodVoid.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function _void(params) {
		    return core._void(exports.ZodVoid, params);
		}
		exports.ZodDate = core.$constructor("ZodDate", (inst, def) => {
		    core.$ZodDate.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.min = (value, params) => inst.check(checks.gte(value, params));
		    inst.max = (value, params) => inst.check(checks.lte(value, params));
		    const c = inst._zod.bag;
		    inst.minDate = c.minimum ? new Date(c.minimum) : null;
		    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
		});
		function date(params) {
		    return core._date(exports.ZodDate, params);
		}
		exports.ZodArray = core.$constructor("ZodArray", (inst, def) => {
		    core.$ZodArray.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.element = def.element;
		    inst.min = (minLength, params) => inst.check(checks.minLength(minLength, params));
		    inst.nonempty = (params) => inst.check(checks.minLength(1, params));
		    inst.max = (maxLength, params) => inst.check(checks.maxLength(maxLength, params));
		    inst.length = (len, params) => inst.check(checks.length(len, params));
		    inst.unwrap = () => inst.element;
		});
		function array(element, params) {
		    return core._array(exports.ZodArray, element, params);
		}
		// .keyof
		function keyof(schema) {
		    const shape = schema._zod.def.shape;
		    return _enum(Object.keys(shape));
		}
		exports.ZodObject = core.$constructor("ZodObject", (inst, def) => {
		    core.$ZodObjectJIT.init(inst, def);
		    exports.ZodType.init(inst, def);
		    index_js_1.util.defineLazy(inst, "shape", () => def.shape);
		    inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
		    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall });
		    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
		    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
		    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
		    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
		    inst.extend = (incoming) => {
		        return index_js_1.util.extend(inst, incoming);
		    };
		    inst.safeExtend = (incoming) => {
		        return index_js_1.util.safeExtend(inst, incoming);
		    };
		    inst.merge = (other) => index_js_1.util.merge(inst, other);
		    inst.pick = (mask) => index_js_1.util.pick(inst, mask);
		    inst.omit = (mask) => index_js_1.util.omit(inst, mask);
		    inst.partial = (...args) => index_js_1.util.partial(exports.ZodOptional, inst, args[0]);
		    inst.required = (...args) => index_js_1.util.required(exports.ZodNonOptional, inst, args[0]);
		});
		function object(shape, params) {
		    const def = {
		        type: "object",
		        get shape() {
		            index_js_1.util.assignProp(this, "shape", shape ? index_js_1.util.objectClone(shape) : {});
		            return this.shape;
		        },
		        ...index_js_1.util.normalizeParams(params),
		    };
		    return new exports.ZodObject(def);
		}
		// strictObject
		function strictObject(shape, params) {
		    return new exports.ZodObject({
		        type: "object",
		        get shape() {
		            index_js_1.util.assignProp(this, "shape", index_js_1.util.objectClone(shape));
		            return this.shape;
		        },
		        catchall: never(),
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		// looseObject
		function looseObject(shape, params) {
		    return new exports.ZodObject({
		        type: "object",
		        get shape() {
		            index_js_1.util.assignProp(this, "shape", index_js_1.util.objectClone(shape));
		            return this.shape;
		        },
		        catchall: unknown(),
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodUnion = core.$constructor("ZodUnion", (inst, def) => {
		    core.$ZodUnion.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.options = def.options;
		});
		function union(options, params) {
		    return new exports.ZodUnion({
		        type: "union",
		        options: options,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodDiscriminatedUnion = core.$constructor("ZodDiscriminatedUnion", (inst, def) => {
		    exports.ZodUnion.init(inst, def);
		    core.$ZodDiscriminatedUnion.init(inst, def);
		});
		function discriminatedUnion(discriminator, options, params) {
		    // const [options, params] = args;
		    return new exports.ZodDiscriminatedUnion({
		        type: "union",
		        options,
		        discriminator,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodIntersection = core.$constructor("ZodIntersection", (inst, def) => {
		    core.$ZodIntersection.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function intersection(left, right) {
		    return new exports.ZodIntersection({
		        type: "intersection",
		        left: left,
		        right: right,
		    });
		}
		exports.ZodTuple = core.$constructor("ZodTuple", (inst, def) => {
		    core.$ZodTuple.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.rest = (rest) => inst.clone({
		        ...inst._zod.def,
		        rest: rest,
		    });
		});
		function tuple(items, _paramsOrRest, _params) {
		    const hasRest = _paramsOrRest instanceof core.$ZodType;
		    const params = hasRest ? _params : _paramsOrRest;
		    const rest = hasRest ? _paramsOrRest : null;
		    return new exports.ZodTuple({
		        type: "tuple",
		        items: items,
		        rest,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodRecord = core.$constructor("ZodRecord", (inst, def) => {
		    core.$ZodRecord.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.keyType = def.keyType;
		    inst.valueType = def.valueType;
		});
		function record(keyType, valueType, params) {
		    return new exports.ZodRecord({
		        type: "record",
		        keyType,
		        valueType: valueType,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		// type alksjf = core.output<core.$ZodRecordKey>;
		function partialRecord(keyType, valueType, params) {
		    const k = core.clone(keyType);
		    k._zod.values = undefined;
		    return new exports.ZodRecord({
		        type: "record",
		        keyType: k,
		        valueType: valueType,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodMap = core.$constructor("ZodMap", (inst, def) => {
		    core.$ZodMap.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.keyType = def.keyType;
		    inst.valueType = def.valueType;
		});
		function map(keyType, valueType, params) {
		    return new exports.ZodMap({
		        type: "map",
		        keyType: keyType,
		        valueType: valueType,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodSet = core.$constructor("ZodSet", (inst, def) => {
		    core.$ZodSet.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.min = (...args) => inst.check(core._minSize(...args));
		    inst.nonempty = (params) => inst.check(core._minSize(1, params));
		    inst.max = (...args) => inst.check(core._maxSize(...args));
		    inst.size = (...args) => inst.check(core._size(...args));
		});
		function set(valueType, params) {
		    return new exports.ZodSet({
		        type: "set",
		        valueType: valueType,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodEnum = core.$constructor("ZodEnum", (inst, def) => {
		    core.$ZodEnum.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.enum = def.entries;
		    inst.options = Object.values(def.entries);
		    const keys = new Set(Object.keys(def.entries));
		    inst.extract = (values, params) => {
		        const newEntries = {};
		        for (const value of values) {
		            if (keys.has(value)) {
		                newEntries[value] = def.entries[value];
		            }
		            else
		                throw new Error(`Key ${value} not found in enum`);
		        }
		        return new exports.ZodEnum({
		            ...def,
		            checks: [],
		            ...index_js_1.util.normalizeParams(params),
		            entries: newEntries,
		        });
		    };
		    inst.exclude = (values, params) => {
		        const newEntries = { ...def.entries };
		        for (const value of values) {
		            if (keys.has(value)) {
		                delete newEntries[value];
		            }
		            else
		                throw new Error(`Key ${value} not found in enum`);
		        }
		        return new exports.ZodEnum({
		            ...def,
		            checks: [],
		            ...index_js_1.util.normalizeParams(params),
		            entries: newEntries,
		        });
		    };
		});
		function _enum(values, params) {
		    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
		    return new exports.ZodEnum({
		        type: "enum",
		        entries,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
		 *
		 * ```ts
		 * enum Colors { red, green, blue }
		 * z.enum(Colors);
		 * ```
		 */
		function nativeEnum(entries, params) {
		    return new exports.ZodEnum({
		        type: "enum",
		        entries,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodLiteral = core.$constructor("ZodLiteral", (inst, def) => {
		    core.$ZodLiteral.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.values = new Set(def.values);
		    Object.defineProperty(inst, "value", {
		        get() {
		            if (def.values.length > 1) {
		                throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
		            }
		            return def.values[0];
		        },
		    });
		});
		function literal(value, params) {
		    return new exports.ZodLiteral({
		        type: "literal",
		        values: Array.isArray(value) ? value : [value],
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodFile = core.$constructor("ZodFile", (inst, def) => {
		    core.$ZodFile.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.min = (size, params) => inst.check(core._minSize(size, params));
		    inst.max = (size, params) => inst.check(core._maxSize(size, params));
		    inst.mime = (types, params) => inst.check(core._mime(Array.isArray(types) ? types : [types], params));
		});
		function file(params) {
		    return core._file(exports.ZodFile, params);
		}
		exports.ZodTransform = core.$constructor("ZodTransform", (inst, def) => {
		    core.$ZodTransform.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst._zod.parse = (payload, _ctx) => {
		        if (_ctx.direction === "backward") {
		            throw new core.$ZodEncodeError(inst.constructor.name);
		        }
		        payload.addIssue = (issue) => {
		            if (typeof issue === "string") {
		                payload.issues.push(index_js_1.util.issue(issue, payload.value, def));
		            }
		            else {
		                // for Zod 3 backwards compatibility
		                const _issue = issue;
		                if (_issue.fatal)
		                    _issue.continue = false;
		                _issue.code ?? (_issue.code = "custom");
		                _issue.input ?? (_issue.input = payload.value);
		                _issue.inst ?? (_issue.inst = inst);
		                // _issue.continue ??= true;
		                payload.issues.push(index_js_1.util.issue(_issue));
		            }
		        };
		        const output = def.transform(payload.value, payload);
		        if (output instanceof Promise) {
		            return output.then((output) => {
		                payload.value = output;
		                return payload;
		            });
		        }
		        payload.value = output;
		        return payload;
		    };
		});
		function transform(fn) {
		    return new exports.ZodTransform({
		        type: "transform",
		        transform: fn,
		    });
		}
		exports.ZodOptional = core.$constructor("ZodOptional", (inst, def) => {
		    core.$ZodOptional.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.innerType;
		});
		function optional(innerType) {
		    return new exports.ZodOptional({
		        type: "optional",
		        innerType: innerType,
		    });
		}
		exports.ZodNullable = core.$constructor("ZodNullable", (inst, def) => {
		    core.$ZodNullable.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.innerType;
		});
		function nullable(innerType) {
		    return new exports.ZodNullable({
		        type: "nullable",
		        innerType: innerType,
		    });
		}
		// nullish
		function nullish(innerType) {
		    return optional(nullable(innerType));
		}
		exports.ZodDefault = core.$constructor("ZodDefault", (inst, def) => {
		    core.$ZodDefault.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.innerType;
		    inst.removeDefault = inst.unwrap;
		});
		function _default(innerType, defaultValue) {
		    return new exports.ZodDefault({
		        type: "default",
		        innerType: innerType,
		        get defaultValue() {
		            return typeof defaultValue === "function" ? defaultValue() : index_js_1.util.shallowClone(defaultValue);
		        },
		    });
		}
		exports.ZodPrefault = core.$constructor("ZodPrefault", (inst, def) => {
		    core.$ZodPrefault.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.innerType;
		});
		function prefault(innerType, defaultValue) {
		    return new exports.ZodPrefault({
		        type: "prefault",
		        innerType: innerType,
		        get defaultValue() {
		            return typeof defaultValue === "function" ? defaultValue() : index_js_1.util.shallowClone(defaultValue);
		        },
		    });
		}
		exports.ZodNonOptional = core.$constructor("ZodNonOptional", (inst, def) => {
		    core.$ZodNonOptional.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.innerType;
		});
		function nonoptional(innerType, params) {
		    return new exports.ZodNonOptional({
		        type: "nonoptional",
		        innerType: innerType,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodSuccess = core.$constructor("ZodSuccess", (inst, def) => {
		    core.$ZodSuccess.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.innerType;
		});
		function success(innerType) {
		    return new exports.ZodSuccess({
		        type: "success",
		        innerType: innerType,
		    });
		}
		exports.ZodCatch = core.$constructor("ZodCatch", (inst, def) => {
		    core.$ZodCatch.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.innerType;
		    inst.removeCatch = inst.unwrap;
		});
		function _catch(innerType, catchValue) {
		    return new exports.ZodCatch({
		        type: "catch",
		        innerType: innerType,
		        catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue),
		    });
		}
		exports.ZodNaN = core.$constructor("ZodNaN", (inst, def) => {
		    core.$ZodNaN.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function nan(params) {
		    return core._nan(exports.ZodNaN, params);
		}
		exports.ZodPipe = core.$constructor("ZodPipe", (inst, def) => {
		    core.$ZodPipe.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.in = def.in;
		    inst.out = def.out;
		});
		function pipe(in_, out) {
		    return new exports.ZodPipe({
		        type: "pipe",
		        in: in_,
		        out: out,
		        // ...util.normalizeParams(params),
		    });
		}
		exports.ZodCodec = core.$constructor("ZodCodec", (inst, def) => {
		    exports.ZodPipe.init(inst, def);
		    core.$ZodCodec.init(inst, def);
		});
		function codec(in_, out, params) {
		    return new exports.ZodCodec({
		        type: "pipe",
		        in: in_,
		        out: out,
		        transform: params.decode,
		        reverseTransform: params.encode,
		    });
		}
		exports.ZodReadonly = core.$constructor("ZodReadonly", (inst, def) => {
		    core.$ZodReadonly.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.innerType;
		});
		function readonly(innerType) {
		    return new exports.ZodReadonly({
		        type: "readonly",
		        innerType: innerType,
		    });
		}
		exports.ZodTemplateLiteral = core.$constructor("ZodTemplateLiteral", (inst, def) => {
		    core.$ZodTemplateLiteral.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function templateLiteral(parts, params) {
		    return new exports.ZodTemplateLiteral({
		        type: "template_literal",
		        parts,
		        ...index_js_1.util.normalizeParams(params),
		    });
		}
		exports.ZodLazy = core.$constructor("ZodLazy", (inst, def) => {
		    core.$ZodLazy.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.getter();
		});
		function lazy(getter) {
		    return new exports.ZodLazy({
		        type: "lazy",
		        getter: getter,
		    });
		}
		exports.ZodPromise = core.$constructor("ZodPromise", (inst, def) => {
		    core.$ZodPromise.init(inst, def);
		    exports.ZodType.init(inst, def);
		    inst.unwrap = () => inst._zod.def.innerType;
		});
		function promise(innerType) {
		    return new exports.ZodPromise({
		        type: "promise",
		        innerType: innerType,
		    });
		}
		exports.ZodFunction = core.$constructor("ZodFunction", (inst, def) => {
		    core.$ZodFunction.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		function _function(params) {
		    return new exports.ZodFunction({
		        type: "function",
		        input: Array.isArray(params?.input) ? tuple(params?.input) : (params?.input ?? array(unknown())),
		        output: params?.output ?? unknown(),
		    });
		}
		exports.ZodCustom = core.$constructor("ZodCustom", (inst, def) => {
		    core.$ZodCustom.init(inst, def);
		    exports.ZodType.init(inst, def);
		});
		// custom checks
		function check(fn) {
		    const ch = new core.$ZodCheck({
		        check: "custom",
		        // ...util.normalizeParams(params),
		    });
		    ch._zod.check = fn;
		    return ch;
		}
		function custom(fn, _params) {
		    return core._custom(exports.ZodCustom, fn ?? (() => true), _params);
		}
		function refine(fn, _params = {}) {
		    return core._refine(exports.ZodCustom, fn, _params);
		}
		// superRefine
		function superRefine(fn) {
		    return core._superRefine(fn);
		}
		function _instanceof(cls, params = {
		    error: `Input not instance of ${cls.name}`,
		}) {
		    const inst = new exports.ZodCustom({
		        type: "custom",
		        check: "custom",
		        fn: (data) => data instanceof cls,
		        abort: true,
		        ...index_js_1.util.normalizeParams(params),
		    });
		    inst._zod.bag.Class = cls;
		    return inst;
		}
		// stringbool
		const stringbool = (...args) => core._stringbool({
		    Codec: exports.ZodCodec,
		    Boolean: exports.ZodBoolean,
		    String: exports.ZodString,
		}, ...args);
		exports.stringbool = stringbool;
		function json(params) {
		    const jsonSchema = lazy(() => {
		        return union([string(params), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);
		    });
		    return jsonSchema;
		}
		// preprocess
		// /** @deprecated Use `z.pipe()` and `z.transform()` instead. */
		function preprocess(fn, schema) {
		    return pipe(transform(fn), schema);
		} 
	} (schemas$1));
	return schemas$1;
}

var compat$1 = {};

(function (exports) {
	"use strict";
	// Zod 3 compat layer
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ZodFirstPartyTypeKind = exports.config = exports.$brand = exports.ZodIssueCode = void 0;
	exports.setErrorMap = setErrorMap;
	exports.getErrorMap = getErrorMap;
	const core = __importStar(core$5);
	/** @deprecated Use the raw string literal codes instead, e.g. "invalid_type". */
	exports.ZodIssueCode = {
	    invalid_type: "invalid_type",
	    too_big: "too_big",
	    too_small: "too_small",
	    invalid_format: "invalid_format",
	    not_multiple_of: "not_multiple_of",
	    unrecognized_keys: "unrecognized_keys",
	    invalid_union: "invalid_union",
	    invalid_key: "invalid_key",
	    invalid_element: "invalid_element",
	    invalid_value: "invalid_value",
	    custom: "custom",
	};
	var index_js_1 = core$5;
	Object.defineProperty(exports, "$brand", { enumerable: true, get: function () { return index_js_1.$brand; } });
	Object.defineProperty(exports, "config", { enumerable: true, get: function () { return index_js_1.config; } });
	/** @deprecated Use `z.config(params)` instead. */
	function setErrorMap(map) {
	    core.config({
	        customError: map,
	    });
	}
	/** @deprecated Use `z.config()` instead. */
	function getErrorMap() {
	    return core.config().customError;
	}
	/** @deprecated Do not use. Stub definition, only included for zod-to-json-schema compatibility. */
	var ZodFirstPartyTypeKind;
	(function (ZodFirstPartyTypeKind) {
	})(ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {})); 
} (compat$1));

var compat = /*@__PURE__*/getDefaultExportFromCjs(compat$1);

var coerce = {};

"use strict";
var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(coerce, "__esModule", { value: true });
var string_1 = coerce.string = string;
var number_1 = coerce.number = number;
var boolean_1 = coerce.boolean = boolean;
var bigint_1 = coerce.bigint = bigint;
var date_1 = coerce.date = date;
const core = __importStar(core$5);
const schemas = __importStar(requireSchemas());
function string(params) {
    return core._coercedString(schemas.ZodString, params);
}
function number(params) {
    return core._coercedNumber(schemas.ZodNumber, params);
}
function boolean(params) {
    return core._coercedBoolean(schemas.ZodBoolean, params);
}
function bigint(params) {
    return core._coercedBigint(schemas.ZodBigInt, params);
}
function date(params) {
    return core._coercedDate(schemas.ZodDate, params);
}

(function (exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.coerce = exports.iso = exports.ZodISODuration = exports.ZodISOTime = exports.ZodISODate = exports.ZodISODateTime = exports.locales = exports.NEVER = exports.util = exports.TimePrecision = exports.toJSONSchema = exports.flattenError = exports.formatError = exports.prettifyError = exports.treeifyError = exports.regexes = exports.clone = exports.$brand = exports.$input = exports.$output = exports.config = exports.registry = exports.globalRegistry = exports.core = void 0;
	exports.core = __importStar(core$5);
	__exportStar(requireSchemas(), exports);
	__exportStar(checks$1, exports);
	__exportStar(errors$5, exports);
	__exportStar(parse$2, exports);
	__exportStar(compat$1, exports);
	// zod-specified
	const index_js_1 = core$5;
	const en_js_1 = __importDefault(en$1);
	(0, index_js_1.config)((0, en_js_1.default)());
	var index_js_2 = core$5;
	Object.defineProperty(exports, "globalRegistry", { enumerable: true, get: function () { return index_js_2.globalRegistry; } });
	Object.defineProperty(exports, "registry", { enumerable: true, get: function () { return index_js_2.registry; } });
	Object.defineProperty(exports, "config", { enumerable: true, get: function () { return index_js_2.config; } });
	Object.defineProperty(exports, "$output", { enumerable: true, get: function () { return index_js_2.$output; } });
	Object.defineProperty(exports, "$input", { enumerable: true, get: function () { return index_js_2.$input; } });
	Object.defineProperty(exports, "$brand", { enumerable: true, get: function () { return index_js_2.$brand; } });
	Object.defineProperty(exports, "clone", { enumerable: true, get: function () { return index_js_2.clone; } });
	Object.defineProperty(exports, "regexes", { enumerable: true, get: function () { return index_js_2.regexes; } });
	Object.defineProperty(exports, "treeifyError", { enumerable: true, get: function () { return index_js_2.treeifyError; } });
	Object.defineProperty(exports, "prettifyError", { enumerable: true, get: function () { return index_js_2.prettifyError; } });
	Object.defineProperty(exports, "formatError", { enumerable: true, get: function () { return index_js_2.formatError; } });
	Object.defineProperty(exports, "flattenError", { enumerable: true, get: function () { return index_js_2.flattenError; } });
	Object.defineProperty(exports, "toJSONSchema", { enumerable: true, get: function () { return index_js_2.toJSONSchema; } });
	Object.defineProperty(exports, "TimePrecision", { enumerable: true, get: function () { return index_js_2.TimePrecision; } });
	Object.defineProperty(exports, "util", { enumerable: true, get: function () { return index_js_2.util; } });
	Object.defineProperty(exports, "NEVER", { enumerable: true, get: function () { return index_js_2.NEVER; } });
	exports.locales = __importStar(locales);
	// iso
	// must be exported from top-level
	// https://github.com/colinhacks/zod/issues/4491
	var iso_js_1 = requireIso();
	Object.defineProperty(exports, "ZodISODateTime", { enumerable: true, get: function () { return iso_js_1.ZodISODateTime; } });
	Object.defineProperty(exports, "ZodISODate", { enumerable: true, get: function () { return iso_js_1.ZodISODate; } });
	Object.defineProperty(exports, "ZodISOTime", { enumerable: true, get: function () { return iso_js_1.ZodISOTime; } });
	Object.defineProperty(exports, "ZodISODuration", { enumerable: true, get: function () { return iso_js_1.ZodISODuration; } });
	exports.iso = __importStar(requireIso());
	exports.coerce = __importStar(coerce); 
} (external$1));

var external = /*@__PURE__*/getDefaultExportFromCjs(external$1);

(function (exports) {
	"use strict";
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.z = void 0;
	const z = __importStar(external$1);
	exports.z = z;
	__exportStar(external$1, exports);
	exports.default = z; 
} (zod));

var index$2 = /*@__PURE__*/getDefaultExportFromCjs(zod);

var LanguageAliases$1 = {};

"use strict";

Object.defineProperty(LanguageAliases$1, "__esModule", {
  value: true
});
var createLanguageAliasesMap_1 = LanguageAliases$1.createLanguageAliasesMap = LanguageAliases_2 = LanguageAliases$1.LanguageAliases = void 0;
const createLanguageAliasesMap = languages => {
  const complexLanguages = languages.filter(language => language.includes('-'));
  // Build languages map
  const languagesMap = {};
  for (const language of complexLanguages) {
    const simpleLanguage = language.split('-')[0];
    if (!(simpleLanguage in languagesMap)) {
      languagesMap[simpleLanguage] = [language];
      continue;
    }
    languagesMap[simpleLanguage].push(language);
  }
  return languagesMap;
};
createLanguageAliasesMap_1 = LanguageAliases$1.createLanguageAliasesMap = createLanguageAliasesMap;
class LanguageAliases {
  constructor(languagesList, options = {}) {
    this.languagesList = languagesList;
    this.options = options;
    // Build map
    const languagesMap = createLanguageAliasesMap(languagesList);
    this.languagesMaps = {
      normal: languagesMap,
      reverse: Object.fromEntries(Object.entries(languagesMap).map(([simpleLanguage, aliases]) => aliases.map(alias => [alias, simpleLanguage])).flat())
    };
    this.simpleLanguages = new Set(languagesList);
  }
  getAll() {
    var _a;
    return Array.from(new Set([...this.languagesList, ...Object.keys(this.languagesMaps.normal), ...Object.keys((_a = this.options.map) !== null && _a !== void 0 ? _a : {})]));
  }
  get(language) {
    var _a, _b;
    const mappedLanguage = this.getMappedLanguage(language);
    if (mappedLanguage) return mappedLanguage;
    // Return mapped language
    const languageAliases = this.languagesMaps.normal[language];
    // Check if key is exists
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (languageAliases) return (_a = this.getMappedLanguage(languageAliases[0])) !== null && _a !== void 0 ? _a : languageAliases[0];
    // Return language in list
    if (this.simpleLanguages.has(language)) return (_b = this.getMappedLanguage(language)) !== null && _b !== void 0 ? _b : language;
    return null;
  }
  getMappedLanguage(language) {
    const {
      map = {}
    } = this.options;
    // Return mapped language
    return language in map ? map[language] : null;
  }
}
var LanguageAliases_2 = LanguageAliases$1.LanguageAliases = LanguageAliases;

"use strict";

Object.defineProperty(MicrosoftTranslator$1, "__esModule", {
  value: true
});
var MicrosoftTranslator_2 = MicrosoftTranslator$1.MicrosoftTranslator = void 0;
var _zod$6 = zod;
var _LanguageAliases$1 = LanguageAliases$1;
var _BaseTranslator$4 = BaseTranslator$1;
var __awaiter$7 = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const ResponseScheme = _zod$6.z.object({
  translations: _zod$6.z.object({
    text: _zod$6.z.string()
  }).array()
}).array().or(_zod$6.z.object({
  error: _zod$6.z.object({
    code: _zod$6.z.number(),
    message: _zod$6.z.string()
  })
}));
// eslint-disable
// prettier-ignore
const supportedLanguagesMap = new _LanguageAliases$1.LanguageAliases(["ace", "af", "sq", "am", "ar", "arz", "ary", "arb", "hy", "as", "ast", "az", "ban", "bn", "ba", "eu", "bbc", "be", "bho", "bik", "brx", "bs", "bg", "yue", "ca", "ceb", "hne", "lzh", "zh-Hans", "zh-Hant", "co", "hr", "cs", "da", "prs", "dv", "doi", "nl", "en", "en-GB", "epo", "et", "fo", "fj", "fil", "fi", "fr", "fr-CA", "fy", "fur", "gl", "lug", "ka", "de", "el", "gu", "ht", "ha", "he", "hil", "hi", "mww", "hu", "iba", "is", "ig", "ilo", "id", "ikt", "iu", "iu-Latn", "ga", "it", "jam", "ja", "jav", "kea", "kn", "pam", "ks", "kk", "km", "rw", "tlh-Latn", "gom", "ko", "kri", "ku", "kmr", "ky", "lo", "la", "lv", "lij", "lim", "ln", "lt", "lmo", "dsb", "lb", "mk", "mai", "mg", "ms", "ml", "mt", "mr", "mwr", "mfe", "min", "mn-Cyrl", "mn-Mong", "my", "mi", "ne", "nb", "nno", "nya", "oc", "or", "pap", "ps", "fa", "pl", "pt", "pt-PT", "pa", "pnb", "otq", "ro", "run", "ru", "sm", "sa", "srd", "sr-Cyrl", "sr-Latn", "st", "nso", "tn", "crs", "sn", "scn", "sd", "si", "sk", "sl", "so", "es", "su", "sw", "sv", "ty", "tgk", "ta", "tt", "te", "tet", "th", "bo", "ti", "tpi", "to", "tr", "tk", "uk", "hsb", "ur", "ug", "uz", "vec", "vi", "war", "cy", "xh", "ydd", "yo", "yua", "zu"]);
// eslint-enable
class MicrosoftTranslator extends _BaseTranslator$4.BaseTranslator {
  constructor() {
    super(...arguments);
    this.token = null;
  }
  static getSupportedLanguages() {
    return supportedLanguagesMap.getAll();
  }
  getLengthLimit() {
    return 50000;
  }
  getRequestsTimeout() {
    return 300;
  }
  checkLimitExceeding(text) {
    if (Array.isArray(text)) {
      const arrayLen = text.reduce((acc, text) => acc + text.length, 0);
      const extra = arrayLen - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    } else {
      const extra = text.length - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    }
  }
  translate(text, from, to) {
    return __awaiter$7(this, void 0, void 0, function* () {
      return this.translateBatch([text], from, to).then(resp => resp[0]);
    });
  }
  translateBatch(text, from, to) {
    return __awaiter$7(this, void 0, void 0, function* () {
      const sourceLanguage = from === 'auto' ? 'auto' : supportedLanguagesMap.get(from);
      const targetLanguage = supportedLanguagesMap.get(to);
      if (!sourceLanguage) throw new TypeError(`Unsupported source language ${from}`);
      if (!targetLanguage) throw new TypeError(`Unsupported source language ${to}`);
      const token = yield this.getToken();
      const url = 'https://api-edge.cognitive.microsofttranslator.com/translate?' + (
      // Omit `from` parameter for auto detection of language
      sourceLanguage !== 'auto' ? `from=${encodeURIComponent(sourceLanguage)}&` : '') + `to=${encodeURIComponent(targetLanguage)}&api-version=3.0&includeSentenceLength=true`;
      return this.fetch(url, {
        responseType: 'json',
        method: 'POST',
        headers: {
          accept: '*/*',
          'accept-language': 'zh-TW,zh;q=0.9,ja;q=0.8,zh-CN;q=0.7,en-US;q=0.6,en;q=0.5',
          authorization: `Bearer ${token}`,
          'cache-control': 'no-cache',
          'content-type': 'application/json',
          pragma: 'no-cache',
          priority: 'u=1, i',
          'referrer-policy': 'strict-origin-when-cross-origin',
          'sec-fetch-dest': 'empty',
          'sec-fetch-mode': 'cors',
          'sec-fetch-site': 'none',
          'sec-fetch-storage-access': 'active'
        },
        body: JSON.stringify(text.map(text => ({
          Text: text
        })))
      }).then(rawResult => {
        const result = ResponseScheme.parse(rawResult.data);
        if ('error' in result) {
          throw new Error(`Code ${result.error.code}: ${result.error.message}`);
        }
        // Transform translations array
        return result.map(translationItem =>
        // Build translation for single text
        translationItem.translations.map(translationSegment => translationSegment.text).join(' '));
      });
    });
  }
  getToken() {
    return __awaiter$7(this, void 0, void 0, function* () {
      var _a;
      // Wait resolution if pending
      if (this.token instanceof Promise) return this.token;
      // Fetch new token
      const tokenLifetime = (_a = this.options.tokenLifetime) !== null && _a !== void 0 ? _a : 30000;
      if (!this.token || Date.now() - this.token.issuedAt > tokenLifetime) {
        this.token = this.fetch('https://edge.microsoft.com/translate/auth', {
          responseType: 'text',
          method: 'GET',
          headers: {
            accept: '*/*',
            'accept-language': 'zh-TW,zh;q=0.9,ja;q=0.8,zh-CN;q=0.7,en-US;q=0.6,en;q=0.5',
            'cache-control': 'no-cache',
            pragma: 'no-cache',
            priority: 'u=1, i',
            'referrer-policy': 'strict-origin-when-cross-origin',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'none',
            'sec-fetch-storage-access': 'active'
          },
          body: null
        }).then(({
          data: token,
          statusText,
          status,
          ok
        }) => {
          if (!ok) throw new Error(statusText || `Unknown error with status ${status}`);
          this.token = {
            value: token,
            issuedAt: Date.now()
          };
          return token;
        }).catch(error => {
          this.token = null;
          throw error;
        });
        return yield this.token;
      }
      // Use cached value
      return this.token.value;
    });
  }
}
MicrosoftTranslator_2 = MicrosoftTranslator$1.MicrosoftTranslator = MicrosoftTranslator;
MicrosoftTranslator.translatorName = 'MicrosoftTranslator';
MicrosoftTranslator.isSupportedAutoFrom = () => true;

var YandexTranslator$1 = {};

var lodash$2 = {exports: {}};

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$2.exports;

(function (module, exports) {
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined$1;

	  /** Used as the semantic version number. */
	  var VERSION = '4.17.21';

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
	      FUNC_ERROR_TEXT = 'Expected a function',
	      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';

	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** Used to compose bitmasks for cloning. */
	  var CLONE_DEEP_FLAG = 1,
	      CLONE_FLAT_FLAG = 2,
	      CLONE_SYMBOLS_FLAG = 4;

	  /** Used to compose bitmasks for value comparisons. */
	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;

	  /** Used to compose bitmasks for function metadata. */
	  var WRAP_BIND_FLAG = 1,
	      WRAP_BIND_KEY_FLAG = 2,
	      WRAP_CURRY_BOUND_FLAG = 4,
	      WRAP_CURRY_FLAG = 8,
	      WRAP_CURRY_RIGHT_FLAG = 16,
	      WRAP_PARTIAL_FLAG = 32,
	      WRAP_PARTIAL_RIGHT_FLAG = 64,
	      WRAP_ARY_FLAG = 128,
	      WRAP_REARG_FLAG = 256,
	      WRAP_FLIP_FLAG = 512;

	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;

	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;

	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	  ];

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);

	  /** Used to match leading whitespace. */
	  var reTrimStart = /^\s+/;

	  /** Used to match a single whitespace character. */
	  var reWhitespace = /\s/;

	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;

	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	  /**
	   * Used to validate the `validate` option in `_.template` variable.
	   *
	   * Forbids characters which could potentially change the meaning of the function argument definition:
	   * - "()," (modification of function parameters)
	   * - "=" (default value)
	   * - "[]{}" (destructuring of function parameters)
	   * - "/" (beginning of a comment)
	   * - whitespace
	   */
	  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;

	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;

	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f',
	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';

	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
	      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');

	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');

	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');

	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();

	  /** Detect free variable `exports`. */
	  var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;

	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      // Use `util.types` for Node.js 10+.
	      var types = freeModule && freeModule.require && freeModule.require('util').types;

	      if (types) {
	        return types;
	      }

	      // Legacy `process.binding('util')` for Node.js < 10.
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());

	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }

	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;

	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }

	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }

	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);

	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }

	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;

	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');

	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }

	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }

	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }

	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }

	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }

	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined$1 : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined$1 : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }

	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;

	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }

	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;

	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined$1) {
	        result = result === undefined$1 ? current : (result + current);
	      }
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);

	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }

	  /**
	   * The base implementation of `_.trim`.
	   *
	   * @private
	   * @param {string} string The string to trim.
	   * @returns {string} Returns the trimmed string.
	   */
	  function baseTrim(string) {
	    return string
	      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
	      : string;
	  }

	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }

	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }

	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }

	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;

	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;

	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;

	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined$1 : object[key];
	  }

	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }

	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }

	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];

	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }

	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);

	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }

	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }

	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }

	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }

	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }

	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }

	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedEndIndex(string) {
	    var index = string.length;

	    while (index-- && reWhitespace.test(string.charAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }

	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }

	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;

	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];

	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());

	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;

	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined$1,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
	        symIterator = Symbol ? Symbol.iterator : undefined$1,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());

	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;

	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);

	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined$1,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
	        symbolToString = symbolProto ? symbolProto.toString : undefined$1;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array and iteratees accept only
	     * one argument. The heuristic for whether a section qualifies for shortcut
	     * fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined$1;
	        return result;
	      };
	    }());

	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined$1;
	    }

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	     * following template settings to use alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined$1 : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
	    }

	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
	    }

	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
	      return this;
	    }

	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }

	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      return index < 0 ? undefined$1 : data[index][1];
	    }

	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }

	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }

	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }

	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }

	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }

	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;

	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }

	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;

	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }

	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }

	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }

	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }

	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);

	      this.size = data.size;
	      return result;
	    }

	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }

	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }

	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }

	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;

	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined$1;
	    }

	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }

	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }

	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined$1 && !eq(object[key], value)) ||
	          (value === undefined$1 && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined$1 && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssignIn(object, source) {
	      return object && copyObject(source, keysIn(source), object);
	    }

	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }

	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;

	      while (++index < length) {
	        result[index] = skip ? undefined$1 : get(object, paths[index]);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined$1) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined$1) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }

	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, bitmask, customizer, key, object, stack) {
	      var result,
	          isDeep = bitmask & CLONE_DEEP_FLAG,
	          isFlat = bitmask & CLONE_FLAT_FLAG,
	          isFull = bitmask & CLONE_SYMBOLS_FLAG;

	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined$1) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;

	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
	          if (!isDeep) {
	            return isFlat
	              ? copySymbolsIn(value, baseAssignIn(result, value))
	              : copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);

	      if (isSet(value)) {
	        value.forEach(function(subValue) {
	          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	        });
	      } else if (isMap(value)) {
	        value.forEach(function(subValue, key) {
	          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	        });
	      }

	      var keysFunc = isFull
	        ? (isFlat ? getAllKeysIn : getAllKeys)
	        : (isFlat ? keysIn : keys);

	      var props = isArr ? undefined$1 : keysFunc(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }

	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];

	        if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined$1, args); }, wait);
	    }

	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;

	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);

	        if (current != null && (computed === undefined$1
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined$1 || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;

	      predicate || (predicate = isFlattenable);
	      result || (result = []);

	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }

	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = castPath(path, object);

	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined$1;
	    }

	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }

	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined$1 ? undefinedTag : nullTag;
	      }
	      return (symToStringTag && symToStringTag in Object(value))
	        ? getRawTag(value)
	        : objectToString(value);
	    }

	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }

	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }

	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }

	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }

	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];

	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined$1;
	      }
	      array = arrays[0];

	      var index = -1,
	          seen = caches[0];

	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      var func = object == null ? object : object[toKey(last(path))];
	      return func == null ? undefined$1 : apply(func, object, args);
	    }

	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }

	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }

	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }

	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, bitmask, customizer, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = objIsArr ? arrayTag : getTag(object),
	          othTag = othIsArr ? arrayTag : getTag(other);

	      objTag = objTag == argsTag ? objectTag : objTag;
	      othTag = othTag == argsTag ? objectTag : othTag;

	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	      }
	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;

	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	    }

	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined$1 && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined$1
	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }

	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }

	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }

	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }

	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }

	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];

	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }

	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined$1 && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        stack || (stack = new Stack);
	        if (isObject(srcValue)) {
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	            : undefined$1;

	          if (newValue === undefined$1) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = safeGet(object, key),
	          srcValue = safeGet(source, key),
	          stacked = stack.get(srcValue);

	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined$1;

	      var isCommon = newValue === undefined$1;

	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || isFunction(objValue)) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }

	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined$1;
	    }

	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      if (iteratees.length) {
	        iteratees = arrayMap(iteratees, function(iteratee) {
	          if (isArray(iteratee)) {
	            return function(value) {
	              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
	            }
	          }
	          return iteratee;
	        });
	      } else {
	        iteratees = [identity];
	      }

	      var index = -1;
	      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, paths) {
	      return basePickBy(object, paths, function(value, path) {
	        return hasIn(object, path);
	      });
	    }

	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, paths, predicate) {
	      var index = -1,
	          length = paths.length,
	          result = {};

	      while (++index < length) {
	        var path = paths[index],
	            value = baseGet(object, path);

	        if (predicate(value, path)) {
	          baseSet(result, castPath(path, object), value);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;

	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;

	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;

	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          } else {
	            baseUnset(array, index);
	          }
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }

	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);

	      return result;
	    }

	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }

	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }

	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }

	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;

	        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
	          return object;
	        }

	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
	          if (newValue === undefined$1) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };

	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      var low = 0,
	          high = array == null ? 0 : array.length;
	      if (high === 0) {
	        return 0;
	      }

	      value = iteratee(value);
	      var valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined$1;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined$1,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);

	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }

	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;

	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      return object == null || delete object[toKey(last(path))];
	    }

	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }

	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}

	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }

	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);

	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;

	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }

	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};

	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined$1;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }

	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }

	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }

	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value, object) {
	      if (isArray(value)) {
	        return value;
	      }
	      return isKey(value, object) ? [value] : stringToPath(toString(value));
	    }

	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;

	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined$1 ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }

	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };

	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	      buffer.copy(result);
	      return result;
	    }

	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }

	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }

	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }

	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }

	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }

	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined$1,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);

	        var othIsDefined = other !== undefined$1,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);

	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }

	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;

	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;

	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];

	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined$1;

	        if (newValue === undefined$1) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }

	    /**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }

	    /**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbolsIn(source, object) {
	      return copyObject(source, getSymbolsIn(source), object);
	    }

	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};

	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }

	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined$1,
	            guard = length > 2 ? sources[2] : undefined$1;

	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined$1;

	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined$1 : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;

	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);

	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined$1;

	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);

	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);

	        return chr[methodName]() + trailing;
	      };
	    }

	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);

	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
	            args, holders, undefined$1, undefined$1, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;

	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined$1;

	          if (data && isLaziable(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value)) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & WRAP_ARY_FLAG,
	          isBind = bitmask & WRAP_BIND_FLAG,
	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	          isFlip = bitmask & WRAP_FLIP_FLAG,
	          Ctor = isBindKey ? undefined$1 : createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }

	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined$1 && other === undefined$1) {
	          return defaultValue;
	        }
	        if (value !== undefined$1) {
	          result = value;
	        }
	        if (other !== undefined$1) {
	          if (result === undefined$1) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }

	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined$1 ? ' ' : baseToString(chars);

	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined$1;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined$1) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }

	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & WRAP_CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined$1,
	          newHoldersRight = isCurry ? undefined$1 : holders,
	          newPartials = isCurry ? partials : undefined$1,
	          newPartialsRight = isCurry ? undefined$1 : partials;

	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];

	      var result = wrapFunc.apply(undefined$1, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }

	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
	        if (precision && nativeIsFinite(number)) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));

	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };

	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined$1;
	      }
	      ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined$1 ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;

	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined$1;
	      }
	      var data = isBindKey ? undefined$1 : getData(func);

	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];

	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] === undefined$1
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);

	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined$1, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	     * of source objects to the destination object for all destination properties
	     * that resolve to `undefined`.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsAssignIn(objValue, srcValue, key, object) {
	      if (objValue === undefined$1 ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
	     * objects into destination objects that are passed thru.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	     * objects.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {string} key The key of the property to inspect.
	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	     */
	    function customOmitClone(value) {
	      return isPlainObject(value) ? undefined$1 : value;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Check that cyclic values are equal.
	      var arrStacked = stack.get(array);
	      var othStacked = stack.get(other);
	      if (arrStacked && othStacked) {
	        return arrStacked == other && othStacked == array;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

	      stack.set(array, other);
	      stack.set(other, array);

	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined$1) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;

	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;

	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');

	        case mapTag:
	          var convert = mapToArray;

	        case setTag:
	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	          convert || (convert = setToArray);

	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= COMPARE_UNORDERED_FLAG;

	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	          stack['delete'](object);
	          return result;

	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          objProps = getAllKeys(object),
	          objLength = objProps.length,
	          othProps = getAllKeys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Check that cyclic values are equal.
	      var objStacked = stack.get(object);
	      var othStacked = stack.get(other);
	      if (objStacked && othStacked) {
	        return objStacked == other && othStacked == object;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);

	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined$1
	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined$1, flatten), func + '');
	    }

	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }

	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }

	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }

	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }

	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;

	      while (length--) {
	        var key = result[length],
	            value = object[key];

	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined$1;
	    }

	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];

	      try {
	        value[symToStringTag] = undefined$1;
	        var unmasked = true;
	      } catch (e) {}

	      var result = nativeObjectToString.call(value);
	      if (unmasked) {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	      if (object == null) {
	        return [];
	      }
	      object = Object(object);
	      return arrayFilter(nativeGetSymbols(object), function(symbol) {
	        return propertyIsEnumerable.call(object, symbol);
	      });
	    };

	    /**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };

	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;

	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined$1,
	            ctorString = Ctor ? toSource(Ctor) : '';

	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }

	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          result = false;

	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case dataViewTag:
	          return cloneDataView(object, isDeep);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);

	        case mapTag:
	          return new Ctor;

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          return cloneRegExp(object);

	        case setTag:
	          return new Ctor;

	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }

	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }

	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      var type = typeof value;
	      length = length == null ? MAX_SAFE_INTEGER : length;

	      return !!length &&
	        (type == 'number' ||
	          (type != 'symbol' && reIsUint.test(value))) &&
	            (value > -1 && value % 1 == 0 && value < length);
	    }

	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }

	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];

	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }

	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;

	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	      return value === proto;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined$1 || (key in Object(object)));
	      };
	    }

	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });

	      var cache = result.cache;
	      return result;
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

	      var isCombo =
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }

	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);

	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }

	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
	      }
	      return array;
	    }

	    /**
	     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the property to get.
	     * @returns {*} Returns the property value.
	     */
	    function safeGet(object, key) {
	      if (key === 'constructor' && typeof object[key] === 'function') {
	        return;
	      }

	      if (key == '__proto__') {
	        return;
	      }

	      return object[key];
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);

	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };

	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);

	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }

	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;

	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined$1, arguments);
	      };
	    }

	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;

	      size = size === undefined$1 ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];

	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }

	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      var result = [];
	      if (string.charCodeAt(0) === 46 /* . */) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, subString) {
	        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });

	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }

	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;

	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }

	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined$1;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined$1;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined$1) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }

	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }

	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }

	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined$1 ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }

	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};

	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined$1;
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }

	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      if (iteratee === last(mapped)) {
	        iteratee = undefined$1;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined$1, comparator)
	        : [];
	    });

	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined$1;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined$1) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }

	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
	    }

	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);

	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined$1, comparator)
	        : array;
	    }

	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);

	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));

	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined$1 ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }

	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }

	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }

	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }

	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined$1;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined$1, group);
	      });
	    }

	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined$1;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
	    });

	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);

	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }

	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined$1;

	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
	      return unzipWith(arrays, iteratee);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }

	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };

	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined$1
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined$1);
	        }
	        return array;
	      });
	    });

	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined$1) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined$1 : this.__values__[this.__index__++];

	      return { 'done': done, 'value': value };
	    }

	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }

	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined$1;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined$1
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }

	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined$1;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     *
	     * // Combining several predicates using `_.overEvery` or `_.overSome`.
	     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
	     * // => objects for ['fred', 'barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);

	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined$1 ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }

	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });

	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });

	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined$1 : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }

	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }

	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined$1;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 30 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined$1 : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined$1;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = WRAP_BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined$1 : arity;
	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined$1 : arity;
	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;

	        lastArgs = lastThis = undefined$1;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }

	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }

	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            timeWaiting = wait - timeSinceLastCall;

	        return maxing
	          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	          : timeWaiting;
	      }

	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;

	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }

	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }

	      function trailingEdge(time) {
	        timerId = undefined$1;

	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined$1;
	        return result;
	      }

	      function cancel() {
	        if (timerId !== undefined$1) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined$1;
	      }

	      function flush() {
	        return timerId === undefined$1 ? result : trailingEdge(now());
	      }

	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);

	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;

	        if (isInvoking) {
	          if (timerId === undefined$1) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            clearTimeout(timerId);
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined$1) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, WRAP_FLIP_FLAG);
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }

	    // Expose `MapCache`.
	    memoize.Cache = MapCache;

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);

	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });

	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
	    });

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined$1 ? start : toInteger(start);
	      return baseRest(func, start);
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start == null ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);

	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }

	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }

	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }

	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }

	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });

	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;

	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }

	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are compared by strict equality, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }

	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      var result = customizer ? customizer(value, other) : undefined$1;
	      return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }

	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }

	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }

	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }

	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined$1;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

	      return func(value);
	    }

	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }

	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;

	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }

	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }

	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = baseTrim(value);
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }

	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return value
	        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
	        : (value === 0 ? value : 0);
	    }

	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });

	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });

	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });

	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });

	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);

	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }

	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(object, sources) {
	      object = Object(object);

	      var index = -1;
	      var length = sources.length;
	      var guard = length > 2 ? sources[2] : undefined$1;

	      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	        length = 1;
	      }

	      while (++index < length) {
	        var source = sources[index];
	        var props = keysIn(source);
	        var propsIndex = -1;
	        var propsLength = props.length;

	        while (++propsIndex < propsLength) {
	          var key = props[propsIndex];
	          var value = object[key];

	          if (value === undefined$1 ||
	              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	            object[key] = source[key];
	          }
	        }
	      }

	      return object;
	    });

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined$1, customDefaultsMerge);
	      return apply(mergeWith, undefined$1, args);
	    });

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }

	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }

	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined$1 : baseGet(object, path);
	      return result === undefined$1 ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }

	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }

	      result[value] = key;
	    }, constant(identity));

	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }

	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);

	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }

	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });

	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, paths) {
	      var result = {};
	      if (object == null) {
	        return result;
	      }
	      var isDeep = false;
	      paths = arrayMap(paths, function(path) {
	        path = castPath(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	      });
	      copyObject(object, getAllKeysIn(object), result);
	      if (isDeep) {
	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	      }
	      var length = paths.length;
	      while (length--) {
	        baseUnset(result, paths[length]);
	      }
	      return result;
	    });

	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }

	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, paths) {
	      return object == null ? {} : basePick(object, paths);
	    });

	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      if (object == null) {
	        return {};
	      }
	      var props = arrayMap(getAllKeysIn(object), function(prop) {
	        return [prop];
	      });
	      predicate = getIteratee(predicate);
	      return basePickBy(object, props, function(value, path) {
	        return predicate(value, path[0]);
	      });
	    }

	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length;

	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        length = 1;
	        object = undefined$1;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined$1 : object[toKey(path[index])];
	        if (value === undefined$1) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }

	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }

	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }

	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);

	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }

	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }

	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }

	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined$1) {
	        upper = lower;
	        lower = undefined$1;
	      }
	      if (upper !== undefined$1) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined$1) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }

	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined$1) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }

	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined$1;
	      }
	      if (floating === undefined$1) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined$1;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined$1;
	        }
	      }
	      if (lower === undefined$1 && upper === undefined$1) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined$1) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });

	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }

	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);

	      var length = string.length;
	      position = position === undefined$1
	        ? length
	        : baseClamp(toInteger(position), 0, length);

	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }

	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }

	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);

	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }

	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined$1;
	      }
	      limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }

	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = position == null
	        ? 0
	        : baseClamp(toInteger(position), 0, string.length);

	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined$1;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, customDefaultsAssignIn);

	      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      // The sourceURL gets injected into the source that's eval-ed, so be careful
	      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
	      // and escape the comment, thus injecting code that gets evaled.
	      var sourceURL = '//# sourceURL=' +
	        (hasOwnProperty.call(options, 'sourceURL')
	          ? (options.sourceURL + '').replace(/\s/g, ' ')
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Throw an error if a forbidden character was found in `variable`, to prevent
	      // potential command injection attacks.
	      else if (reForbiddenIdentifierChars.test(variable)) {
	        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
	      }

	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined$1, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }

	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined$1)) {
	        return baseTrim(string);
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;

	      return castSlice(strSymbols, start, end).join('');
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined$1)) {
	        return string.slice(0, trimmedEndIndex(string) + 1);
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

	      return castSlice(strSymbols, 0, end).join('');
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined$1)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));

	      return castSlice(strSymbols, start).join('');
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);

	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);

	      if (separator === undefined$1) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;

	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });

	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined$1 : pattern;

	      if (pattern === undefined$1) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined$1, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });

	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();

	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });

	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }

	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }

	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * **Note:** Multiple values can be checked by combining several matchers
	     * using `_.overSome`
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     *
	     * // Checking for several possible values
	     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * **Note:** Multiple values can be checked by combining several matchers
	     * using `_.overSome`
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     *
	     * // Checking for several possible values
	     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);

	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);

	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);

	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });

	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }

	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }

	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);

	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * Following shorthands are possible for providing predicates.
	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);

	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * Following shorthands are possible for providing predicates.
	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     *
	     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
	     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
	     */
	    var overSome = createOver(arraySome);

	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined$1 : baseGet(object, path);
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();

	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);

	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }

	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }

	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }

	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }

	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }

	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);

	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;

	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	    }

	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);

	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);

	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined$1;
	    }

	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined$1;
	    }

	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }

	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }

	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined$1;
	    }

	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined$1;
	    }

	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);

	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);

	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }

	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }

	    /*------------------------------------------------------------------------*/

	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;

	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;

	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

	        var result = (this.__filtered__ && !index)
	          ? new LazyWrapper(this)
	          : this.clone();

	        if (result.__filtered__) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };

	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };

	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });

	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined$1) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;

	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });

	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });

	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = lodashFunc.name + '';
	        if (!hasOwnProperty.call(realNames, key)) {
	          realNames[key] = [];
	        }
	        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined$1
	    }];

	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;

	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (typeof undefined$1 == 'function' && typeof undefined$1.amd == 'object' && undefined$1.amd) {
	    // Expose Lodash on the global object to prevent errors when Lodash is
	    // loaded by a script tag in the presence of an AMD loader.
	    // See http://requirejs.org/docs/errors.html#mismatch for more details.
	    // Use `_.noConflict` to remove Lodash from the global object.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    undefined$1(function() {
	      return _;
	    });
	  }
	  // Check for `exports` after `define` in case a build optimizer adds it.
	  else if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(commonjsGlobal)); 
} (lodash$2, lodash$2.exports));

var lodashExports = lodash$2.exports;
var lodash$1 = /*@__PURE__*/getDefaultExportFromCjs(lodashExports);

const token$1 = '%[a-f0-9]{2}';
const singleMatcher = new RegExp('(' + token$1 + ')|([^%]+?)', 'gi');
const multiMatcher = new RegExp('(' + token$1 + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return [decodeURIComponent(components.join(''))];
	} catch {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	const left = components.slice(0, split);
	const right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode$1(input) {
	try {
		return decodeURIComponent(input);
	} catch {
		let tokens = input.match(singleMatcher) || [];

		for (let i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher) || [];
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	const replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD',
	};

	let match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch {
			const result = decode$1(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	const entries = Object.keys(replaceMap);

	for (const key of entries) {
		// Replace all decoded components
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

function decodeUriComponent(encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
}

function includeKeys(object, predicate) {
	const result = {};

	if (Array.isArray(predicate)) {
		for (const key of predicate) {
			const descriptor = Object.getOwnPropertyDescriptor(object, key);
			if (descriptor?.enumerable) {
				Object.defineProperty(result, key, descriptor);
			}
		}
	} else {
		// `Reflect.ownKeys()` is required to retrieve symbol properties
		for (const key of Reflect.ownKeys(object)) {
			const descriptor = Object.getOwnPropertyDescriptor(object, key);
			if (descriptor.enumerable) {
				const value = object[key];
				if (predicate(key, value, object)) {
					Object.defineProperty(result, key, descriptor);
				}
			}
		}
	}

	return result;
}

function excludeKeys(object, predicate) {
	if (Array.isArray(predicate)) {
		const set = new Set(predicate);
		return includeKeys(object, key => !set.has(key));
	}

	return includeKeys(object, (key, value, object) => !predicate(key, value, object));
}

function splitOnFirst(string, separator) {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (string === '' || separator === '') {
		return [];
	}

	const separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
}

const isNullOrUndefined = value => value === null || value === undefined;

// eslint-disable-next-line unicorn/prefer-code-point
const strictUriEncode = string => encodeURIComponent(string).replaceAll(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index': {
			return key => (result, value) => {
				const index = result.length;

				if (
					value === undefined
					|| (options.skipNull && value === null)
					|| (options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [
						...result, [encode(key, options), '[', index, ']'].join(''),
					];
				}

				return [
					...result,
					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join(''),
				];
			};
		}

		case 'bracket': {
			return key => (result, value) => {
				if (
					value === undefined
					|| (options.skipNull && value === null)
					|| (options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [
						...result,
						[encode(key, options), '[]'].join(''),
					];
				}

				return [
					...result,
					[encode(key, options), '[]=', encode(value, options)].join(''),
				];
			};
		}

		case 'colon-list-separator': {
			return key => (result, value) => {
				if (
					value === undefined
					|| (options.skipNull && value === null)
					|| (options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [
						...result,
						[encode(key, options), ':list='].join(''),
					];
				}

				return [
					...result,
					[encode(key, options), ':list=', encode(value, options)].join(''),
				];
			};
		}

		case 'comma':
		case 'separator':
		case 'bracket-separator': {
			const keyValueSeparator = options.arrayFormat === 'bracket-separator'
				? '[]='
				: '=';

			return key => (result, value) => {
				if (
					value === undefined
					|| (options.skipNull && value === null)
					|| (options.skipEmptyString && value === '')
				) {
					return result;
				}

				// Translate null to an empty string so that it doesn't serialize as 'null'
				value = value === null ? '' : value;

				if (result.length === 0) {
					return [[encode(key, options), keyValueSeparator, encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			};
		}

		default: {
			return key => (result, value) => {
				if (
					value === undefined
					|| (options.skipNull && value === null)
					|| (options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return [
						...result,
						encode(key, options),
					];
				}

				return [
					...result,
					[encode(key, options), '=', encode(value, options)].join(''),
				];
			};
		}
	}
}

function parserForArrayFormat(options) {
	let result;

	switch (options.arrayFormat) {
		case 'index': {
			return (key, value, accumulator) => {
				result = /\[(\d*)]$/.exec(key);

				key = key.replace(/\[\d*]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};
		}

		case 'bracket': {
			return (key, value, accumulator) => {
				result = /(\[])$/.exec(key);
				key = key.replace(/\[]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [...accumulator[key], value];
			};
		}

		case 'colon-list-separator': {
			return (key, value, accumulator) => {
				result = /(:list)$/.exec(key);
				key = key.replace(/:list$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [...accumulator[key], value];
			};
		}

		case 'comma':
		case 'separator': {
			return (key, value, accumulator) => {
				const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
				const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
				value = isEncodedArray ? decode(value, options) : value;
				const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : (value === null ? value : decode(value, options));
				accumulator[key] = newValue;
			};
		}

		case 'bracket-separator': {
			return (key, value, accumulator) => {
				const isArray = /(\[])$/.test(key);
				key = key.replace(/\[]$/, '');

				if (!isArray) {
					accumulator[key] = value ? decode(value, options) : value;
					return;
				}

				const arrayValue = value === null
					? []
					: decode(value, options).split(options.arrayFormatSeparator);

				if (accumulator[key] === undefined) {
					accumulator[key] = arrayValue;
					return;
				}

				accumulator[key] = [...accumulator[key], ...arrayValue];
			};
		}

		default: {
			return (key, value, accumulator) => {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [...[accumulator[key]].flat(), value];
			};
		}
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeUriComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort((a, b) => Number(a) - Number(b))
			.map(key => input[key]);
	}

	return input;
}

function removeHash(input) {
	const hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	let hash = '';
	const hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function parseValue(value, options, type) {
	if (type === 'string' && typeof value === 'string') {
		return value;
	}

	if (typeof type === 'function' && typeof value === 'string') {
		return type(value);
	}

	if (type === 'boolean' && value === null) {
		return true;
	}

	if (type === 'boolean' && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		return value.toLowerCase() === 'true';
	}

	if (type === 'boolean' && value !== null && (value.toLowerCase() === '1' || value.toLowerCase() === '0')) {
		return value.toLowerCase() === '1';
	}

	if (type === 'string[]' && options.arrayFormat !== 'none' && typeof value === 'string') {
		return [value];
	}

	if (type === 'number[]' && options.arrayFormat !== 'none' && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		return [Number(value)];
	}

	if (type === 'number' && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		return Number(value);
	}

	if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		return value.toLowerCase() === 'true';
	}

	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		return Number(value);
	}

	return value;
}

function extract(input) {
	input = removeHash(input);
	const queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parse$1(query, options) {
	options = {
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false,
		types: Object.create(null),
		...options,
	};

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	const returnValue = Object.create(null);

	if (typeof query !== 'string') {
		return returnValue;
	}

	query = query.trim().replace(/^[?#&]/, '');

	if (!query) {
		return returnValue;
	}

	for (const parameter of query.split('&')) {
		if (parameter === '') {
			continue;
		}

		const parameter_ = options.decode ? parameter.replaceAll('+', ' ') : parameter;

		let [key, value] = splitOnFirst(parameter_, '=');

		if (key === undefined) {
			key = parameter_;
		}

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : (['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options));
		formatter(decode(key, options), value, returnValue);
	}

	for (const [key, value] of Object.entries(returnValue)) {
		if (typeof value === 'object' && value !== null && options.types[key] !== 'string') {
			for (const [key2, value2] of Object.entries(value)) {
				const type = options.types[key] ? options.types[key].replace('[]', '') : undefined;
				value[key2] = parseValue(value2, options, type);
			}
		} else if (typeof value === 'object' && value !== null && options.types[key] === 'string') {
			returnValue[key] = Object.values(value).join(options.arrayFormatSeparator);
		} else {
			returnValue[key] = parseValue(value, options, options.types[key]);
		}
	}

	if (options.sort === false) {
		return returnValue;
	}

	// TODO: Remove the use of `reduce`.
	// eslint-disable-next-line unicorn/no-array-reduce
	return (options.sort === true ? Object.keys(returnValue).sort() : Object.keys(returnValue).sort(options.sort)).reduce((result, key) => {
		const value = returnValue[key];
		result[key] = Boolean(value) && typeof value === 'object' && !Array.isArray(value) ? keysSorter(value) : value;
		return result;
	}, Object.create(null));
}

function stringify(object, options) {
	if (!object) {
		return '';
	}

	options = {
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		...options,
	};

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	const shouldFilter = key => (
		(options.skipNull && isNullOrUndefined(object[key]))
		|| (options.skipEmptyString && object[key] === '')
	);

	const formatter = encoderForArrayFormat(options);

	const objectCopy = {};

	for (const [key, value] of Object.entries(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = value;
		}
	}

	const keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(key => {
		const value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
				return encode(key, options) + '[]';
			}

			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(x => x.length > 0).join('&');
}

function parseUrl(url, options) {
	options = {
		decode: true,
		...options,
	};

	let [url_, hash] = splitOnFirst(url, '#');

	if (url_ === undefined) {
		url_ = url;
	}

	return {
		url: url_?.split('?')?.[0] ?? '',
		query: parse$1(extract(url), options),
		...(options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}),
	};
}

function stringifyUrl(object, options) {
	options = {
		encode: true,
		strict: true,
		[encodeFragmentIdentifier]: true,
		...options,
	};

	const url = removeHash(object.url).split('?')[0] || '';
	const queryFromUrl = extract(object.url);

	const query = {
		...parse$1(queryFromUrl, {sort: false, ...options}),
		...object.query,
	};

	let queryString = stringify(query, options);
	queryString &&= `?${queryString}`;

	let hash = getHash(object.url);
	if (typeof object.fragmentIdentifier === 'string') {
		const urlObjectForFragmentEncode = new URL(url);
		urlObjectForFragmentEncode.hash = object.fragmentIdentifier;
		hash = options[encodeFragmentIdentifier] ? urlObjectForFragmentEncode.hash : `#${object.fragmentIdentifier}`;
	}

	return `${url}${queryString}${hash}`;
}

function pick(input, filter, options) {
	options = {
		parseFragmentIdentifier: true,
		[encodeFragmentIdentifier]: false,
		...options,
	};

	const {url, query, fragmentIdentifier} = parseUrl(input, options);

	return stringifyUrl({
		url,
		query: includeKeys(query, filter),
		fragmentIdentifier,
	}, options);
}

function exclude(input, filter, options) {
	const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

	return pick(input, exclusionFilter, options);
}

var queryString$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	exclude: exclude,
	extract: extract,
	parse: parse$1,
	parseUrl: parseUrl,
	pick: pick,
	stringify: stringify,
	stringifyUrl: stringifyUrl
});

var queryString = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: queryString$1
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(queryString);

var getYandexSID$1 = {};

"use strict";

Object.defineProperty(getYandexSID$1, "__esModule", {
  value: true
});
var getYandexSID_2 = getYandexSID$1.getYandexSID = getYandexSID;
// Source: https://github.com/FilipePS/Traduzir-paginas-web/blob/f3a4956a1aa96b7a9124864158a5200827694521/background/translationService.js
let lastYandexRequestSIDTime = null;
let yandexTranslateSID = null;
let yandexSIDNotFound = false;
function getYandexSID(fetcher) {
  return new Promise(resolve => {
    let updateYandexSid = false;
    if (lastYandexRequestSIDTime) {
      const date = new Date();
      if (yandexTranslateSID) {
        date.setHours(date.getHours() - 12);
      } else if (yandexSIDNotFound) {
        date.setMinutes(date.getMinutes() - 30);
      } else {
        date.setMinutes(date.getMinutes() - 2);
      }
      if (date.getTime() > lastYandexRequestSIDTime) {
        updateYandexSid = true;
      }
    } else {
      updateYandexSid = true;
    }
    if (updateYandexSid) {
      lastYandexRequestSIDTime = Date.now();
      const url = 'https://translate.yandex.net/website-widget/v1/widget.js?widgetId=ytWidget&pageLang=es&widgetTheme=light&autoMode=false';
      fetcher(url, {
        responseType: 'text'
      }).then(response => {
        const result = /sid:\s'[0-9a-f.]+/.exec(typeof response.data === 'string' ? response.data : '');
        if ((result === null || result === void 0 ? void 0 : result[0]) && result[0].length > 7) {
          yandexTranslateSID = result[0].substring(6);
          yandexSIDNotFound = false;
        } else {
          yandexSIDNotFound = true;
        }
        resolve();
      }).catch(error => {
        console.error(error);
        resolve();
      });
    } else {
      resolve();
    }
  }).then(() => yandexTranslateSID);
}

"use strict";

Object.defineProperty(YandexTranslator$1, "__esModule", {
  value: true
});
var YandexTranslator_2 = YandexTranslator$1.YandexTranslator = void 0;
var _lodash = lodashExports;
var _queryString$1 = _interopRequireDefault$4(require$$0);
var _zod$5 = _interopRequireDefault$4(zod);
var _BaseTranslator$3 = BaseTranslator$1;
var _getYandexSID = getYandexSID$1;
function _interopRequireDefault$4(e) { return e && e.__esModule ? e : { default: e }; }
var __awaiter$6 = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class YandexTranslator extends _BaseTranslator$3.BaseTranslator {
  static isSupportedAutoFrom() {
    return true;
  }
  static getSupportedLanguages() {
    // Supported, but not valid languages ['mhr', 'pap', 'ceb', 'mrj', 'udm']
    // eslint-disable
    // prettier-ignore
    return ['af', 'am', 'ar', 'az', 'ba', 'be', 'bg', 'bn', 'bs', 'ca', 'ceb', 'cs', 'cv', 'cy', 'da', 'de', 'el', 'emj', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fr', 'ga', 'gd', 'gl', 'gu', 'he', 'hi', 'hr', 'ht', 'hu', 'hy', 'id', 'is', 'it', 'ja', 'jv', 'ka', 'kazlat', 'kk', 'km', 'kn', 'ko', 'ky', 'la', 'lb', 'lo', 'lt', 'lv', 'mg', 'mhr', 'mi', 'mk', 'ml', 'mn', 'mr', 'mrj', 'ms', 'mt', 'my', 'ne', 'nl', 'no', 'pa', 'pap', 'pl', 'pt', 'ro', 'ru', 'sah', 'si', 'sjn', 'sk', 'sl', 'sq', 'sr', 'su', 'sv', 'sw', 'ta', 'te', 'tg', 'th', 'tl', 'tr', 'tt', 'udm', 'uk', 'ur', 'uz', 'uzbcyr', 'vi', 'xh', 'yi', 'zh', 'zu'];
    // eslint-enable
  }
  getLengthLimit() {
    return 4000;
  }
  getRequestsTimeout() {
    return 500;
  }
  checkLimitExceeding(text) {
    if (Array.isArray(text)) {
      const arrayLen = text.reduce((acc, text) => acc + text.length, 0);
      const extra = arrayLen - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    } else {
      const extra = text.length - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    }
  }
  translate(text, from, to) {
    return __awaiter$6(this, void 0, void 0, function* () {
      return this.translateBatch([text], from, to).then(resp => resp[0]);
    });
  }
  translateBatch(text, from, to) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const sid = yield (0, _getYandexSID.getYandexSID)(this.fetch);
      if (sid === null) {
        throw new Error('Invalid SID');
      }
      const options = {
        format: 'html',
        lang: from === 'auto' ? to : `${from}-${to}`
      };
      let body = _queryString$1.default.stringify(options);
      for (const textChunk of text) {
        body += '&text=' + encodeURIComponent(textChunk);
      }
      // NOTE: if service will resist and will not work, it may check order of headers, parameters and requests
      // in this case just make requests less specific to it looks like requests from typical page (with overhead requests if require)
      const urlWithSid = 'https://translate.yandex.net/api/v1/tr.json/translate?srv=tr-url-widget&id=' + sid + '-0-0&';
      return this.fetch(urlWithSid + body, {
        responseType: 'json',
        method: 'GET',
        headers: Object.assign({
          'Content-Type': 'application/x-www-form-urlencoded'
        }, this.options.headers)
      }).then(response => {
        const data = _zod$5.default.object({
          text: _zod$5.default.string().array()
        }).parse(response.data);
        return data.text.map(text => (0, _lodash.unescape)(text));
      });
    });
  }
}
YandexTranslator_2 = YandexTranslator$1.YandexTranslator = YandexTranslator;
YandexTranslator.translatorName = 'YandexTranslator';

var GoogleTranslator$1 = {};

var languages = {};

var fixedLanguagesMap_1;
var languageAliases_1;
"use strict";

Object.defineProperty(languages, "__esModule", {
  value: true
});
var supportedLanguages_1 = languages.supportedLanguages = languageAliases_1 = languages.languageAliases = getFixedLanguage_1 = languages.getFixedLanguage = fixedLanguagesMap_1 = languages.fixedLanguagesMap = void 0;
var _LanguageAliases = LanguageAliases$1;
/**
 * Raw languages array
 */
// prettier-ignore
const supportedLanguages = supportedLanguages_1 = languages.supportedLanguages = ['af', 'ak', 'am', 'ar', 'as', 'ay', 'az', 'be', 'bg', 'bho', 'bm', 'bn', 'bs', 'ca', 'ceb', 'ckb', 'co', 'cs', 'cy', 'da', 'de', 'doi', 'dv', 'ee', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fr', 'fy', 'ga', 'gd', 'gl', 'gn', 'gom', 'gu', 'ha', 'haw', 'hi', 'hmn', 'hr', 'ht', 'hu', 'hy', 'id', 'ig', 'ilo', 'is', 'it', 'iw', 'ja', 'jw', 'ka', 'kk', 'km', 'kn', 'ko', 'kri', 'ku', 'ky', 'la', 'lb', 'lg', 'ln', 'lo', 'lt', 'lus', 'lv', 'mai', 'mg', 'mi', 'mk', 'ml', 'mn', 'mni-Mtei', 'mr', 'ms', 'mt', 'my', 'ne', 'nl', 'no', 'nso', 'ny', 'om', 'or', 'pa', 'pl', 'ps', 'pt', 'qu', 'ro', 'ru', 'rw', 'sa', 'sd', 'si', 'sk', 'sl', 'sm', 'sn', 'so', 'sq', 'sr', 'st', 'su', 'sv', 'sw', 'ta', 'te', 'tg', 'th', 'ti', 'tk', 'tl', 'tr', 'ts', 'tt', 'ug', 'uk', 'ur', 'uz', 'vi', 'xh', 'yi', 'yo', 'zh', 'zh-CN', 'zh-TW', 'zu'];
/**
 * Map with languages aliases.
 *
 * Google translator use legacy codes for some languages,
 * this map useful to use actual language codes by aliases
 *
 * @link https://xml.coverpages.org/iso639a.html
 */
const fixedLanguagesMap = fixedLanguagesMap_1 = languages.fixedLanguagesMap = {
  he: 'iw',
  jv: 'jw'
};
/**
 * Map ISO lang codes to google translator lang codes
 */
const languageAliases = languageAliases_1 = languages.languageAliases = new _LanguageAliases.LanguageAliases(supportedLanguages, {
  map: fixedLanguagesMap
});
/**
 * @param language language code or `auto`
 * @returns mapped language
 */
const getFixedLanguage = language => {
  var _a;
  return (_a = languageAliases.get(language)) !== null && _a !== void 0 ? _a : language;
};
var getFixedLanguage_1 = languages.getFixedLanguage = getFixedLanguage;

var token = {};

"use strict";

Object.defineProperty(token, "__esModule", {
  value: true
});
var getToken_1 = token.getToken = getToken;
// This file is generated, so eslint is not needed here
/* eslint-disable */
// TKK value from https://github.com/FilipePS/Traduzir-paginas-web/blob/f3a4956a1aa96b7a9124864158a5200827694521/background/translationService.js
const googleTranslateTKK = '448487.932609646';

//
// Obfuscated logic: START
//

function shiftLeftOrRightThenSumOrXor(num, optString) {
  for (let i = 0; i < optString.length - 2; i += 3) {
    let acc = optString.charAt(i + 2);
    if ('a' <= acc) {
      acc = acc.charCodeAt(0) - 87;
    } else {
      acc = Number(acc);
    }
    if (optString.charAt(i + 1) == '+') {
      acc = num >>> acc;
    } else {
      acc = num << acc;
    }
    if (optString.charAt(i) == '+') {
      num += acc & 4294967295;
    } else {
      num ^= acc;
    }
  }
  return num;
}
function transformQuery(query) {
  const bytesArray = [];
  let idx = [];
  for (let i = 0; i < query.length; i++) {
    let charCode = query.charCodeAt(i);
    if (128 > charCode) {
      bytesArray[idx++] = charCode;
    } else {
      if (2048 > charCode) {
        bytesArray[idx++] = charCode >> 6 | 192;
      } else {
        if (55296 == (charCode & 64512) && i + 1 < query.length && 56320 == (query.charCodeAt(i + 1) & 64512)) {
          charCode = 65536 + ((charCode & 1023) << 10) + (query.charCodeAt(++i) & 1023);
          bytesArray[idx++] = charCode >> 18 | 240;
          bytesArray[idx++] = charCode >> 12 & 63 | 128;
        } else {
          bytesArray[idx++] = charCode >> 12 | 224;
        }
        bytesArray[idx++] = charCode >> 6 & 63 | 128;
      }
      bytesArray[idx++] = charCode & 63 | 128;
    }
  }
  return bytesArray;
}
function calcHash(query, windowTkk) {
  const tkkSplited = windowTkk.split('.');
  const tkkIndex = Number(tkkSplited[0]) || 0;
  const tkkKey = Number(tkkSplited[1]) || 0;
  const bytesArray = transformQuery(query);
  let encondingRound = tkkIndex;
  for (let i = 0; i < bytesArray.length; i++) {
    encondingRound += bytesArray[i];
    encondingRound = shiftLeftOrRightThenSumOrXor(encondingRound, '+-a^+6');
  }
  encondingRound = shiftLeftOrRightThenSumOrXor(encondingRound, '+-3^+b+-f');
  encondingRound ^= tkkKey;
  if (encondingRound <= 0) {
    encondingRound = (encondingRound & 2147483647) + 2147483648;
  }
  const normalizedResult = encondingRound % 1000000;
  return normalizedResult.toString() + '.' + (normalizedResult ^ tkkIndex);
}

//
// Obfuscated logic: END
//

function getToken(query) {
  return new Promise(res => res({
    value: calcHash(query, googleTranslateTKK)
  }));
}

var utils = {};

var xpath$1 = {};

/*
 * xpath.js
 *
 * An XPath 1.0 library for JavaScript.
 *
 * Cameron McCormack <cam (at) mcc.id.au>
 *
 * This work is licensed under the MIT License.
 *
 * Revision 20: April 26, 2011
 *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,
 *   thanks to <shi_a009 (at) hotmail.com>.
 *
 * Revision 19: November 29, 2005
 *   Nodesets now store their nodes in a height balanced tree, increasing
 *   performance for the common case of selecting nodes in document order,
 *   thanks to Sébastien Cramatte <contact (at) zeninteractif.com>.
 *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.
 *
 * Revision 18: October 27, 2005
 *   DOM 3 XPath support.  Caveats:
 *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,
 *       but in XPathExpression.evaluate.
 *     - XPathResult.invalidIteratorState is not implemented.
 *
 * Revision 17: October 25, 2005
 *   Some core XPath function fixes and a patch to avoid crashing certain
 *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to
 *   Sébastien Cramatte <contact (at) zeninteractif.com>.
 *
 * Revision 16: September 22, 2005
 *   Workarounds for some IE 5.5 deficiencies.
 *   Fixed problem with prefix node tests on attribute nodes.
 *
 * Revision 15: May 21, 2005
 *   Fixed problem with QName node tests on elements with an xmlns="...".
 *
 * Revision 14: May 19, 2005
 *   Fixed QName node tests on attribute node regression.
 *
 * Revision 13: May 3, 2005
 *   Node tests are case insensitive now if working in an HTML DOM.
 *
 * Revision 12: April 26, 2005
 *   Updated licence.  Slight code changes to enable use of Dean
 *   Edwards' script compression, http://dean.edwards.name/packer/ .
 *
 * Revision 11: April 23, 2005
 *   Fixed bug with 'and' and 'or' operators, fix thanks to
 *   Sandy McArthur <sandy (at) mcarthur.org>.
 *
 * Revision 10: April 15, 2005
 *   Added support for a virtual root node, supposedly helpful for
 *   implementing XForms.  Fixed problem with QName node tests and
 *   the parent axis.
 *
 * Revision 9: March 17, 2005
 *   Namespace resolver tweaked so using the document node as the context
 *   for namespace lookups is equivalent to using the document element.
 *
 * Revision 8: February 13, 2005
 *   Handle implicit declaration of 'xmlns' namespace prefix.
 *   Fixed bug when comparing nodesets.
 *   Instance data can now be associated with a FunctionResolver, and
 *     workaround for MSXML not supporting 'localName' and 'getElementById',
 *     thanks to Grant Gongaware.
 *   Fix a few problems when the context node is the root node.
 *
 * Revision 7: February 11, 2005
 *   Default namespace resolver fix from Grant Gongaware
 *   <grant (at) gongaware.com>.
 *
 * Revision 6: February 10, 2005
 *   Fixed bug in 'number' function.
 *
 * Revision 5: February 9, 2005
 *   Fixed bug where text nodes not getting converted to string values.
 *
 * Revision 4: January 21, 2005
 *   Bug in 'name' function, fix thanks to Bill Edney.
 *   Fixed incorrect processing of namespace nodes.
 *   Fixed NamespaceResolver to resolve 'xml' namespace.
 *   Implemented union '|' operator.
 *
 * Revision 3: January 14, 2005
 *   Fixed bug with nodeset comparisons, bug lexing < and >.
 *
 * Revision 2: October 26, 2004
 *   QName node test namespace handling fixed.  Few other bug fixes.
 *
 * Revision 1: August 13, 2004
 *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.
 *   Added minimal licence.
 *
 * Initial version: June 14, 2004
 */

(function (exports) {
	// non-node wrapper
	var xpath = ('object' === 'undefined') ? {} : exports;

	(function (exports) {
	    "use strict";

	    // namespace nodes are not part of the DOM spec, so we use a custom nodetype for them.
	    // should NOT be used externally
	    var NAMESPACE_NODE_NODETYPE = '__namespace';

	    var isNil = function (x) {
	        return x === null || x === undefined;
	    };

	    var isValidNodeType = function (nodeType) {
	        return nodeType === NAMESPACE_NODE_NODETYPE ||
	            (Number.isInteger(nodeType)
	                && nodeType >= 1
	                && nodeType <= 11
	            );
	    };

	    var isNodeLike = function (value) {
	        return value
	            && isValidNodeType(value.nodeType)
	            && typeof value.nodeName === "string";
	    };

	    // functional helpers
	    function curry(func) {
	        var slice = Array.prototype.slice,
	            totalargs = func.length,
	            partial = function (args, fn) {
	                return function () {
	                    return fn.apply(this, args.concat(slice.call(arguments)));
	                }
	            },
	            fn = function () {
	                var args = slice.call(arguments);
	                return (args.length < totalargs) ?
	                    partial(args, fn) :
	                    func.apply(this, slice.apply(arguments, [0, totalargs]));
	            };
	        return fn;
	    }

	    var forEach = function (f, xs) {
	        for (var i = 0; i < xs.length; i += 1) {
	            f(xs[i], i, xs);
	        }
	    };

	    var reduce = function (f, seed, xs) {
	        var acc = seed;

	        forEach(function (x, i) { acc = f(acc, x, i); }, xs);

	        return acc;
	    };

	    var map = function (f, xs) {
	        var mapped = new Array(xs.length);

	        forEach(function (x, i) { mapped[i] = f(x); }, xs);

	        return mapped;
	    };

	    var filter = function (f, xs) {
	        var filtered = [];

	        forEach(function (x, i) { if (f(x, i)) { filtered.push(x); } }, xs);

	        return filtered;
	    };

	    var includes = function (values, value) {
	        for (var i = 0; i < values.length; i += 1) {
	            if (values[i] === value) {
	                return true;
	            }
	        }

	        return false;
	    };

	    function always(value) { return function () { return value; } }

	    function toString(x) { return x.toString(); }
	    var join = function (s, xs) { return xs.join(s); };
	    var wrap = function (pref, suf, str) { return pref + str + suf; };

	    var prototypeConcat = Array.prototype.concat;

	    var sortNodes = function (nodes, reverse) {
	        var ns = new XNodeSet();

	        ns.addArray(nodes);

	        var sorted = ns.toArray();

	        return reverse ? sorted.reverse() : sorted;
	    };

	    // .apply() fails above a certain number of arguments - https://github.com/goto100/xpath/pull/98
	    var MAX_ARGUMENT_LENGTH = 32767;

	    function flatten(arr) {
	        var result = [];

	        for (var start = 0; start < arr.length; start += MAX_ARGUMENT_LENGTH) {
	            var chunk = arr.slice(start, start + MAX_ARGUMENT_LENGTH);

	            result = prototypeConcat.apply(result, chunk);
	        }

	        return result;
	    }

	    function assign(target, varArgs) { // .length of function is 2
	        var to = Object(target);

	        for (var index = 1; index < arguments.length; index++) {
	            var nextSource = arguments[index];

	            if (nextSource != null) { // Skip over if undefined or null
	                for (var nextKey in nextSource) {
	                    // Avoid bugs when hasOwnProperty is shadowed
	                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
	                        to[nextKey] = nextSource[nextKey];
	                    }
	                }
	            }
	        }

	        return to;
	    }

	    var NodeTypes = {
	        ELEMENT_NODE: 1,
	        ATTRIBUTE_NODE: 2,
	        TEXT_NODE: 3,
	        CDATA_SECTION_NODE: 4,
	        PROCESSING_INSTRUCTION_NODE: 7,
	        COMMENT_NODE: 8,
	        DOCUMENT_NODE: 9,
	        DOCUMENT_TYPE_NODE: 10,
	        DOCUMENT_FRAGMENT_NODE: 11,
	        NAMESPACE_NODE: NAMESPACE_NODE_NODETYPE,
	    };

	    // XPathParser ///////////////////////////////////////////////////////////////

	    XPathParser.prototype = new Object();
	    XPathParser.prototype.constructor = XPathParser;
	    XPathParser.superclass = Object.prototype;

	    function XPathParser() {
	        this.init();
	    }

	    XPathParser.prototype.init = function () {
	        this.reduceActions = [];

	        this.reduceActions[3] = function (rhs) {
	            return new OrOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[5] = function (rhs) {
	            return new AndOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[7] = function (rhs) {
	            return new EqualsOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[8] = function (rhs) {
	            return new NotEqualOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[10] = function (rhs) {
	            return new LessThanOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[11] = function (rhs) {
	            return new GreaterThanOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[12] = function (rhs) {
	            return new LessThanOrEqualOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[13] = function (rhs) {
	            return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[15] = function (rhs) {
	            return new PlusOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[16] = function (rhs) {
	            return new MinusOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[18] = function (rhs) {
	            return new MultiplyOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[19] = function (rhs) {
	            return new DivOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[20] = function (rhs) {
	            return new ModOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[22] = function (rhs) {
	            return new UnaryMinusOperation(rhs[1]);
	        };
	        this.reduceActions[24] = function (rhs) {
	            return new BarOperation(rhs[0], rhs[2]);
	        };
	        this.reduceActions[25] = function (rhs) {
	            return new PathExpr(undefined, undefined, rhs[0]);
	        };
	        this.reduceActions[27] = function (rhs) {
	            rhs[0].locationPath = rhs[2];
	            return rhs[0];
	        };
	        this.reduceActions[28] = function (rhs) {
	            rhs[0].locationPath = rhs[2];
	            rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
	            return rhs[0];
	        };
	        this.reduceActions[29] = function (rhs) {
	            return new PathExpr(rhs[0], [], undefined);
	        };
	        this.reduceActions[30] = function (rhs) {
	            if (Utilities.instance_of(rhs[0], PathExpr)) {
	                if (rhs[0].filterPredicates == undefined) {
	                    rhs[0].filterPredicates = [];
	                }
	                rhs[0].filterPredicates.push(rhs[1]);
	                return rhs[0];
	            } else {
	                return new PathExpr(rhs[0], [rhs[1]], undefined);
	            }
	        };
	        this.reduceActions[32] = function (rhs) {
	            return rhs[1];
	        };
	        this.reduceActions[33] = function (rhs) {
	            return new XString(rhs[0]);
	        };
	        this.reduceActions[34] = function (rhs) {
	            return new XNumber(rhs[0]);
	        };
	        this.reduceActions[36] = function (rhs) {
	            return new FunctionCall(rhs[0], []);
	        };
	        this.reduceActions[37] = function (rhs) {
	            return new FunctionCall(rhs[0], rhs[2]);
	        };
	        this.reduceActions[38] = function (rhs) {
	            return [rhs[0]];
	        };
	        this.reduceActions[39] = function (rhs) {
	            rhs[2].unshift(rhs[0]);
	            return rhs[2];
	        };
	        this.reduceActions[43] = function (rhs) {
	            return new LocationPath(true, []);
	        };
	        this.reduceActions[44] = function (rhs) {
	            rhs[1].absolute = true;
	            return rhs[1];
	        };
	        this.reduceActions[46] = function (rhs) {
	            return new LocationPath(false, [rhs[0]]);
	        };
	        this.reduceActions[47] = function (rhs) {
	            rhs[0].steps.push(rhs[2]);
	            return rhs[0];
	        };
	        this.reduceActions[49] = function (rhs) {
	            return new Step(rhs[0], rhs[1], []);
	        };
	        this.reduceActions[50] = function (rhs) {
	            return new Step(Step.CHILD, rhs[0], []);
	        };
	        this.reduceActions[51] = function (rhs) {
	            return new Step(rhs[0], rhs[1], rhs[2]);
	        };
	        this.reduceActions[52] = function (rhs) {
	            return new Step(Step.CHILD, rhs[0], rhs[1]);
	        };
	        this.reduceActions[54] = function (rhs) {
	            return [rhs[0]];
	        };
	        this.reduceActions[55] = function (rhs) {
	            rhs[1].unshift(rhs[0]);
	            return rhs[1];
	        };
	        this.reduceActions[56] = function (rhs) {
	            if (rhs[0] == "ancestor") {
	                return Step.ANCESTOR;
	            } else if (rhs[0] == "ancestor-or-self") {
	                return Step.ANCESTORORSELF;
	            } else if (rhs[0] == "attribute") {
	                return Step.ATTRIBUTE;
	            } else if (rhs[0] == "child") {
	                return Step.CHILD;
	            } else if (rhs[0] == "descendant") {
	                return Step.DESCENDANT;
	            } else if (rhs[0] == "descendant-or-self") {
	                return Step.DESCENDANTORSELF;
	            } else if (rhs[0] == "following") {
	                return Step.FOLLOWING;
	            } else if (rhs[0] == "following-sibling") {
	                return Step.FOLLOWINGSIBLING;
	            } else if (rhs[0] == "namespace") {
	                return Step.NAMESPACE;
	            } else if (rhs[0] == "parent") {
	                return Step.PARENT;
	            } else if (rhs[0] == "preceding") {
	                return Step.PRECEDING;
	            } else if (rhs[0] == "preceding-sibling") {
	                return Step.PRECEDINGSIBLING;
	            } else if (rhs[0] == "self") {
	                return Step.SELF;
	            }
	            return -1;
	        };
	        this.reduceActions[57] = function (rhs) {
	            return Step.ATTRIBUTE;
	        };
	        this.reduceActions[59] = function (rhs) {
	            if (rhs[0] == "comment") {
	                return NodeTest.commentTest;
	            } else if (rhs[0] == "text") {
	                return NodeTest.textTest;
	            } else if (rhs[0] == "processing-instruction") {
	                return NodeTest.anyPiTest;
	            } else if (rhs[0] == "node") {
	                return NodeTest.nodeTest;
	            }
	            return new NodeTest(-1, undefined);
	        };
	        this.reduceActions[60] = function (rhs) {
	            return new NodeTest.PITest(rhs[2]);
	        };
	        this.reduceActions[61] = function (rhs) {
	            return rhs[1];
	        };
	        this.reduceActions[63] = function (rhs) {
	            rhs[1].absolute = true;
	            rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
	            return rhs[1];
	        };
	        this.reduceActions[64] = function (rhs) {
	            rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
	            rhs[0].steps.push(rhs[2]);
	            return rhs[0];
	        };
	        this.reduceActions[65] = function (rhs) {
	            return new Step(Step.SELF, NodeTest.nodeTest, []);
	        };
	        this.reduceActions[66] = function (rhs) {
	            return new Step(Step.PARENT, NodeTest.nodeTest, []);
	        };
	        this.reduceActions[67] = function (rhs) {
	            return new VariableReference(rhs[1]);
	        };
	        this.reduceActions[68] = function (rhs) {
	            return NodeTest.nameTestAny;
	        };
	        this.reduceActions[69] = function (rhs) {
	            return new NodeTest.NameTestPrefixAny(rhs[0].split(':')[0]);
	        };
	        this.reduceActions[70] = function (rhs) {
	            return new NodeTest.NameTestQName(rhs[0]);
	        };
	    };

	    XPathParser.actionTable = [
	        " s s        sssssssss    s ss  s  ss",
	        "                 s                  ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "                rrrrr               ",
	        " s s        sssssssss    s ss  s  ss",
	        "rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
	        " s s        sssssssss    s ss  s  ss",
	        "                            s       ",
	        "                            s       ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "  s                                 ",
	        "                            s       ",
	        " s           s  sssss          s  s ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "a                                   ",
	        "r       s                    rr  r  ",
	        "r      sr                    rr  r  ",
	        "r   s  rr            s       rr  r  ",
	        "r   rssrr            rss     rr  r  ",
	        "r   rrrrr            rrrss   rr  r  ",
	        "r   rrrrrsss         rrrrr   rr  r  ",
	        "r   rrrrrrrr         rrrrr   rr  r  ",
	        "r   rrrrrrrr         rrrrrs  rr  r  ",
	        "r   rrrrrrrr         rrrrrr  rr  r  ",
	        "r   rrrrrrrr         rrrrrr  rr  r  ",
	        "r  srrrrrrrr         rrrrrrs rr sr  ",
	        "r  srrrrrrrr         rrrrrrs rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r   rrrrrrrr         rrrrrr  rr  r  ",
	        "r   rrrrrrrr         rrrrrr  rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "                sssss               ",
	        "r  rrrrrrrrr         rrrrrrr rr sr  ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "                             s      ",
	        "r  srrrrrrrr         rrrrrrs rr  r  ",
	        "r   rrrrrrrr         rrrrr   rr  r  ",
	        "              s                     ",
	        "                             s      ",
	        "                rrrrr               ",
	        " s s        sssssssss    s sss s  ss",
	        "r  srrrrrrrr         rrrrrrs rr  r  ",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s s        sssssssss      ss  s  ss",
	        " s s        sssssssss    s ss  s  ss",
	        " s           s  sssss          s  s ",
	        " s           s  sssss          s  s ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        " s           s  sssss          s  s ",
	        " s           s  sssss          s  s ",
	        "r  rrrrrrrrr         rrrrrrr rr sr  ",
	        "r  rrrrrrrrr         rrrrrrr rr sr  ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "                             s      ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "                             rr     ",
	        "                             s      ",
	        "                             rs     ",
	        "r      sr                    rr  r  ",
	        "r   s  rr            s       rr  r  ",
	        "r   rssrr            rss     rr  r  ",
	        "r   rssrr            rss     rr  r  ",
	        "r   rrrrr            rrrss   rr  r  ",
	        "r   rrrrr            rrrss   rr  r  ",
	        "r   rrrrr            rrrss   rr  r  ",
	        "r   rrrrr            rrrss   rr  r  ",
	        "r   rrrrrsss         rrrrr   rr  r  ",
	        "r   rrrrrsss         rrrrr   rr  r  ",
	        "r   rrrrrrrr         rrrrr   rr  r  ",
	        "r   rrrrrrrr         rrrrr   rr  r  ",
	        "r   rrrrrrrr         rrrrr   rr  r  ",
	        "r   rrrrrrrr         rrrrrr  rr  r  ",
	        "                                 r  ",
	        "                                 s  ",
	        "r  srrrrrrrr         rrrrrrs rr  r  ",
	        "r  srrrrrrrr         rrrrrrs rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr  r  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        " s s        sssssssss    s ss  s  ss",
	        "r  rrrrrrrrr         rrrrrrr rr rr  ",
	        "                             r      "
	    ];

	    XPathParser.actionTableNumber = [
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        "                 J                  ",
	        "a  aaaaaaaaa         aaaaaaa aa  a  ",
	        "                YYYYY               ",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        "K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        "                            N       ",
	        "                            O       ",
	        "e  eeeeeeeee         eeeeeee ee ee  ",
	        "f  fffffffff         fffffff ff ff  ",
	        "d  ddddddddd         ddddddd dd dd  ",
	        "B  BBBBBBBBB         BBBBBBB BB BB  ",
	        "A  AAAAAAAAA         AAAAAAA AA AA  ",
	        "  P                                 ",
	        "                            Q       ",
	        " 1           .  +*)('          #  \" ",
	        "b  bbbbbbbbb         bbbbbbb bb  b  ",
	        "                                    ",
	        "!       S                    !!  !  ",
	        "\"      T\"                    \"\"  \"  ",
	        "$   V  $$            U       $$  $  ",
	        "&   &ZY&&            &XW     &&  &  ",
	        ")   )))))            )))\\[   ))  )  ",
	        ".   ....._^]         .....   ..  .  ",
	        "1   11111111         11111   11  1  ",
	        "5   55555555         55555`  55  5  ",
	        "7   77777777         777777  77  7  ",
	        "9   99999999         999999  99  9  ",
	        ":  c::::::::         ::::::b :: a:  ",
	        "I  fIIIIIIII         IIIIIIe II  I  ",
	        "=  =========         ======= == ==  ",
	        "?  ?????????         ??????? ?? ??  ",
	        "C  CCCCCCCCC         CCCCCCC CC CC  ",
	        "J   JJJJJJJJ         JJJJJJ  JJ  J  ",
	        "M   MMMMMMMM         MMMMMM  MM  M  ",
	        "N  NNNNNNNNN         NNNNNNN NN  N  ",
	        "P  PPPPPPPPP         PPPPPPP PP  P  ",
	        "                +*)('               ",
	        "R  RRRRRRRRR         RRRRRRR RR aR  ",
	        "U  UUUUUUUUU         UUUUUUU UU  U  ",
	        "Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
	        "c  ccccccccc         ccccccc cc cc  ",
	        "                             j      ",
	        "L  fLLLLLLLL         LLLLLLe LL  L  ",
	        "6   66666666         66666   66  6  ",
	        "              k                     ",
	        "                             l      ",
	        "                XXXXX               ",
	        " 1 0        /.-,+*)('    & %$m #  \"!",
	        "_  f________         ______e __  _  ",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1 0        /.-,+*)('      %$  #  \"!",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        " 1           .  +*)('          #  \" ",
	        " 1           .  +*)('          #  \" ",
	        ">  >>>>>>>>>         >>>>>>> >> >>  ",
	        " 1           .  +*)('          #  \" ",
	        " 1           .  +*)('          #  \" ",
	        "Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
	        "V  VVVVVVVVV         VVVVVVV VV aV  ",
	        "T  TTTTTTTTT         TTTTTTT TT  T  ",
	        "@  @@@@@@@@@         @@@@@@@ @@ @@  ",
	        "                             \x87      ",
	        "[  [[[[[[[[[         [[[[[[[ [[ [[  ",
	        "D  DDDDDDDDD         DDDDDDD DD DD  ",
	        "                             HH     ",
	        "                             \x88      ",
	        "                             F\x89     ",
	        "#      T#                    ##  #  ",
	        "%   V  %%            U       %%  %  ",
	        "'   'ZY''            'XW     ''  '  ",
	        "(   (ZY((            (XW     ((  (  ",
	        "+   +++++            +++\\[   ++  +  ",
	        "*   *****            ***\\[   **  *  ",
	        "-   -----            ---\\[   --  -  ",
	        ",   ,,,,,            ,,,\\[   ,,  ,  ",
	        "0   00000_^]         00000   00  0  ",
	        "/   /////_^]         /////   //  /  ",
	        "2   22222222         22222   22  2  ",
	        "3   33333333         33333   33  3  ",
	        "4   44444444         44444   44  4  ",
	        "8   88888888         888888  88  8  ",
	        "                                 ^  ",
	        "                                 \x8a  ",
	        ";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
	        "<  f<<<<<<<<         <<<<<<e <<  <  ",
	        "O  OOOOOOOOO         OOOOOOO OO  O  ",
	        "`  `````````         ``````` ``  `  ",
	        "S  SSSSSSSSS         SSSSSSS SS  S  ",
	        "W  WWWWWWWWW         WWWWWWW WW  W  ",
	        "\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
	        "E  EEEEEEEEE         EEEEEEE EE EE  ",
	        " 1 0        /.-,+*)('    & %$  #  \"!",
	        "]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
	        "                             G      "
	    ];

	    XPathParser.gotoTable = [
	        "3456789:;<=>?@ AB  CDEFGH IJ ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "L456789:;<=>?@ AB  CDEFGH IJ ",
	        "            M        EFGH IJ ",
	        "       N;<=>?@ AB  CDEFGH IJ ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "            S        EFGH IJ ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "              e              ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                        h  J ",
	        "              i          j   ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "o456789:;<=>?@ ABpqCDEFGH IJ ",
	        "                             ",
	        "  r6789:;<=>?@ AB  CDEFGH IJ ",
	        "   s789:;<=>?@ AB  CDEFGH IJ ",
	        "    t89:;<=>?@ AB  CDEFGH IJ ",
	        "    u89:;<=>?@ AB  CDEFGH IJ ",
	        "     v9:;<=>?@ AB  CDEFGH IJ ",
	        "     w9:;<=>?@ AB  CDEFGH IJ ",
	        "     x9:;<=>?@ AB  CDEFGH IJ ",
	        "     y9:;<=>?@ AB  CDEFGH IJ ",
	        "      z:;<=>?@ AB  CDEFGH IJ ",
	        "      {:;<=>?@ AB  CDEFGH IJ ",
	        "       |;<=>?@ AB  CDEFGH IJ ",
	        "       };<=>?@ AB  CDEFGH IJ ",
	        "       ~;<=>?@ AB  CDEFGH IJ ",
	        "         \x7f=>?@ AB  CDEFGH IJ ",
	        "\x80456789:;<=>?@ AB  CDEFGH IJ\x81",
	        "            \x82        EFGH IJ ",
	        "            \x83        EFGH IJ ",
	        "                             ",
	        "                     \x84 GH IJ ",
	        "                     \x85 GH IJ ",
	        "              i          \x86   ",
	        "              i          \x87   ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "                             ",
	        "o456789:;<=>?@ AB\x8cqCDEFGH IJ ",
	        "                             ",
	        "                             "
	    ];

	    XPathParser.productions = [
	        [1, 1, 2],
	        [2, 1, 3],
	        [3, 1, 4],
	        [3, 3, 3, -9, 4],
	        [4, 1, 5],
	        [4, 3, 4, -8, 5],
	        [5, 1, 6],
	        [5, 3, 5, -22, 6],
	        [5, 3, 5, -5, 6],
	        [6, 1, 7],
	        [6, 3, 6, -23, 7],
	        [6, 3, 6, -24, 7],
	        [6, 3, 6, -6, 7],
	        [6, 3, 6, -7, 7],
	        [7, 1, 8],
	        [7, 3, 7, -25, 8],
	        [7, 3, 7, -26, 8],
	        [8, 1, 9],
	        [8, 3, 8, -12, 9],
	        [8, 3, 8, -11, 9],
	        [8, 3, 8, -10, 9],
	        [9, 1, 10],
	        [9, 2, -26, 9],
	        [10, 1, 11],
	        [10, 3, 10, -27, 11],
	        [11, 1, 12],
	        [11, 1, 13],
	        [11, 3, 13, -28, 14],
	        [11, 3, 13, -4, 14],
	        [13, 1, 15],
	        [13, 2, 13, 16],
	        [15, 1, 17],
	        [15, 3, -29, 2, -30],
	        [15, 1, -15],
	        [15, 1, -16],
	        [15, 1, 18],
	        [18, 3, -13, -29, -30],
	        [18, 4, -13, -29, 19, -30],
	        [19, 1, 20],
	        [19, 3, 20, -31, 19],
	        [20, 1, 2],
	        [12, 1, 14],
	        [12, 1, 21],
	        [21, 1, -28],
	        [21, 2, -28, 14],
	        [21, 1, 22],
	        [14, 1, 23],
	        [14, 3, 14, -28, 23],
	        [14, 1, 24],
	        [23, 2, 25, 26],
	        [23, 1, 26],
	        [23, 3, 25, 26, 27],
	        [23, 2, 26, 27],
	        [23, 1, 28],
	        [27, 1, 16],
	        [27, 2, 16, 27],
	        [25, 2, -14, -3],
	        [25, 1, -32],
	        [26, 1, 29],
	        [26, 3, -20, -29, -30],
	        [26, 4, -21, -29, -15, -30],
	        [16, 3, -33, 30, -34],
	        [30, 1, 2],
	        [22, 2, -4, 14],
	        [24, 3, 14, -4, 23],
	        [28, 1, -35],
	        [28, 1, -2],
	        [17, 2, -36, -18],
	        [29, 1, -17],
	        [29, 1, -19],
	        [29, 1, -18]
	    ];

	    XPathParser.DOUBLEDOT = 2;
	    XPathParser.DOUBLECOLON = 3;
	    XPathParser.DOUBLESLASH = 4;
	    XPathParser.NOTEQUAL = 5;
	    XPathParser.LESSTHANOREQUAL = 6;
	    XPathParser.GREATERTHANOREQUAL = 7;
	    XPathParser.AND = 8;
	    XPathParser.OR = 9;
	    XPathParser.MOD = 10;
	    XPathParser.DIV = 11;
	    XPathParser.MULTIPLYOPERATOR = 12;
	    XPathParser.FUNCTIONNAME = 13;
	    XPathParser.AXISNAME = 14;
	    XPathParser.LITERAL = 15;
	    XPathParser.NUMBER = 16;
	    XPathParser.ASTERISKNAMETEST = 17;
	    XPathParser.QNAME = 18;
	    XPathParser.NCNAMECOLONASTERISK = 19;
	    XPathParser.NODETYPE = 20;
	    XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
	    XPathParser.EQUALS = 22;
	    XPathParser.LESSTHAN = 23;
	    XPathParser.GREATERTHAN = 24;
	    XPathParser.PLUS = 25;
	    XPathParser.MINUS = 26;
	    XPathParser.BAR = 27;
	    XPathParser.SLASH = 28;
	    XPathParser.LEFTPARENTHESIS = 29;
	    XPathParser.RIGHTPARENTHESIS = 30;
	    XPathParser.COMMA = 31;
	    XPathParser.AT = 32;
	    XPathParser.LEFTBRACKET = 33;
	    XPathParser.RIGHTBRACKET = 34;
	    XPathParser.DOT = 35;
	    XPathParser.DOLLAR = 36;

	    XPathParser.prototype.tokenize = function (s1) {
	        var types = [];
	        var values = [];
	        var s = s1 + '\0';

	        var pos = 0;
	        var c = s.charAt(pos++);
	        while (1) {
	            while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
	                c = s.charAt(pos++);
	            }
	            if (c == '\0' || pos >= s.length) {
	                break;
	            }

	            if (c == '(') {
	                types.push(XPathParser.LEFTPARENTHESIS);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == ')') {
	                types.push(XPathParser.RIGHTPARENTHESIS);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == '[') {
	                types.push(XPathParser.LEFTBRACKET);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == ']') {
	                types.push(XPathParser.RIGHTBRACKET);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == '@') {
	                types.push(XPathParser.AT);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == ',') {
	                types.push(XPathParser.COMMA);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == '|') {
	                types.push(XPathParser.BAR);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == '+') {
	                types.push(XPathParser.PLUS);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == '-') {
	                types.push(XPathParser.MINUS);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == '=') {
	                types.push(XPathParser.EQUALS);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }
	            if (c == '$') {
	                types.push(XPathParser.DOLLAR);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }

	            if (c == '.') {
	                c = s.charAt(pos++);
	                if (c == '.') {
	                    types.push(XPathParser.DOUBLEDOT);
	                    values.push("..");
	                    c = s.charAt(pos++);
	                    continue;
	                }
	                if (c >= '0' && c <= '9') {
	                    var number = "." + c;
	                    c = s.charAt(pos++);
	                    while (c >= '0' && c <= '9') {
	                        number += c;
	                        c = s.charAt(pos++);
	                    }
	                    types.push(XPathParser.NUMBER);
	                    values.push(number);
	                    continue;
	                }
	                types.push(XPathParser.DOT);
	                values.push('.');
	                continue;
	            }

	            if (c == '\'' || c == '"') {
	                var delimiter = c;
	                var literal = "";
	                while (pos < s.length && (c = s.charAt(pos)) !== delimiter) {
	                    literal += c;
	                    pos += 1;
	                }
	                if (c !== delimiter) {
	                    throw XPathException.fromMessage("Unterminated string literal: " + delimiter + literal);
	                }
	                pos += 1;
	                types.push(XPathParser.LITERAL);
	                values.push(literal);
	                c = s.charAt(pos++);
	                continue;
	            }

	            if (c >= '0' && c <= '9') {
	                var number = c;
	                c = s.charAt(pos++);
	                while (c >= '0' && c <= '9') {
	                    number += c;
	                    c = s.charAt(pos++);
	                }
	                if (c == '.') {
	                    if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
	                        number += c;
	                        number += s.charAt(pos++);
	                        c = s.charAt(pos++);
	                        while (c >= '0' && c <= '9') {
	                            number += c;
	                            c = s.charAt(pos++);
	                        }
	                    }
	                }
	                types.push(XPathParser.NUMBER);
	                values.push(number);
	                continue;
	            }

	            if (c == '*') {
	                if (types.length > 0) {
	                    var last = types[types.length - 1];
	                    if (last != XPathParser.AT
	                        && last != XPathParser.DOUBLECOLON
	                        && last != XPathParser.LEFTPARENTHESIS
	                        && last != XPathParser.LEFTBRACKET
	                        && last != XPathParser.AND
	                        && last != XPathParser.OR
	                        && last != XPathParser.MOD
	                        && last != XPathParser.DIV
	                        && last != XPathParser.MULTIPLYOPERATOR
	                        && last != XPathParser.SLASH
	                        && last != XPathParser.DOUBLESLASH
	                        && last != XPathParser.BAR
	                        && last != XPathParser.PLUS
	                        && last != XPathParser.MINUS
	                        && last != XPathParser.EQUALS
	                        && last != XPathParser.NOTEQUAL
	                        && last != XPathParser.LESSTHAN
	                        && last != XPathParser.LESSTHANOREQUAL
	                        && last != XPathParser.GREATERTHAN
	                        && last != XPathParser.GREATERTHANOREQUAL) {
	                        types.push(XPathParser.MULTIPLYOPERATOR);
	                        values.push(c);
	                        c = s.charAt(pos++);
	                        continue;
	                    }
	                }
	                types.push(XPathParser.ASTERISKNAMETEST);
	                values.push(c);
	                c = s.charAt(pos++);
	                continue;
	            }

	            if (c == ':') {
	                if (s.charAt(pos) == ':') {
	                    types.push(XPathParser.DOUBLECOLON);
	                    values.push("::");
	                    pos++;
	                    c = s.charAt(pos++);
	                    continue;
	                }
	            }

	            if (c == '/') {
	                c = s.charAt(pos++);
	                if (c == '/') {
	                    types.push(XPathParser.DOUBLESLASH);
	                    values.push("//");
	                    c = s.charAt(pos++);
	                    continue;
	                }
	                types.push(XPathParser.SLASH);
	                values.push('/');
	                continue;
	            }

	            if (c == '!') {
	                if (s.charAt(pos) == '=') {
	                    types.push(XPathParser.NOTEQUAL);
	                    values.push("!=");
	                    pos++;
	                    c = s.charAt(pos++);
	                    continue;
	                }
	            }

	            if (c == '<') {
	                if (s.charAt(pos) == '=') {
	                    types.push(XPathParser.LESSTHANOREQUAL);
	                    values.push("<=");
	                    pos++;
	                    c = s.charAt(pos++);
	                    continue;
	                }
	                types.push(XPathParser.LESSTHAN);
	                values.push('<');
	                c = s.charAt(pos++);
	                continue;
	            }

	            if (c == '>') {
	                if (s.charAt(pos) == '=') {
	                    types.push(XPathParser.GREATERTHANOREQUAL);
	                    values.push(">=");
	                    pos++;
	                    c = s.charAt(pos++);
	                    continue;
	                }
	                types.push(XPathParser.GREATERTHAN);
	                values.push('>');
	                c = s.charAt(pos++);
	                continue;
	            }

	            if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {
	                var name = c;
	                c = s.charAt(pos++);
	                while (Utilities.isNCNameChar(c.charCodeAt(0))) {
	                    name += c;
	                    c = s.charAt(pos++);
	                }
	                if (types.length > 0) {
	                    var last = types[types.length - 1];
	                    if (last != XPathParser.AT
	                        && last != XPathParser.DOUBLECOLON
	                        && last != XPathParser.LEFTPARENTHESIS
	                        && last != XPathParser.LEFTBRACKET
	                        && last != XPathParser.AND
	                        && last != XPathParser.OR
	                        && last != XPathParser.MOD
	                        && last != XPathParser.DIV
	                        && last != XPathParser.MULTIPLYOPERATOR
	                        && last != XPathParser.SLASH
	                        && last != XPathParser.DOUBLESLASH
	                        && last != XPathParser.BAR
	                        && last != XPathParser.PLUS
	                        && last != XPathParser.MINUS
	                        && last != XPathParser.EQUALS
	                        && last != XPathParser.NOTEQUAL
	                        && last != XPathParser.LESSTHAN
	                        && last != XPathParser.LESSTHANOREQUAL
	                        && last != XPathParser.GREATERTHAN
	                        && last != XPathParser.GREATERTHANOREQUAL) {
	                        if (name == "and") {
	                            types.push(XPathParser.AND);
	                            values.push(name);
	                            continue;
	                        }
	                        if (name == "or") {
	                            types.push(XPathParser.OR);
	                            values.push(name);
	                            continue;
	                        }
	                        if (name == "mod") {
	                            types.push(XPathParser.MOD);
	                            values.push(name);
	                            continue;
	                        }
	                        if (name == "div") {
	                            types.push(XPathParser.DIV);
	                            values.push(name);
	                            continue;
	                        }
	                    }
	                }
	                if (c == ':') {
	                    if (s.charAt(pos) == '*') {
	                        types.push(XPathParser.NCNAMECOLONASTERISK);
	                        values.push(name + ":*");
	                        pos++;
	                        c = s.charAt(pos++);
	                        continue;
	                    }
	                    if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {
	                        name += ':';
	                        c = s.charAt(pos++);
	                        while (Utilities.isNCNameChar(c.charCodeAt(0))) {
	                            name += c;
	                            c = s.charAt(pos++);
	                        }
	                        if (c == '(') {
	                            types.push(XPathParser.FUNCTIONNAME);
	                            values.push(name);
	                            continue;
	                        }
	                        types.push(XPathParser.QNAME);
	                        values.push(name);
	                        continue;
	                    }
	                    if (s.charAt(pos) == ':') {
	                        types.push(XPathParser.AXISNAME);
	                        values.push(name);
	                        continue;
	                    }
	                }
	                if (c == '(') {
	                    if (name == "comment" || name == "text" || name == "node") {
	                        types.push(XPathParser.NODETYPE);
	                        values.push(name);
	                        continue;
	                    }
	                    if (name == "processing-instruction") {
	                        if (s.charAt(pos) == ')') {
	                            types.push(XPathParser.NODETYPE);
	                        } else {
	                            types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
	                        }
	                        values.push(name);
	                        continue;
	                    }
	                    types.push(XPathParser.FUNCTIONNAME);
	                    values.push(name);
	                    continue;
	                }
	                types.push(XPathParser.QNAME);
	                values.push(name);
	                continue;
	            }

	            throw new Error("Unexpected character " + c);
	        }
	        types.push(1);
	        values.push("[EOF]");
	        return [types, values];
	    };

	    XPathParser.SHIFT = 's';
	    XPathParser.REDUCE = 'r';
	    XPathParser.ACCEPT = 'a';

	    XPathParser.prototype.parse = function (s) {
	        if (!s) {
	            throw new Error('XPath expression unspecified.');
	        }
	        if (typeof s !== 'string'){
	            throw new Error('XPath expression must be a string.');
	        }

	        var types;
	        var values;
	        var res = this.tokenize(s);
	        if (res == undefined) {
	            return undefined;
	        }
	        types = res[0];
	        values = res[1];
	        var tokenPos = 0;
	        var state = [];
	        var tokenType = [];
	        var tokenValue = [];
	        var s;
	        var a;
	        var t;

	        state.push(0);
	        tokenType.push(1);
	        tokenValue.push("_S");

	        a = types[tokenPos];
	        t = values[tokenPos++];
	        while (1) {
	            s = state[state.length - 1];
	            switch (XPathParser.actionTable[s].charAt(a - 1)) {
	                case XPathParser.SHIFT:
	                    tokenType.push(-a);
	                    tokenValue.push(t);
	                    state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
	                    a = types[tokenPos];
	                    t = values[tokenPos++];
	                    break;
	                case XPathParser.REDUCE:
	                    var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
	                    var rhs = [];
	                    for (var i = 0; i < num; i++) {
	                        tokenType.pop();
	                        rhs.unshift(tokenValue.pop());
	                        state.pop();
	                    }
	                    var s_ = state[state.length - 1];
	                    tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
	                    if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
	                        tokenValue.push(rhs[0]);
	                    } else {
	                        tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
	                    }
	                    state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
	                    break;
	                case XPathParser.ACCEPT:
	                    return new XPath(tokenValue.pop());
	                default:
	                    throw new Error("XPath parse error");
	            }
	        }
	    };

	    // XPath /////////////////////////////////////////////////////////////////////

	    XPath.prototype = new Object();
	    XPath.prototype.constructor = XPath;
	    XPath.superclass = Object.prototype;

	    function XPath(e) {
	        this.expression = e;
	    }

	    XPath.prototype.toString = function () {
	        return this.expression.toString();
	    };

	    function setIfUnset(obj, prop, value) {
	        if (!(prop in obj)) {
	            obj[prop] = value;
	        }
	    }

	    XPath.prototype.evaluate = function (c) {
	        var node = c.expressionContextNode;

	        if (!(isNil(node) || isNodeLike(node))) {
	            throw new Error("Context node does not appear to be a valid DOM node.");
	        }

	        c.contextNode = c.expressionContextNode;
	        c.contextSize = 1;
	        c.contextPosition = 1;

	        // [2017-11-25] Removed usage of .implementation.hasFeature() since it does
	        //              not reliably detect HTML DOMs (always returns false in xmldom and true in browsers)
	        if (c.isHtml) {
	            setIfUnset(c, 'caseInsensitive', true);
	            setIfUnset(c, 'allowAnyNamespaceForNoPrefix', true);
	        }

	        setIfUnset(c, 'caseInsensitive', false);

	        return this.expression.evaluate(c);
	    };

	    XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
	    XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";

	    // Expression ////////////////////////////////////////////////////////////////

	    Expression.prototype = new Object();
	    Expression.prototype.constructor = Expression;
	    Expression.superclass = Object.prototype;

	    function Expression() {
	    }

	    Expression.prototype.init = function () {
	    };

	    Expression.prototype.toString = function () {
	        return "<Expression>";
	    };

	    Expression.prototype.evaluate = function (c) {
	        throw new Error("Could not evaluate expression.");
	    };

	    // UnaryOperation ////////////////////////////////////////////////////////////

	    UnaryOperation.prototype = new Expression();
	    UnaryOperation.prototype.constructor = UnaryOperation;
	    UnaryOperation.superclass = Expression.prototype;

	    function UnaryOperation(rhs) {
	        if (arguments.length > 0) {
	            this.init(rhs);
	        }
	    }

	    UnaryOperation.prototype.init = function (rhs) {
	        this.rhs = rhs;
	    };

	    // UnaryMinusOperation ///////////////////////////////////////////////////////

	    UnaryMinusOperation.prototype = new UnaryOperation();
	    UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
	    UnaryMinusOperation.superclass = UnaryOperation.prototype;

	    function UnaryMinusOperation(rhs) {
	        if (arguments.length > 0) {
	            this.init(rhs);
	        }
	    }

	    UnaryMinusOperation.prototype.init = function (rhs) {
	        UnaryMinusOperation.superclass.init.call(this, rhs);
	    };

	    UnaryMinusOperation.prototype.evaluate = function (c) {
	        return this.rhs.evaluate(c).number().negate();
	    };

	    UnaryMinusOperation.prototype.toString = function () {
	        return "-" + this.rhs.toString();
	    };

	    // BinaryOperation ///////////////////////////////////////////////////////////

	    BinaryOperation.prototype = new Expression();
	    BinaryOperation.prototype.constructor = BinaryOperation;
	    BinaryOperation.superclass = Expression.prototype;

	    function BinaryOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    BinaryOperation.prototype.init = function (lhs, rhs) {
	        this.lhs = lhs;
	        this.rhs = rhs;
	    };

	    // OrOperation ///////////////////////////////////////////////////////////////

	    OrOperation.prototype = new BinaryOperation();
	    OrOperation.prototype.constructor = OrOperation;
	    OrOperation.superclass = BinaryOperation.prototype;

	    function OrOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    OrOperation.prototype.init = function (lhs, rhs) {
	        OrOperation.superclass.init.call(this, lhs, rhs);
	    };

	    OrOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
	    };

	    OrOperation.prototype.evaluate = function (c) {
	        var b = this.lhs.evaluate(c).bool();
	        if (b.booleanValue()) {
	            return b;
	        }
	        return this.rhs.evaluate(c).bool();
	    };

	    // AndOperation //////////////////////////////////////////////////////////////

	    AndOperation.prototype = new BinaryOperation();
	    AndOperation.prototype.constructor = AndOperation;
	    AndOperation.superclass = BinaryOperation.prototype;

	    function AndOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    AndOperation.prototype.init = function (lhs, rhs) {
	        AndOperation.superclass.init.call(this, lhs, rhs);
	    };

	    AndOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
	    };

	    AndOperation.prototype.evaluate = function (c) {
	        var b = this.lhs.evaluate(c).bool();
	        if (!b.booleanValue()) {
	            return b;
	        }
	        return this.rhs.evaluate(c).bool();
	    };

	    // EqualsOperation ///////////////////////////////////////////////////////////

	    EqualsOperation.prototype = new BinaryOperation();
	    EqualsOperation.prototype.constructor = EqualsOperation;
	    EqualsOperation.superclass = BinaryOperation.prototype;

	    function EqualsOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    EqualsOperation.prototype.init = function (lhs, rhs) {
	        EqualsOperation.superclass.init.call(this, lhs, rhs);
	    };

	    EqualsOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
	    };

	    EqualsOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
	    };

	    // NotEqualOperation /////////////////////////////////////////////////////////

	    NotEqualOperation.prototype = new BinaryOperation();
	    NotEqualOperation.prototype.constructor = NotEqualOperation;
	    NotEqualOperation.superclass = BinaryOperation.prototype;

	    function NotEqualOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    NotEqualOperation.prototype.init = function (lhs, rhs) {
	        NotEqualOperation.superclass.init.call(this, lhs, rhs);
	    };

	    NotEqualOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
	    };

	    NotEqualOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
	    };

	    // LessThanOperation /////////////////////////////////////////////////////////

	    LessThanOperation.prototype = new BinaryOperation();
	    LessThanOperation.prototype.constructor = LessThanOperation;
	    LessThanOperation.superclass = BinaryOperation.prototype;

	    function LessThanOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    LessThanOperation.prototype.init = function (lhs, rhs) {
	        LessThanOperation.superclass.init.call(this, lhs, rhs);
	    };

	    LessThanOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
	    };

	    LessThanOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
	    };

	    // GreaterThanOperation //////////////////////////////////////////////////////

	    GreaterThanOperation.prototype = new BinaryOperation();
	    GreaterThanOperation.prototype.constructor = GreaterThanOperation;
	    GreaterThanOperation.superclass = BinaryOperation.prototype;

	    function GreaterThanOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    GreaterThanOperation.prototype.init = function (lhs, rhs) {
	        GreaterThanOperation.superclass.init.call(this, lhs, rhs);
	    };

	    GreaterThanOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
	    };

	    GreaterThanOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
	    };

	    // LessThanOrEqualOperation //////////////////////////////////////////////////

	    LessThanOrEqualOperation.prototype = new BinaryOperation();
	    LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
	    LessThanOrEqualOperation.superclass = BinaryOperation.prototype;

	    function LessThanOrEqualOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    LessThanOrEqualOperation.prototype.init = function (lhs, rhs) {
	        LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
	    };

	    LessThanOrEqualOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
	    };

	    LessThanOrEqualOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
	    };

	    // GreaterThanOrEqualOperation ///////////////////////////////////////////////

	    GreaterThanOrEqualOperation.prototype = new BinaryOperation();
	    GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
	    GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;

	    function GreaterThanOrEqualOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    GreaterThanOrEqualOperation.prototype.init = function (lhs, rhs) {
	        GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
	    };

	    GreaterThanOrEqualOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
	    };

	    GreaterThanOrEqualOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
	    };

	    // PlusOperation /////////////////////////////////////////////////////////////

	    PlusOperation.prototype = new BinaryOperation();
	    PlusOperation.prototype.constructor = PlusOperation;
	    PlusOperation.superclass = BinaryOperation.prototype;

	    function PlusOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    PlusOperation.prototype.init = function (lhs, rhs) {
	        PlusOperation.superclass.init.call(this, lhs, rhs);
	    };

	    PlusOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
	    };

	    PlusOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
	    };

	    // MinusOperation ////////////////////////////////////////////////////////////

	    MinusOperation.prototype = new BinaryOperation();
	    MinusOperation.prototype.constructor = MinusOperation;
	    MinusOperation.superclass = BinaryOperation.prototype;

	    function MinusOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    MinusOperation.prototype.init = function (lhs, rhs) {
	        MinusOperation.superclass.init.call(this, lhs, rhs);
	    };

	    MinusOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
	    };

	    MinusOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
	    };

	    // MultiplyOperation /////////////////////////////////////////////////////////

	    MultiplyOperation.prototype = new BinaryOperation();
	    MultiplyOperation.prototype.constructor = MultiplyOperation;
	    MultiplyOperation.superclass = BinaryOperation.prototype;

	    function MultiplyOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    MultiplyOperation.prototype.init = function (lhs, rhs) {
	        MultiplyOperation.superclass.init.call(this, lhs, rhs);
	    };

	    MultiplyOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
	    };

	    MultiplyOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
	    };

	    // DivOperation //////////////////////////////////////////////////////////////

	    DivOperation.prototype = new BinaryOperation();
	    DivOperation.prototype.constructor = DivOperation;
	    DivOperation.superclass = BinaryOperation.prototype;

	    function DivOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    DivOperation.prototype.init = function (lhs, rhs) {
	        DivOperation.superclass.init.call(this, lhs, rhs);
	    };

	    DivOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
	    };

	    DivOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
	    };

	    // ModOperation //////////////////////////////////////////////////////////////

	    ModOperation.prototype = new BinaryOperation();
	    ModOperation.prototype.constructor = ModOperation;
	    ModOperation.superclass = BinaryOperation.prototype;

	    function ModOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    ModOperation.prototype.init = function (lhs, rhs) {
	        ModOperation.superclass.init.call(this, lhs, rhs);
	    };

	    ModOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
	    };

	    ModOperation.prototype.toString = function () {
	        return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
	    };

	    // BarOperation //////////////////////////////////////////////////////////////

	    BarOperation.prototype = new BinaryOperation();
	    BarOperation.prototype.constructor = BarOperation;
	    BarOperation.superclass = BinaryOperation.prototype;

	    function BarOperation(lhs, rhs) {
	        if (arguments.length > 0) {
	            this.init(lhs, rhs);
	        }
	    }

	    BarOperation.prototype.init = function (lhs, rhs) {
	        BarOperation.superclass.init.call(this, lhs, rhs);
	    };

	    BarOperation.prototype.evaluate = function (c) {
	        return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
	    };

	    BarOperation.prototype.toString = function () {
	        return map(toString, [this.lhs, this.rhs]).join(' | ');
	    };

	    // PathExpr //////////////////////////////////////////////////////////////////

	    PathExpr.prototype = new Expression();
	    PathExpr.prototype.constructor = PathExpr;
	    PathExpr.superclass = Expression.prototype;

	    function PathExpr(filter, filterPreds, locpath) {
	        if (arguments.length > 0) {
	            this.init(filter, filterPreds, locpath);
	        }
	    }

	    PathExpr.prototype.init = function (filter, filterPreds, locpath) {
	        PathExpr.superclass.init.call(this);
	        this.filter = filter;
	        this.filterPredicates = filterPreds;
	        this.locationPath = locpath;
	    };

	    /**
	     * Returns the topmost node of the tree containing node
	     */
	    function findRoot(node) {
	        while (node && node.parentNode) {
	            node = node.parentNode;
	        }

	        return node;
	    }

	    var applyPredicates = function (predicates, c, nodes, reverse) {
	        if (predicates.length === 0) {
	            return nodes;
	        }

	        var ctx = c.extend({});

	        return reduce(
	            function (inNodes, pred) {
	                ctx.contextSize = inNodes.length;

	                return filter(
	                    function (node, i) {
	                        ctx.contextNode = node;
	                        ctx.contextPosition = i + 1;

	                        return PathExpr.predicateMatches(pred, ctx);
	                    },
	                    inNodes
	                );
	            },
	            sortNodes(nodes, reverse),
	            predicates
	        );
	    };

	    PathExpr.getRoot = function (xpc, nodes) {
	        var firstNode = nodes[0];

	        // xpc.virtualRoot could possibly provide a root even if firstNode is null,
	        // so using a guard here instead of throwing.
	        if (firstNode && firstNode.nodeType === NodeTypes.DOCUMENT_NODE) {
	            return firstNode;
	        }

	        if (xpc.virtualRoot) {
	            return xpc.virtualRoot;
	        }

	        if (!firstNode) {
	            throw new Error('Context node not found when determining document root.');
	        }

	        var ownerDoc = firstNode.ownerDocument;

	        if (ownerDoc) {
	            return ownerDoc;
	        }

	        // IE 5.5 doesn't have ownerDocument?
	        var n = firstNode;
	        while (n.parentNode != null) {
	            n = n.parentNode;
	        }
	        return n;
	    };

	    var getPrefixForNamespaceNode = function (attrNode) {
	        var nm = String(attrNode.name);

	        if (nm === "xmlns") {
	            return "";
	        }

	        if (nm.substring(0, 6) === "xmlns:") {
	            return nm.substring(6, nm.length);
	        }

	        return null;
	    };

	    PathExpr.applyStep = function (step, xpc, node) {
	        if (!node) {
	            throw new Error('Context node not found when evaluating XPath step: ' + step);
	        }

	        var newNodes = [];
	        xpc.contextNode = node;

	        switch (step.axis) {
	            case Step.ANCESTOR:
	                // look at all the ancestor nodes
	                if (xpc.contextNode === xpc.virtualRoot) {
	                    break;
	                }
	                var m;
	                if (xpc.contextNode.nodeType == NodeTypes.ATTRIBUTE_NODE) {
	                    m = PathExpr.getOwnerElement(xpc.contextNode);
	                } else {
	                    m = xpc.contextNode.parentNode;
	                }
	                while (m != null) {
	                    if (step.nodeTest.matches(m, xpc)) {
	                        newNodes.push(m);
	                    }
	                    if (m === xpc.virtualRoot) {
	                        break;
	                    }
	                    m = m.parentNode;
	                }
	                break;

	            case Step.ANCESTORORSELF:
	                // look at all the ancestor nodes and the current node
	                for (var m = xpc.contextNode; m != null; m = m.nodeType == NodeTypes.ATTRIBUTE_NODE ? PathExpr.getOwnerElement(m) : m.parentNode) {
	                    if (step.nodeTest.matches(m, xpc)) {
	                        newNodes.push(m);
	                    }
	                    if (m === xpc.virtualRoot) {
	                        break;
	                    }
	                }
	                break;

	            case Step.ATTRIBUTE:
	                // look at the attributes
	                var nnm = xpc.contextNode.attributes;
	                if (nnm != null) {
	                    for (var k = 0; k < nnm.length; k++) {
	                        var m = nnm.item(k);
	                        if (step.nodeTest.matches(m, xpc)) {
	                            newNodes.push(m);
	                        }
	                    }
	                }
	                break;

	            case Step.CHILD:
	                // look at all child elements
	                for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
	                    if (step.nodeTest.matches(m, xpc)) {
	                        newNodes.push(m);
	                    }
	                }
	                break;

	            case Step.DESCENDANT:
	                // look at all descendant nodes
	                var st = [xpc.contextNode.firstChild];
	                while (st.length > 0) {
	                    for (var m = st.pop(); m != null;) {
	                        if (step.nodeTest.matches(m, xpc)) {
	                            newNodes.push(m);
	                        }
	                        if (m.firstChild != null) {
	                            st.push(m.nextSibling);
	                            m = m.firstChild;
	                        } else {
	                            m = m.nextSibling;
	                        }
	                    }
	                }
	                break;

	            case Step.DESCENDANTORSELF:
	                // look at self
	                if (step.nodeTest.matches(xpc.contextNode, xpc)) {
	                    newNodes.push(xpc.contextNode);
	                }
	                // look at all descendant nodes
	                var st = [xpc.contextNode.firstChild];
	                while (st.length > 0) {
	                    for (var m = st.pop(); m != null;) {
	                        if (step.nodeTest.matches(m, xpc)) {
	                            newNodes.push(m);
	                        }
	                        if (m.firstChild != null) {
	                            st.push(m.nextSibling);
	                            m = m.firstChild;
	                        } else {
	                            m = m.nextSibling;
	                        }
	                    }
	                }
	                break;

	            case Step.FOLLOWING:
	                if (xpc.contextNode === xpc.virtualRoot) {
	                    break;
	                }
	                var st = [];
	                if (xpc.contextNode.firstChild != null) {
	                    st.unshift(xpc.contextNode.firstChild);
	                } else {
	                    st.unshift(xpc.contextNode.nextSibling);
	                }
	                for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != NodeTypes.DOCUMENT_NODE && m !== xpc.virtualRoot; m = m.parentNode) {
	                    st.unshift(m.nextSibling);
	                }
	                do {
	                    for (var m = st.pop(); m != null;) {
	                        if (step.nodeTest.matches(m, xpc)) {
	                            newNodes.push(m);
	                        }
	                        if (m.firstChild != null) {
	                            st.push(m.nextSibling);
	                            m = m.firstChild;
	                        } else {
	                            m = m.nextSibling;
	                        }
	                    }
	                } while (st.length > 0);
	                break;

	            case Step.FOLLOWINGSIBLING:
	                if (xpc.contextNode === xpc.virtualRoot) {
	                    break;
	                }
	                for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
	                    if (step.nodeTest.matches(m, xpc)) {
	                        newNodes.push(m);
	                    }
	                }
	                break;

	            case Step.NAMESPACE:
	                var nodes = {};

	                if (xpc.contextNode.nodeType == NodeTypes.ELEMENT_NODE) {
	                    // BUG: This only collects the namespaces on the current node, but seemingly
	                    //      it should collect all those in scope
	                    nodes["xml"] = new XPathNamespace("xml", null, XPath.XML_NAMESPACE_URI, xpc.contextNode);

	                    for (var m = xpc.contextNode; m != null && m.nodeType == NodeTypes.ELEMENT_NODE; m = m.parentNode) {
	                        for (var k = 0; k < m.attributes.length; k++) {
	                            var attr = m.attributes.item(k);

	                            var pre = getPrefixForNamespaceNode(attr);

	                            if (pre != null && nodes[pre] == undefined) {
	                                nodes[pre] = new XPathNamespace(pre, attr, attr.value, xpc.contextNode);
	                            }
	                        }
	                    }

	                    for (var pre in nodes) {
	                        var node = nodes[pre];

	                        if (step.nodeTest.matches(node, xpc)) {
	                            newNodes.push(node);
	                        }
	                    }
	                }
	                break;

	            case Step.PARENT:
	                m = null;
	                if (xpc.contextNode !== xpc.virtualRoot) {
	                    if (xpc.contextNode.nodeType == NodeTypes.ATTRIBUTE_NODE) {
	                        m = PathExpr.getOwnerElement(xpc.contextNode);
	                    } else {
	                        m = xpc.contextNode.parentNode;
	                    }
	                }
	                if (m != null && step.nodeTest.matches(m, xpc)) {
	                    newNodes.push(m);
	                }
	                break;

	            case Step.PRECEDING:
	                var st;
	                if (xpc.virtualRoot != null) {
	                    st = [xpc.virtualRoot];
	                } else {
	                    // cannot rely on .ownerDocument because the node may be in a document fragment
	                    st = [findRoot(xpc.contextNode)];
	                }
	                outer: while (st.length > 0) {
	                    for (var m = st.pop(); m != null;) {
	                        if (m == xpc.contextNode) {
	                            break outer;
	                        }
	                        if (step.nodeTest.matches(m, xpc)) {
	                            newNodes.unshift(m);
	                        }
	                        if (m.firstChild != null) {
	                            st.push(m.nextSibling);
	                            m = m.firstChild;
	                        } else {
	                            m = m.nextSibling;
	                        }
	                    }
	                }
	                break;

	            case Step.PRECEDINGSIBLING:
	                if (xpc.contextNode === xpc.virtualRoot) {
	                    break;
	                }
	                for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
	                    if (step.nodeTest.matches(m, xpc)) {
	                        newNodes.push(m);
	                    }
	                }
	                break;

	            case Step.SELF:
	                if (step.nodeTest.matches(xpc.contextNode, xpc)) {
	                    newNodes.push(xpc.contextNode);
	                }
	                break;

	            default:
	        }

	        return newNodes;
	    };

	    function applyStepWithPredicates(step, xpc, node) {
	        return applyPredicates(
	            step.predicates,
	            xpc,
	            PathExpr.applyStep(step, xpc, node),
	            includes(REVERSE_AXES, step.axis)
	        );
	    }

	    function applyStepToNodes(context, nodes, step) {
	        return flatten(
	            map(
	                applyStepWithPredicates.bind(null, step, context),
	                nodes
	            )
	        );
	    }

	    PathExpr.applySteps = function (steps, xpc, nodes) {
	        return reduce(
	            applyStepToNodes.bind(null, xpc),
	            nodes,
	            steps
	        );
	    };

	    PathExpr.prototype.applyFilter = function (c, xpc) {
	        if (!this.filter) {
	            return { nodes: [c.contextNode] };
	        }

	        var ns = this.filter.evaluate(c);

	        if (!Utilities.instance_of(ns, XNodeSet)) {
	            if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
	                throw new Error("Path expression filter must evaluate to a nodeset if predicates or location path are used");
	            }

	            return { nonNodes: ns };
	        }

	        return {
	            nodes: applyPredicates(
	                this.filterPredicates || [],
	                xpc,
	                ns.toUnsortedArray(),
	                false // reverse
	            )
	        };
	    };

	    PathExpr.applyLocationPath = function (locationPath, xpc, nodes) {
	        if (!locationPath) {
	            return nodes;
	        }

	        var startNodes = locationPath.absolute ? [PathExpr.getRoot(xpc, nodes)] : nodes;

	        return PathExpr.applySteps(locationPath.steps, xpc, startNodes);
	    };

	    PathExpr.prototype.evaluate = function (c) {
	        var xpc = assign(new XPathContext(), c);

	        var filterResult = this.applyFilter(c, xpc);

	        if ('nonNodes' in filterResult) {
	            return filterResult.nonNodes;
	        }

	        var ns = new XNodeSet();
	        ns.addArray(PathExpr.applyLocationPath(this.locationPath, xpc, filterResult.nodes));
	        return ns;
	    };

	    PathExpr.predicateMatches = function (pred, c) {
	        var res = pred.evaluate(c);

	        return Utilities.instance_of(res, XNumber)
	            ? c.contextPosition === res.numberValue()
	            : res.booleanValue();
	    };

	    PathExpr.predicateString = function (predicate) {
	        return wrap('[', ']', predicate.toString());
	    };

	    PathExpr.predicatesString = function (predicates) {
	        return join(
	            '',
	            map(PathExpr.predicateString, predicates)
	        );
	    };

	    PathExpr.prototype.toString = function () {
	        if (this.filter != undefined) {
	            var filterStr = toString(this.filter);

	            if (Utilities.instance_of(this.filter, XString)) {
	                return wrap("'", "'", filterStr);
	            }
	            if (this.filterPredicates != undefined && this.filterPredicates.length) {
	                return wrap('(', ')', filterStr) +
	                    PathExpr.predicatesString(this.filterPredicates);
	            }
	            if (this.locationPath != undefined) {
	                return filterStr +
	                    (this.locationPath.absolute ? '' : '/') +
	                    toString(this.locationPath);
	            }

	            return filterStr;
	        }

	        return toString(this.locationPath);
	    };

	    PathExpr.getOwnerElement = function (n) {
	        // DOM 2 has ownerElement
	        if (n.ownerElement) {
	            return n.ownerElement;
	        }
	        // DOM 1 Internet Explorer can use selectSingleNode (ironically)
	        try {
	            if (n.selectSingleNode) {
	                return n.selectSingleNode("..");
	            }
	        } catch (e) {
	        }
	        // Other DOM 1 implementations must use this egregious search
	        var doc = n.nodeType == NodeTypes.DOCUMENT_NODE
	            ? n
	            : n.ownerDocument;
	        var elts = doc.getElementsByTagName("*");
	        for (var i = 0; i < elts.length; i++) {
	            var elt = elts.item(i);
	            var nnm = elt.attributes;
	            for (var j = 0; j < nnm.length; j++) {
	                var an = nnm.item(j);
	                if (an === n) {
	                    return elt;
	                }
	            }
	        }
	        return null;
	    };

	    // LocationPath //////////////////////////////////////////////////////////////

	    LocationPath.prototype = new Object();
	    LocationPath.prototype.constructor = LocationPath;
	    LocationPath.superclass = Object.prototype;

	    function LocationPath(abs, steps) {
	        if (arguments.length > 0) {
	            this.init(abs, steps);
	        }
	    }

	    LocationPath.prototype.init = function (abs, steps) {
	        this.absolute = abs;
	        this.steps = steps;
	    };

	    LocationPath.prototype.toString = function () {
	        return (
	            (this.absolute ? '/' : '') +
	            map(toString, this.steps).join('/')
	        );
	    };

	    // Step //////////////////////////////////////////////////////////////////////

	    Step.prototype = new Object();
	    Step.prototype.constructor = Step;
	    Step.superclass = Object.prototype;

	    function Step(axis, nodetest, preds) {
	        if (arguments.length > 0) {
	            this.init(axis, nodetest, preds);
	        }
	    }

	    Step.prototype.init = function (axis, nodetest, preds) {
	        this.axis = axis;
	        this.nodeTest = nodetest;
	        this.predicates = preds;
	    };

	    Step.prototype.toString = function () {
	        return Step.STEPNAMES[this.axis] +
	            "::" +
	            this.nodeTest.toString() +
	            PathExpr.predicatesString(this.predicates);
	    };


	    Step.ANCESTOR = 0;
	    Step.ANCESTORORSELF = 1;
	    Step.ATTRIBUTE = 2;
	    Step.CHILD = 3;
	    Step.DESCENDANT = 4;
	    Step.DESCENDANTORSELF = 5;
	    Step.FOLLOWING = 6;
	    Step.FOLLOWINGSIBLING = 7;
	    Step.NAMESPACE = 8;
	    Step.PARENT = 9;
	    Step.PRECEDING = 10;
	    Step.PRECEDINGSIBLING = 11;
	    Step.SELF = 12;

	    Step.STEPNAMES = reduce(function (acc, x) { return acc[x[0]] = x[1], acc; }, {}, [
	        [Step.ANCESTOR, 'ancestor'],
	        [Step.ANCESTORORSELF, 'ancestor-or-self'],
	        [Step.ATTRIBUTE, 'attribute'],
	        [Step.CHILD, 'child'],
	        [Step.DESCENDANT, 'descendant'],
	        [Step.DESCENDANTORSELF, 'descendant-or-self'],
	        [Step.FOLLOWING, 'following'],
	        [Step.FOLLOWINGSIBLING, 'following-sibling'],
	        [Step.NAMESPACE, 'namespace'],
	        [Step.PARENT, 'parent'],
	        [Step.PRECEDING, 'preceding'],
	        [Step.PRECEDINGSIBLING, 'preceding-sibling'],
	        [Step.SELF, 'self']
	    ]);

	    var REVERSE_AXES = [
	        Step.ANCESTOR,
	        Step.ANCESTORORSELF,
	        Step.PARENT,
	        Step.PRECEDING,
	        Step.PRECEDINGSIBLING
	    ];

	    // NodeTest //////////////////////////////////////////////////////////////////

	    NodeTest.prototype = new Object();
	    NodeTest.prototype.constructor = NodeTest;
	    NodeTest.superclass = Object.prototype;

	    function NodeTest(type, value) {
	        if (arguments.length > 0) {
	            this.init(type, value);
	        }
	    }

	    NodeTest.prototype.init = function (type, value) {
	        this.type = type;
	        this.value = value;
	    };

	    NodeTest.prototype.toString = function () {
	        return "<unknown nodetest type>";
	    };

	    NodeTest.prototype.matches = function (n, xpc) {
	        console.warn('unknown node test type');
	    };

	    NodeTest.NAMETESTANY = 0;
	    NodeTest.NAMETESTPREFIXANY = 1;
	    NodeTest.NAMETESTQNAME = 2;
	    NodeTest.COMMENT = 3;
	    NodeTest.TEXT = 4;
	    NodeTest.PI = 5;
	    NodeTest.NODE = 6;

	    NodeTest.isNodeType = function (types) {
	        return function (node) {
	            return includes(types, node.nodeType);
	        };
	    };

	    NodeTest.makeNodeTestType = function (type, members, ctor) {
	        var newType = ctor || function () { };

	        newType.prototype = new NodeTest(type);
	        newType.prototype.constructor = newType;

	        assign(newType.prototype, members);

	        return newType;
	    };
	    // create invariant node test for certain node types
	    NodeTest.makeNodeTypeTest = function (type, nodeTypes, stringVal) {
	        return new (NodeTest.makeNodeTestType(type, {
	            matches: NodeTest.isNodeType(nodeTypes),
	            toString: always(stringVal)
	        }))();
	    };

	    NodeTest.hasPrefix = function (node) {
	        return node.prefix || (node.nodeName || node.tagName).indexOf(':') !== -1;
	    };

	    NodeTest.isElementOrAttribute = NodeTest.isNodeType([1, 2]);
	    NodeTest.nameSpaceMatches = function (prefix, xpc, n) {
	        var nNamespace = (n.namespaceURI || '');

	        if (!prefix) {
	            return !nNamespace || (xpc.allowAnyNamespaceForNoPrefix && !NodeTest.hasPrefix(n));
	        }

	        var ns = xpc.namespaceResolver.getNamespace(prefix, xpc.expressionContextNode);

	        if (ns == null) {
	            throw new Error("Cannot resolve QName " + prefix);
	        }

	        return ns === nNamespace;
	    };
	    NodeTest.localNameMatches = function (localName, xpc, n) {
	        var nLocalName = (n.localName || n.nodeName);

	        return xpc.caseInsensitive
	            ? localName.toLowerCase() === nLocalName.toLowerCase()
	            : localName === nLocalName;
	    };

	    NodeTest.NameTestPrefixAny = NodeTest.makeNodeTestType(
	        NodeTest.NAMETESTPREFIXANY,
	        {
	            matches: function (n, xpc) {
	                return NodeTest.isElementOrAttribute(n) &&
	                    NodeTest.nameSpaceMatches(this.prefix, xpc, n);
	            },
	            toString: function () {
	                return this.prefix + ":*";
	            }
	        },
	        function NameTestPrefixAny(prefix) { this.prefix = prefix; }
	    );

	    NodeTest.NameTestQName = NodeTest.makeNodeTestType(
	        NodeTest.NAMETESTQNAME,
	        {
	            matches: function (n, xpc) {
	                return NodeTest.isNodeType(
	                    [
	                        NodeTypes.ELEMENT_NODE,
	                        NodeTypes.ATTRIBUTE_NODE,
	                        NodeTypes.NAMESPACE_NODE,
	                    ]
	                )(n) &&
	                    NodeTest.nameSpaceMatches(this.prefix, xpc, n) &&
	                    NodeTest.localNameMatches(this.localName, xpc, n);
	            },
	            toString: function () {
	                return this.name;
	            }
	        },
	        function NameTestQName(name) {
	            var nameParts = name.split(':');

	            this.name = name;
	            this.prefix = nameParts.length > 1 ? nameParts[0] : null;
	            this.localName = nameParts[nameParts.length > 1 ? 1 : 0];
	        }
	    );

	    NodeTest.PITest = NodeTest.makeNodeTestType(NodeTest.PI, {
	        matches: function (n, xpc) {
	            return NodeTest.isNodeType(
	                [NodeTypes.PROCESSING_INSTRUCTION_NODE]
	            )(n) &&
	                (n.target || n.nodeName) === this.name;
	        },
	        toString: function () {
	            return wrap('processing-instruction("', '")', this.name);
	        }
	    }, function (name) { this.name = name; });

	    // singletons

	    // elements, attributes, namespaces
	    NodeTest.nameTestAny = NodeTest.makeNodeTypeTest(
	        NodeTest.NAMETESTANY,
	        [
	            NodeTypes.ELEMENT_NODE,
	            NodeTypes.ATTRIBUTE_NODE,
	            NodeTypes.NAMESPACE_NODE,
	        ],
	        '*'
	    );
	    // text, cdata
	    NodeTest.textTest = NodeTest.makeNodeTypeTest(
	        NodeTest.TEXT,
	        [
	            NodeTypes.TEXT_NODE,
	            NodeTypes.CDATA_SECTION_NODE,
	        ],
	        'text()'
	    );
	    NodeTest.commentTest = NodeTest.makeNodeTypeTest(
	        NodeTest.COMMENT,
	        [NodeTypes.COMMENT_NODE],
	        'comment()'
	    );
	    // elements, attributes, text, cdata, PIs, comments, document nodes
	    NodeTest.nodeTest = NodeTest.makeNodeTypeTest(
	        NodeTest.NODE,
	        [
	            NodeTypes.ELEMENT_NODE,
	            NodeTypes.ATTRIBUTE_NODE,
	            NodeTypes.TEXT_NODE,
	            NodeTypes.CDATA_SECTION_NODE,
	            NodeTypes.PROCESSING_INSTRUCTION_NODE,
	            NodeTypes.COMMENT_NODE,
	            NodeTypes.DOCUMENT_NODE,
	        ],
	        'node()'
	    );
	    NodeTest.anyPiTest = NodeTest.makeNodeTypeTest(
	        NodeTest.PI,
	        [NodeTypes.PROCESSING_INSTRUCTION_NODE],
	        'processing-instruction()'
	    );

	    // VariableReference /////////////////////////////////////////////////////////

	    VariableReference.prototype = new Expression();
	    VariableReference.prototype.constructor = VariableReference;
	    VariableReference.superclass = Expression.prototype;

	    function VariableReference(v) {
	        if (arguments.length > 0) {
	            this.init(v);
	        }
	    }

	    VariableReference.prototype.init = function (v) {
	        this.variable = v;
	    };

	    VariableReference.prototype.toString = function () {
	        return "$" + this.variable;
	    };

	    VariableReference.prototype.evaluate = function (c) {
	        var parts = Utilities.resolveQName(this.variable, c.namespaceResolver, c.contextNode, false);

	        if (parts[0] == null) {
	            throw new Error("Cannot resolve QName " + fn);
	        }
	        var result = c.variableResolver.getVariable(parts[1], parts[0]);
	        if (!result) {
	            throw XPathException.fromMessage("Undeclared variable: " + this.toString());
	        }
	        return result;
	    };

	    // FunctionCall //////////////////////////////////////////////////////////////

	    FunctionCall.prototype = new Expression();
	    FunctionCall.prototype.constructor = FunctionCall;
	    FunctionCall.superclass = Expression.prototype;

	    function FunctionCall(fn, args) {
	        if (arguments.length > 0) {
	            this.init(fn, args);
	        }
	    }

	    FunctionCall.prototype.init = function (fn, args) {
	        this.functionName = fn;
	        this.arguments = args;
	    };

	    FunctionCall.prototype.toString = function () {
	        var s = this.functionName + "(";
	        for (var i = 0; i < this.arguments.length; i++) {
	            if (i > 0) {
	                s += ", ";
	            }
	            s += this.arguments[i].toString();
	        }
	        return s + ")";
	    };

	    FunctionCall.prototype.evaluate = function (c) {
	        var f = FunctionResolver.getFunctionFromContext(this.functionName, c);

	        if (!f) {
	            throw new Error("Unknown function " + this.functionName);
	        }

	        var a = [c].concat(this.arguments);
	        return f.apply(c.functionResolver.thisArg, a);
	    };

	    // Operators /////////////////////////////////////////////////////////////////

	    var Operators = new Object();

	    Operators.equals = function (l, r) {
	        return l.equals(r);
	    };

	    Operators.notequal = function (l, r) {
	        return l.notequal(r);
	    };

	    Operators.lessthan = function (l, r) {
	        return l.lessthan(r);
	    };

	    Operators.greaterthan = function (l, r) {
	        return l.greaterthan(r);
	    };

	    Operators.lessthanorequal = function (l, r) {
	        return l.lessthanorequal(r);
	    };

	    Operators.greaterthanorequal = function (l, r) {
	        return l.greaterthanorequal(r);
	    };

	    // XString ///////////////////////////////////////////////////////////////////

	    XString.prototype = new Expression();
	    XString.prototype.constructor = XString;
	    XString.superclass = Expression.prototype;

	    function XString(s) {
	        if (arguments.length > 0) {
	            this.init(s);
	        }
	    }

	    XString.prototype.init = function (s) {
	        this.str = String(s);
	    };

	    XString.prototype.toString = function () {
	        return this.str;
	    };

	    XString.prototype.evaluate = function (c) {
	        return this;
	    };

	    XString.prototype.string = function () {
	        return this;
	    };

	    XString.prototype.number = function () {
	        return new XNumber(this.str);
	    };

	    XString.prototype.bool = function () {
	        return new XBoolean(this.str);
	    };

	    XString.prototype.nodeset = function () {
	        throw new Error("Cannot convert string to nodeset");
	    };

	    XString.prototype.stringValue = function () {
	        return this.str;
	    };

	    XString.prototype.numberValue = function () {
	        return this.number().numberValue();
	    };

	    XString.prototype.booleanValue = function () {
	        return this.bool().booleanValue();
	    };

	    XString.prototype.equals = function (r) {
	        if (Utilities.instance_of(r, XBoolean)) {
	            return this.bool().equals(r);
	        }
	        if (Utilities.instance_of(r, XNumber)) {
	            return this.number().equals(r);
	        }
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithString(this, Operators.equals);
	        }
	        return new XBoolean(this.str == r.str);
	    };

	    XString.prototype.notequal = function (r) {
	        if (Utilities.instance_of(r, XBoolean)) {
	            return this.bool().notequal(r);
	        }
	        if (Utilities.instance_of(r, XNumber)) {
	            return this.number().notequal(r);
	        }
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithString(this, Operators.notequal);
	        }
	        return new XBoolean(this.str != r.str);
	    };

	    XString.prototype.lessthan = function (r) {
	        return this.number().lessthan(r);
	    };

	    XString.prototype.greaterthan = function (r) {
	        return this.number().greaterthan(r);
	    };

	    XString.prototype.lessthanorequal = function (r) {
	        return this.number().lessthanorequal(r);
	    };

	    XString.prototype.greaterthanorequal = function (r) {
	        return this.number().greaterthanorequal(r);
	    };

	    // XNumber ///////////////////////////////////////////////////////////////////

	    XNumber.prototype = new Expression();
	    XNumber.prototype.constructor = XNumber;
	    XNumber.superclass = Expression.prototype;

	    function XNumber(n) {
	        if (arguments.length > 0) {
	            this.init(n);
	        }
	    }

	    XNumber.prototype.init = function (n) {
	        this.num = typeof n === "string" ? this.parse(n) : Number(n);
	    };

	    XNumber.prototype.numberFormat = /^\s*-?[0-9]*\.?[0-9]+\s*$/;

	    XNumber.prototype.parse = function (s) {
	        // XPath representation of numbers is more restrictive than what Number() or parseFloat() allow
	        return this.numberFormat.test(s) ? parseFloat(s) : Number.NaN;
	    };

	    function padSmallNumber(numberStr) {
	        var parts = numberStr.split('e-');
	        var base = parts[0].replace('.', '');
	        var exponent = Number(parts[1]);

	        for (var i = 0; i < exponent - 1; i += 1) {
	            base = '0' + base;
	        }

	        return '0.' + base;
	    }

	    function padLargeNumber(numberStr) {
	        var parts = numberStr.split('e');
	        var base = parts[0].replace('.', '');
	        var exponent = Number(parts[1]);
	        var zerosToAppend = exponent + 1 - base.length;

	        for (var i = 0; i < zerosToAppend; i += 1) {
	            base += '0';
	        }

	        return base;
	    }

	    XNumber.prototype.toString = function () {
	        var strValue = this.num.toString();

	        if (strValue.indexOf('e-') !== -1) {
	            return padSmallNumber(strValue);
	        }

	        if (strValue.indexOf('e') !== -1) {
	            return padLargeNumber(strValue);
	        }

	        return strValue;
	    };

	    XNumber.prototype.evaluate = function (c) {
	        return this;
	    };

	    XNumber.prototype.string = function () {


	        return new XString(this.toString());
	    };

	    XNumber.prototype.number = function () {
	        return this;
	    };

	    XNumber.prototype.bool = function () {
	        return new XBoolean(this.num);
	    };

	    XNumber.prototype.nodeset = function () {
	        throw new Error("Cannot convert number to nodeset");
	    };

	    XNumber.prototype.stringValue = function () {
	        return this.string().stringValue();
	    };

	    XNumber.prototype.numberValue = function () {
	        return this.num;
	    };

	    XNumber.prototype.booleanValue = function () {
	        return this.bool().booleanValue();
	    };

	    XNumber.prototype.negate = function () {
	        return new XNumber(-this.num);
	    };

	    XNumber.prototype.equals = function (r) {
	        if (Utilities.instance_of(r, XBoolean)) {
	            return this.bool().equals(r);
	        }
	        if (Utilities.instance_of(r, XString)) {
	            return this.equals(r.number());
	        }
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithNumber(this, Operators.equals);
	        }
	        return new XBoolean(this.num == r.num);
	    };

	    XNumber.prototype.notequal = function (r) {
	        if (Utilities.instance_of(r, XBoolean)) {
	            return this.bool().notequal(r);
	        }
	        if (Utilities.instance_of(r, XString)) {
	            return this.notequal(r.number());
	        }
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithNumber(this, Operators.notequal);
	        }
	        return new XBoolean(this.num != r.num);
	    };

	    XNumber.prototype.lessthan = function (r) {
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithNumber(this, Operators.greaterthan);
	        }
	        if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
	            return this.lessthan(r.number());
	        }
	        return new XBoolean(this.num < r.num);
	    };

	    XNumber.prototype.greaterthan = function (r) {
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithNumber(this, Operators.lessthan);
	        }
	        if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
	            return this.greaterthan(r.number());
	        }
	        return new XBoolean(this.num > r.num);
	    };

	    XNumber.prototype.lessthanorequal = function (r) {
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithNumber(this, Operators.greaterthanorequal);
	        }
	        if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
	            return this.lessthanorequal(r.number());
	        }
	        return new XBoolean(this.num <= r.num);
	    };

	    XNumber.prototype.greaterthanorequal = function (r) {
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithNumber(this, Operators.lessthanorequal);
	        }
	        if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
	            return this.greaterthanorequal(r.number());
	        }
	        return new XBoolean(this.num >= r.num);
	    };

	    XNumber.prototype.plus = function (r) {
	        return new XNumber(this.num + r.num);
	    };

	    XNumber.prototype.minus = function (r) {
	        return new XNumber(this.num - r.num);
	    };

	    XNumber.prototype.multiply = function (r) {
	        return new XNumber(this.num * r.num);
	    };

	    XNumber.prototype.div = function (r) {
	        return new XNumber(this.num / r.num);
	    };

	    XNumber.prototype.mod = function (r) {
	        return new XNumber(this.num % r.num);
	    };

	    // XBoolean //////////////////////////////////////////////////////////////////

	    XBoolean.prototype = new Expression();
	    XBoolean.prototype.constructor = XBoolean;
	    XBoolean.superclass = Expression.prototype;

	    function XBoolean(b) {
	        if (arguments.length > 0) {
	            this.init(b);
	        }
	    }

	    XBoolean.prototype.init = function (b) {
	        this.b = Boolean(b);
	    };

	    XBoolean.prototype.toString = function () {
	        return this.b.toString();
	    };

	    XBoolean.prototype.evaluate = function (c) {
	        return this;
	    };

	    XBoolean.prototype.string = function () {
	        return new XString(this.b);
	    };

	    XBoolean.prototype.number = function () {
	        return new XNumber(this.b);
	    };

	    XBoolean.prototype.bool = function () {
	        return this;
	    };

	    XBoolean.prototype.nodeset = function () {
	        throw new Error("Cannot convert boolean to nodeset");
	    };

	    XBoolean.prototype.stringValue = function () {
	        return this.string().stringValue();
	    };

	    XBoolean.prototype.numberValue = function () {
	        return this.number().numberValue();
	    };

	    XBoolean.prototype.booleanValue = function () {
	        return this.b;
	    };

	    XBoolean.prototype.not = function () {
	        return new XBoolean(!this.b);
	    };

	    XBoolean.prototype.equals = function (r) {
	        if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
	            return this.equals(r.bool());
	        }
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithBoolean(this, Operators.equals);
	        }
	        return new XBoolean(this.b == r.b);
	    };

	    XBoolean.prototype.notequal = function (r) {
	        if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
	            return this.notequal(r.bool());
	        }
	        if (Utilities.instance_of(r, XNodeSet)) {
	            return r.compareWithBoolean(this, Operators.notequal);
	        }
	        return new XBoolean(this.b != r.b);
	    };

	    XBoolean.prototype.lessthan = function (r) {
	        return this.number().lessthan(r);
	    };

	    XBoolean.prototype.greaterthan = function (r) {
	        return this.number().greaterthan(r);
	    };

	    XBoolean.prototype.lessthanorequal = function (r) {
	        return this.number().lessthanorequal(r);
	    };

	    XBoolean.prototype.greaterthanorequal = function (r) {
	        return this.number().greaterthanorequal(r);
	    };

	    XBoolean.true_ = new XBoolean(true);
	    XBoolean.false_ = new XBoolean(false);

	    // AVLTree ///////////////////////////////////////////////////////////////////

	    AVLTree.prototype = new Object();
	    AVLTree.prototype.constructor = AVLTree;
	    AVLTree.superclass = Object.prototype;

	    function AVLTree(n) {
	        this.init(n);
	    }

	    AVLTree.prototype.init = function (n) {
	        this.left = null;
	        this.right = null;
	        this.node = n;
	        this.depth = 1;
	    };

	    AVLTree.prototype.balance = function () {
	        var ldepth = this.left == null ? 0 : this.left.depth;
	        var rdepth = this.right == null ? 0 : this.right.depth;

	        if (ldepth > rdepth + 1) {
	            // LR or LL rotation
	            var lldepth = this.left.left == null ? 0 : this.left.left.depth;
	            var lrdepth = this.left.right == null ? 0 : this.left.right.depth;

	            if (lldepth < lrdepth) {
	                // LR rotation consists of a RR rotation of the left child
	                this.left.rotateRR();
	                // plus a LL rotation of this node, which happens anyway
	            }
	            this.rotateLL();
	        } else if (ldepth + 1 < rdepth) {
	            // RR or RL rorarion
	            var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
	            var rldepth = this.right.left == null ? 0 : this.right.left.depth;

	            if (rldepth > rrdepth) {
	                // RR rotation consists of a LL rotation of the right child
	                this.right.rotateLL();
	                // plus a RR rotation of this node, which happens anyway
	            }
	            this.rotateRR();
	        }
	    };

	    AVLTree.prototype.rotateLL = function () {
	        // the left side is too long => rotate from the left (_not_ leftwards)
	        var nodeBefore = this.node;
	        var rightBefore = this.right;
	        this.node = this.left.node;
	        this.right = this.left;
	        this.left = this.left.left;
	        this.right.left = this.right.right;
	        this.right.right = rightBefore;
	        this.right.node = nodeBefore;
	        this.right.updateInNewLocation();
	        this.updateInNewLocation();
	    };

	    AVLTree.prototype.rotateRR = function () {
	        // the right side is too long => rotate from the right (_not_ rightwards)
	        var nodeBefore = this.node;
	        var leftBefore = this.left;
	        this.node = this.right.node;
	        this.left = this.right;
	        this.right = this.right.right;
	        this.left.right = this.left.left;
	        this.left.left = leftBefore;
	        this.left.node = nodeBefore;
	        this.left.updateInNewLocation();
	        this.updateInNewLocation();
	    };

	    AVLTree.prototype.updateInNewLocation = function () {
	        this.getDepthFromChildren();
	    };

	    AVLTree.prototype.getDepthFromChildren = function () {
	        this.depth = this.node == null ? 0 : 1;
	        if (this.left != null) {
	            this.depth = this.left.depth + 1;
	        }
	        if (this.right != null && this.depth <= this.right.depth) {
	            this.depth = this.right.depth + 1;
	        }
	    };

	    function nodeOrder(n1, n2) {
	        if (n1 === n2) {
	            return 0;
	        }

	        if (n1.compareDocumentPosition) {
	            var cpos = n1.compareDocumentPosition(n2);

	            if (cpos & 0x01) {
	                // not in the same document; return an arbitrary result (is there a better way to do this)
	                return 1;
	            }
	            if (cpos & 0x0A) {
	                // n2 precedes or contains n1
	                return 1;
	            }
	            if (cpos & 0x14) {
	                // n2 follows or is contained by n1
	                return -1;
	            }

	            return 0;
	        }

	        var d1 = 0,
	            d2 = 0;
	        for (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) {
	            d1++;
	        }
	        for (var m2 = n2; m2 != null; m2 = m2.parentNode || m2.ownerElement) {
	            d2++;
	        }

	        // step up to same depth
	        if (d1 > d2) {
	            while (d1 > d2) {
	                n1 = n1.parentNode || n1.ownerElement;
	                d1--;
	            }
	            if (n1 === n2) {
	                return 1;
	            }
	        } else if (d2 > d1) {
	            while (d2 > d1) {
	                n2 = n2.parentNode || n2.ownerElement;
	                d2--;
	            }
	            if (n1 === n2) {
	                return -1;
	            }
	        }

	        var n1Par = n1.parentNode || n1.ownerElement,
	            n2Par = n2.parentNode || n2.ownerElement;

	        // find common parent
	        while (n1Par !== n2Par) {
	            n1 = n1Par;
	            n2 = n2Par;
	            n1Par = n1.parentNode || n1.ownerElement;
	            n2Par = n2.parentNode || n2.ownerElement;
	        }

	        var n1isAttr = isAttributeLike(n1);
	        var n2isAttr = isAttributeLike(n2);

	        if (n1isAttr && !n2isAttr) {
	            return -1;
	        }
	        if (!n1isAttr && n2isAttr) {
	            return 1;
	        }

	        // xml namespace node comes before others. namespace nodes before non-namespace nodes
	        if (n1.isXPathNamespace) {
	            if (n1.nodeValue === XPath.XML_NAMESPACE_URI) {
	                return -1;
	            }

	            if (!n2.isXPathNamespace) {
	                return -1;
	            }

	            if (n2.nodeValue === XPath.XML_NAMESPACE_URI) {
	                return 1;
	            }
	        } else if (n2.isXPathNamespace) {
	            return 1;
	        }

	        if (n1Par) {
	            var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes;
	            var len = cn.length;
	            var n1Compare = n1.baseNode || n1;
	            var n2Compare = n2.baseNode || n2;

	            for (var i = 0; i < len; i += 1) {
	                var n = cn[i];
	                if (n === n1Compare) {
	                    return -1;
	                }
	                if (n === n2Compare) {
	                    return 1;
	                }
	            }
	        }

	        throw new Error('Unexpected: could not determine node order');
	    }

	    AVLTree.prototype.add = function (n) {
	        if (n === this.node) {
	            return false;
	        }

	        var o = nodeOrder(n, this.node);

	        var ret = false;
	        if (o == -1) {
	            if (this.left == null) {
	                this.left = new AVLTree(n);
	                ret = true;
	            } else {
	                ret = this.left.add(n);
	                if (ret) {
	                    this.balance();
	                }
	            }
	        } else if (o == 1) {
	            if (this.right == null) {
	                this.right = new AVLTree(n);
	                ret = true;
	            } else {
	                ret = this.right.add(n);
	                if (ret) {
	                    this.balance();
	                }
	            }
	        }

	        if (ret) {
	            this.getDepthFromChildren();
	        }
	        return ret;
	    };

	    // XNodeSet //////////////////////////////////////////////////////////////////

	    XNodeSet.prototype = new Expression();
	    XNodeSet.prototype.constructor = XNodeSet;
	    XNodeSet.superclass = Expression.prototype;

	    function XNodeSet() {
	        this.init();
	    }

	    XNodeSet.prototype.init = function () {
	        this.tree = null;
	        this.nodes = [];
	        this.size = 0;
	    };

	    XNodeSet.prototype.toString = function () {
	        var p = this.first();
	        if (p == null) {
	            return "";
	        }
	        return this.stringForNode(p);
	    };

	    XNodeSet.prototype.evaluate = function (c) {
	        return this;
	    };

	    XNodeSet.prototype.string = function () {
	        return new XString(this.toString());
	    };

	    XNodeSet.prototype.stringValue = function () {
	        return this.toString();
	    };

	    XNodeSet.prototype.number = function () {
	        return new XNumber(this.string());
	    };

	    XNodeSet.prototype.numberValue = function () {
	        return Number(this.string());
	    };

	    XNodeSet.prototype.bool = function () {
	        return new XBoolean(this.booleanValue());
	    };

	    XNodeSet.prototype.booleanValue = function () {
	        return !!this.size;
	    };

	    XNodeSet.prototype.nodeset = function () {
	        return this;
	    };

	    XNodeSet.prototype.stringForNode = function (n) {
	        if (n.nodeType == NodeTypes.DOCUMENT_NODE ||
	            n.nodeType == NodeTypes.ELEMENT_NODE ||
	            n.nodeType === NodeTypes.DOCUMENT_FRAGMENT_NODE) {
	            return this.stringForContainerNode(n);
	        }
	        if (n.nodeType === NodeTypes.ATTRIBUTE_NODE) {
	            return n.value || n.nodeValue;
	        }
	        if (n.isNamespaceNode) {
	            return n.namespace;
	        }
	        return n.nodeValue;
	    };

	    XNodeSet.prototype.stringForContainerNode = function (n) {
	        var s = "";
	        for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
	            var nt = n2.nodeType;
	            //  Element,    Text,       CDATA,      Document,   Document Fragment
	            if (nt === 1 || nt === 3 || nt === 4 || nt === 9 || nt === 11) {
	                s += this.stringForNode(n2);
	            }
	        }
	        return s;
	    };

	    XNodeSet.prototype.buildTree = function () {
	        if (!this.tree && this.nodes.length) {
	            this.tree = new AVLTree(this.nodes[0]);
	            for (var i = 1; i < this.nodes.length; i += 1) {
	                this.tree.add(this.nodes[i]);
	            }
	        }

	        return this.tree;
	    };

	    XNodeSet.prototype.first = function () {
	        var p = this.buildTree();
	        if (p == null) {
	            return null;
	        }
	        while (p.left != null) {
	            p = p.left;
	        }
	        return p.node;
	    };

	    XNodeSet.prototype.add = function (n) {
	        for (var i = 0; i < this.nodes.length; i += 1) {
	            if (n === this.nodes[i]) {
	                return;
	            }
	        }

	        this.tree = null;
	        this.nodes.push(n);
	        this.size += 1;
	    };

	    XNodeSet.prototype.addArray = function (ns) {
	        var self = this;

	        forEach(function (x) { self.add(x); }, ns);
	    };

	    /**
	     * Returns an array of the node set's contents in document order
	     */
	    XNodeSet.prototype.toArray = function () {
	        var a = [];
	        this.toArrayRec(this.buildTree(), a);
	        return a;
	    };

	    XNodeSet.prototype.toArrayRec = function (t, a) {
	        if (t != null) {
	            this.toArrayRec(t.left, a);
	            a.push(t.node);
	            this.toArrayRec(t.right, a);
	        }
	    };

	    /**
	     * Returns an array of the node set's contents in arbitrary order
	     */
	    XNodeSet.prototype.toUnsortedArray = function () {
	        return this.nodes.slice();
	    };

	    XNodeSet.prototype.compareWithString = function (r, o) {
	        var a = this.toUnsortedArray();
	        for (var i = 0; i < a.length; i++) {
	            var n = a[i];
	            var l = new XString(this.stringForNode(n));
	            var res = o(l, r);
	            if (res.booleanValue()) {
	                return res;
	            }
	        }
	        return new XBoolean(false);
	    };

	    XNodeSet.prototype.compareWithNumber = function (r, o) {
	        var a = this.toUnsortedArray();
	        for (var i = 0; i < a.length; i++) {
	            var n = a[i];
	            var l = new XNumber(this.stringForNode(n));
	            var res = o(l, r);
	            if (res.booleanValue()) {
	                return res;
	            }
	        }
	        return new XBoolean(false);
	    };

	    XNodeSet.prototype.compareWithBoolean = function (r, o) {
	        return o(this.bool(), r);
	    };

	    XNodeSet.prototype.compareWithNodeSet = function (r, o) {
	        var arr = this.toUnsortedArray();
	        var oInvert = function (lop, rop) { return o(rop, lop); };

	        for (var i = 0; i < arr.length; i++) {
	            var l = new XString(this.stringForNode(arr[i]));

	            var res = r.compareWithString(l, oInvert);
	            if (res.booleanValue()) {
	                return res;
	            }
	        }

	        return new XBoolean(false);
	    };

	    XNodeSet.compareWith = curry(function (o, r) {
	        if (Utilities.instance_of(r, XString)) {
	            return this.compareWithString(r, o);
	        }
	        if (Utilities.instance_of(r, XNumber)) {
	            return this.compareWithNumber(r, o);
	        }
	        if (Utilities.instance_of(r, XBoolean)) {
	            return this.compareWithBoolean(r, o);
	        }
	        return this.compareWithNodeSet(r, o);
	    });

	    XNodeSet.prototype.equals = XNodeSet.compareWith(Operators.equals);
	    XNodeSet.prototype.notequal = XNodeSet.compareWith(Operators.notequal);
	    XNodeSet.prototype.lessthan = XNodeSet.compareWith(Operators.lessthan);
	    XNodeSet.prototype.greaterthan = XNodeSet.compareWith(Operators.greaterthan);
	    XNodeSet.prototype.lessthanorequal = XNodeSet.compareWith(Operators.lessthanorequal);
	    XNodeSet.prototype.greaterthanorequal = XNodeSet.compareWith(Operators.greaterthanorequal);

	    XNodeSet.prototype.union = function (r) {
	        var ns = new XNodeSet();
	        ns.addArray(this.toUnsortedArray());
	        ns.addArray(r.toUnsortedArray());
	        return ns;
	    };

	    // XPathNamespace ////////////////////////////////////////////////////////////

	    XPathNamespace.prototype = new Object();
	    XPathNamespace.prototype.constructor = XPathNamespace;
	    XPathNamespace.superclass = Object.prototype;

	    function XPathNamespace(pre, node, uri, p) {
	        this.isXPathNamespace = true;
	        this.baseNode = node;
	        this.ownerDocument = p.ownerDocument;
	        this.nodeName = pre;
	        this.prefix = pre;
	        this.localName = pre;
	        this.namespaceURI = null;
	        this.nodeValue = uri;
	        this.ownerElement = p;
	        this.nodeType = NodeTypes.NAMESPACE_NODE;
	    }

	    XPathNamespace.prototype.toString = function () {
	        return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
	    };

	    // XPathContext //////////////////////////////////////////////////////////////

	    XPathContext.prototype = new Object();
	    XPathContext.prototype.constructor = XPathContext;
	    XPathContext.superclass = Object.prototype;

	    function XPathContext(vr, nr, fr) {
	        this.variableResolver = vr != null ? vr : new VariableResolver();
	        this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
	        this.functionResolver = fr != null ? fr : new FunctionResolver();
	    }

	    XPathContext.prototype.extend = function (newProps) {
	        return assign(new XPathContext(), this, newProps);
	    };

	    // VariableResolver //////////////////////////////////////////////////////////

	    VariableResolver.prototype = new Object();
	    VariableResolver.prototype.constructor = VariableResolver;
	    VariableResolver.superclass = Object.prototype;

	    function VariableResolver() {
	    }

	    VariableResolver.prototype.getVariable = function (ln, ns) {
	        return null;
	    };

	    // FunctionResolver //////////////////////////////////////////////////////////

	    FunctionResolver.prototype = new Object();
	    FunctionResolver.prototype.constructor = FunctionResolver;
	    FunctionResolver.superclass = Object.prototype;

	    function FunctionResolver(thisArg) {
	        this.thisArg = thisArg != null ? thisArg : Functions;
	        this.functions = new Object();
	        this.addStandardFunctions();
	    }

	    FunctionResolver.prototype.addStandardFunctions = function () {
	        this.functions["{}last"] = Functions.last;
	        this.functions["{}position"] = Functions.position;
	        this.functions["{}count"] = Functions.count;
	        this.functions["{}id"] = Functions.id;
	        this.functions["{}local-name"] = Functions.localName;
	        this.functions["{}namespace-uri"] = Functions.namespaceURI;
	        this.functions["{}name"] = Functions.name;
	        this.functions["{}string"] = Functions.string;
	        this.functions["{}concat"] = Functions.concat;
	        this.functions["{}starts-with"] = Functions.startsWith;
	        this.functions["{}contains"] = Functions.contains;
	        this.functions["{}substring-before"] = Functions.substringBefore;
	        this.functions["{}substring-after"] = Functions.substringAfter;
	        this.functions["{}substring"] = Functions.substring;
	        this.functions["{}string-length"] = Functions.stringLength;
	        this.functions["{}normalize-space"] = Functions.normalizeSpace;
	        this.functions["{}translate"] = Functions.translate;
	        this.functions["{}boolean"] = Functions.boolean_;
	        this.functions["{}not"] = Functions.not;
	        this.functions["{}true"] = Functions.true_;
	        this.functions["{}false"] = Functions.false_;
	        this.functions["{}lang"] = Functions.lang;
	        this.functions["{}number"] = Functions.number;
	        this.functions["{}sum"] = Functions.sum;
	        this.functions["{}floor"] = Functions.floor;
	        this.functions["{}ceiling"] = Functions.ceiling;
	        this.functions["{}round"] = Functions.round;
	    };

	    FunctionResolver.prototype.addFunction = function (ns, ln, f) {
	        this.functions["{" + ns + "}" + ln] = f;
	    };

	    FunctionResolver.getFunctionFromContext = function (qName, context) {
	        var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);

	        if (parts[0] === null) {
	            throw new Error("Cannot resolve QName " + name);
	        }

	        return context.functionResolver.getFunction(parts[1], parts[0]);
	    };

	    FunctionResolver.prototype.getFunction = function (localName, namespace) {
	        return this.functions["{" + namespace + "}" + localName];
	    };

	    // NamespaceResolver /////////////////////////////////////////////////////////

	    NamespaceResolver.prototype = new Object();
	    NamespaceResolver.prototype.constructor = NamespaceResolver;
	    NamespaceResolver.superclass = Object.prototype;

	    function NamespaceResolver() {
	    }

	    NamespaceResolver.prototype.getNamespace = function (prefix, n) {
	        if (prefix == "xml") {
	            return XPath.XML_NAMESPACE_URI;
	        } else if (prefix == "xmlns") {
	            return XPath.XMLNS_NAMESPACE_URI;
	        }
	        if (n.nodeType == NodeTypes.DOCUMENT_NODE) {
	            n = n.documentElement;
	        } else if (n.nodeType == NodeTypes.ATTRIBUTE_NODE) {
	            n = PathExpr.getOwnerElement(n);
	        } else if (n.nodeType != NodeTypes.ELEMENT_NODE) {
	            n = n.parentNode;
	        }
	        while (n != null && n.nodeType == NodeTypes.ELEMENT_NODE) {
	            var nnm = n.attributes;
	            for (var i = 0; i < nnm.length; i++) {
	                var a = nnm.item(i);
	                var aname = a.name || a.nodeName;
	                if ((aname === "xmlns" && prefix === "")
	                    || aname === "xmlns:" + prefix) {
	                    return String(a.value || a.nodeValue);
	                }
	            }
	            n = n.parentNode;
	        }
	        return null;
	    };

	    // Functions /////////////////////////////////////////////////////////////////

	    var Functions = new Object();

	    Functions.last = function (c) {
	        if (arguments.length != 1) {
	            throw new Error("Function last expects ()");
	        }

	        return new XNumber(c.contextSize);
	    };

	    Functions.position = function (c) {
	        if (arguments.length != 1) {
	            throw new Error("Function position expects ()");
	        }

	        return new XNumber(c.contextPosition);
	    };

	    Functions.count = function () {
	        var c = arguments[0];
	        var ns;
	        if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
	            throw new Error("Function count expects (node-set)");
	        }
	        return new XNumber(ns.size);
	    };

	    Functions.id = function () {
	        var c = arguments[0];
	        var id;
	        if (arguments.length != 2) {
	            throw new Error("Function id expects (object)");
	        }
	        id = arguments[1].evaluate(c);
	        if (Utilities.instance_of(id, XNodeSet)) {
	            id = id.toArray().join(" ");
	        } else {
	            id = id.stringValue();
	        }
	        var ids = id.split(/[\x0d\x0a\x09\x20]+/);
	        var count = 0;
	        var ns = new XNodeSet();
	        var doc = c.contextNode.nodeType == NodeTypes.DOCUMENT_NODE
	            ? c.contextNode
	            : c.contextNode.ownerDocument;
	        for (var i = 0; i < ids.length; i++) {
	            var n;
	            if (doc.getElementById) {
	                n = doc.getElementById(ids[i]);
	            } else {
	                n = Utilities.getElementById(doc, ids[i]);
	            }
	            if (n != null) {
	                ns.add(n);
	                count++;
	            }
	        }
	        return ns;
	    };

	    Functions.localName = function (c, eNode) {
	        var n;

	        if (arguments.length == 1) {
	            n = c.contextNode;
	        } else if (arguments.length == 2) {
	            n = eNode.evaluate(c).first();
	        } else {
	            throw new Error("Function local-name expects (node-set?)");
	        }

	        if (n == null) {
	            return new XString("");
	        }

	        return new XString(
	            n.localName ||     //  standard elements and attributes
	            n.baseName ||     //  IE
	            n.target ||     //  processing instructions
	            n.nodeName ||     //  DOM1 elements
	            ""                 //  fallback
	        );
	    };

	    Functions.namespaceURI = function () {
	        var c = arguments[0];
	        var n;

	        if (arguments.length == 1) {
	            n = c.contextNode;
	        } else if (arguments.length == 2) {
	            n = arguments[1].evaluate(c).first();
	        } else {
	            throw new Error("Function namespace-uri expects (node-set?)");
	        }

	        if (n == null) {
	            return new XString("");
	        }
	        return new XString(n.namespaceURI || '');
	    };

	    Functions.name = function () {
	        var c = arguments[0];
	        var n;
	        if (arguments.length == 1) {
	            n = c.contextNode;
	        } else if (arguments.length == 2) {
	            n = arguments[1].evaluate(c).first();
	        } else {
	            throw new Error("Function name expects (node-set?)");
	        }
	        if (n == null) {
	            return new XString("");
	        }
	        if (n.nodeType == NodeTypes.ELEMENT_NODE) {
	            return new XString(n.nodeName);
	        } else if (n.nodeType == NodeTypes.ATTRIBUTE_NODE) {
	            return new XString(n.name || n.nodeName);
	        } else if (n.nodeType === NodeTypes.PROCESSING_INSTRUCTION_NODE) {
	            return new XString(n.target || n.nodeName);
	        } else if (n.localName == null) {
	            return new XString("");
	        } else {
	            return new XString(n.localName);
	        }
	    };

	    Functions.string = function () {
	        var c = arguments[0];
	        if (arguments.length == 1) {
	            return new XString(XNodeSet.prototype.stringForNode(c.contextNode));
	        } else if (arguments.length == 2) {
	            return arguments[1].evaluate(c).string();
	        }
	        throw new Error("Function string expects (object?)");
	    };

	    Functions.concat = function (c) {
	        if (arguments.length < 3) {
	            throw new Error("Function concat expects (string, string[, string]*)");
	        }
	        var s = "";
	        for (var i = 1; i < arguments.length; i++) {
	            s += arguments[i].evaluate(c).stringValue();
	        }
	        return new XString(s);
	    };

	    Functions.startsWith = function () {
	        var c = arguments[0];
	        if (arguments.length != 3) {
	            throw new Error("Function startsWith expects (string, string)");
	        }
	        var s1 = arguments[1].evaluate(c).stringValue();
	        var s2 = arguments[2].evaluate(c).stringValue();
	        return new XBoolean(s1.substring(0, s2.length) == s2);
	    };

	    Functions.contains = function () {
	        var c = arguments[0];
	        if (arguments.length != 3) {
	            throw new Error("Function contains expects (string, string)");
	        }
	        var s1 = arguments[1].evaluate(c).stringValue();
	        var s2 = arguments[2].evaluate(c).stringValue();
	        return new XBoolean(s1.indexOf(s2) !== -1);
	    };

	    Functions.substringBefore = function () {
	        var c = arguments[0];
	        if (arguments.length != 3) {
	            throw new Error("Function substring-before expects (string, string)");
	        }
	        var s1 = arguments[1].evaluate(c).stringValue();
	        var s2 = arguments[2].evaluate(c).stringValue();
	        return new XString(s1.substring(0, s1.indexOf(s2)));
	    };

	    Functions.substringAfter = function () {
	        var c = arguments[0];
	        if (arguments.length != 3) {
	            throw new Error("Function substring-after expects (string, string)");
	        }
	        var s1 = arguments[1].evaluate(c).stringValue();
	        var s2 = arguments[2].evaluate(c).stringValue();
	        if (s2.length == 0) {
	            return new XString(s1);
	        }
	        var i = s1.indexOf(s2);
	        if (i == -1) {
	            return new XString("");
	        }
	        return new XString(s1.substring(i + s2.length));
	    };

	    Functions.substring = function () {
	        var c = arguments[0];
	        if (!(arguments.length == 3 || arguments.length == 4)) {
	            throw new Error("Function substring expects (string, number, number?)");
	        }
	        var s = arguments[1].evaluate(c).stringValue();
	        var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
	        var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
	        return new XString(s.substring(n1, n2));
	    };

	    Functions.stringLength = function () {
	        var c = arguments[0];
	        var s;
	        if (arguments.length == 1) {
	            s = XNodeSet.prototype.stringForNode(c.contextNode);
	        } else if (arguments.length == 2) {
	            s = arguments[1].evaluate(c).stringValue();
	        } else {
	            throw new Error("Function string-length expects (string?)");
	        }
	        return new XNumber(s.length);
	    };

	    Functions.normalizeSpace = function () {
	        var c = arguments[0];
	        var s;
	        if (arguments.length == 1) {
	            s = XNodeSet.prototype.stringForNode(c.contextNode);
	        } else if (arguments.length == 2) {
	            s = arguments[1].evaluate(c).stringValue();
	        } else {
	            throw new Error("Function normalize-space expects (string?)");
	        }
	        var i = 0;
	        var j = s.length - 1;
	        while (Utilities.isSpace(s.charCodeAt(j))) {
	            j--;
	        }
	        var t = "";
	        while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
	            i++;
	        }
	        while (i <= j) {
	            if (Utilities.isSpace(s.charCodeAt(i))) {
	                t += " ";
	                while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
	                    i++;
	                }
	            } else {
	                t += s.charAt(i);
	                i++;
	            }
	        }
	        return new XString(t);
	    };

	    Functions.translate = function (c, eValue, eFrom, eTo) {
	        if (arguments.length != 4) {
	            throw new Error("Function translate expects (string, string, string)");
	        }

	        var value = eValue.evaluate(c).stringValue();
	        var from = eFrom.evaluate(c).stringValue();
	        var to = eTo.evaluate(c).stringValue();

	        var cMap = reduce(function (acc, ch, i) {
	            if (!(ch in acc)) {
	                acc[ch] = i > to.length ? '' : to[i];
	            }
	            return acc;
	        }, {}, from);

	        var t = join(
	            '',
	            map(function (ch) {
	                return ch in cMap ? cMap[ch] : ch;
	            }, value)
	        );

	        return new XString(t);
	    };

	    Functions.boolean_ = function () {
	        var c = arguments[0];
	        if (arguments.length != 2) {
	            throw new Error("Function boolean expects (object)");
	        }
	        return arguments[1].evaluate(c).bool();
	    };

	    Functions.not = function (c, eValue) {
	        if (arguments.length != 2) {
	            throw new Error("Function not expects (object)");
	        }
	        return eValue.evaluate(c).bool().not();
	    };

	    Functions.true_ = function () {
	        if (arguments.length != 1) {
	            throw new Error("Function true expects ()");
	        }
	        return XBoolean.true_;
	    };

	    Functions.false_ = function () {
	        if (arguments.length != 1) {
	            throw new Error("Function false expects ()");
	        }
	        return XBoolean.false_;
	    };

	    Functions.lang = function () {
	        var c = arguments[0];
	        if (arguments.length != 2) {
	            throw new Error("Function lang expects (string)");
	        }
	        var lang;
	        for (var n = c.contextNode; n != null && n.nodeType != NodeTypes.DOCUMENT_NODE; n = n.parentNode) {
	            var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
	            if (a != null) {
	                lang = String(a);
	                break;
	            }
	        }
	        if (lang == null) {
	            return XBoolean.false_;
	        }
	        var s = arguments[1].evaluate(c).stringValue();
	        return new XBoolean(lang.substring(0, s.length) == s
	            && (lang.length == s.length || lang.charAt(s.length) == '-'));
	    };

	    Functions.number = function () {
	        var c = arguments[0];
	        if (!(arguments.length == 1 || arguments.length == 2)) {
	            throw new Error("Function number expects (object?)");
	        }
	        if (arguments.length == 1) {
	            return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
	        }
	        return arguments[1].evaluate(c).number();
	    };

	    Functions.sum = function () {
	        var c = arguments[0];
	        var ns;
	        if (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {
	            throw new Error("Function sum expects (node-set)");
	        }
	        ns = ns.toUnsortedArray();
	        var n = 0;
	        for (var i = 0; i < ns.length; i++) {
	            n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
	        }
	        return new XNumber(n);
	    };

	    Functions.floor = function () {
	        var c = arguments[0];
	        if (arguments.length != 2) {
	            throw new Error("Function floor expects (number)");
	        }
	        return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
	    };

	    Functions.ceiling = function () {
	        var c = arguments[0];
	        if (arguments.length != 2) {
	            throw new Error("Function ceiling expects (number)");
	        }
	        return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
	    };

	    Functions.round = function () {
	        var c = arguments[0];
	        if (arguments.length != 2) {
	            throw new Error("Function round expects (number)");
	        }
	        return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
	    };

	    // Utilities /////////////////////////////////////////////////////////////////

	    var Utilities = new Object();

	    // Returns true if the node is an attribute node or namespace node
	    var isAttributeLike = function (val) {
	        return val && (
	            val.nodeType === NodeTypes.ATTRIBUTE_NODE ||
	            val.ownerElement ||
	            val.isXPathNamespace
	        );
	    };

	    Utilities.splitQName = function (qn) {
	        var i = qn.indexOf(":");
	        if (i == -1) {
	            return [null, qn];
	        }
	        return [qn.substring(0, i), qn.substring(i + 1)];
	    };

	    Utilities.resolveQName = function (qn, nr, n, useDefault) {
	        var parts = Utilities.splitQName(qn);
	        if (parts[0] != null) {
	            parts[0] = nr.getNamespace(parts[0], n);
	        } else {
	            if (useDefault) {
	                parts[0] = nr.getNamespace("", n);
	                if (parts[0] == null) {
	                    parts[0] = "";
	                }
	            } else {
	                parts[0] = "";
	            }
	        }
	        return parts;
	    };

	    Utilities.isSpace = function (c) {
	        return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
	    };

	    Utilities.isLetter = function (c) {
	        return c >= 0x0041 && c <= 0x005A ||
	            c >= 0x0061 && c <= 0x007A ||
	            c >= 0x00C0 && c <= 0x00D6 ||
	            c >= 0x00D8 && c <= 0x00F6 ||
	            c >= 0x00F8 && c <= 0x00FF ||
	            c >= 0x0100 && c <= 0x0131 ||
	            c >= 0x0134 && c <= 0x013E ||
	            c >= 0x0141 && c <= 0x0148 ||
	            c >= 0x014A && c <= 0x017E ||
	            c >= 0x0180 && c <= 0x01C3 ||
	            c >= 0x01CD && c <= 0x01F0 ||
	            c >= 0x01F4 && c <= 0x01F5 ||
	            c >= 0x01FA && c <= 0x0217 ||
	            c >= 0x0250 && c <= 0x02A8 ||
	            c >= 0x02BB && c <= 0x02C1 ||
	            c == 0x0386 ||
	            c >= 0x0388 && c <= 0x038A ||
	            c == 0x038C ||
	            c >= 0x038E && c <= 0x03A1 ||
	            c >= 0x03A3 && c <= 0x03CE ||
	            c >= 0x03D0 && c <= 0x03D6 ||
	            c == 0x03DA ||
	            c == 0x03DC ||
	            c == 0x03DE ||
	            c == 0x03E0 ||
	            c >= 0x03E2 && c <= 0x03F3 ||
	            c >= 0x0401 && c <= 0x040C ||
	            c >= 0x040E && c <= 0x044F ||
	            c >= 0x0451 && c <= 0x045C ||
	            c >= 0x045E && c <= 0x0481 ||
	            c >= 0x0490 && c <= 0x04C4 ||
	            c >= 0x04C7 && c <= 0x04C8 ||
	            c >= 0x04CB && c <= 0x04CC ||
	            c >= 0x04D0 && c <= 0x04EB ||
	            c >= 0x04EE && c <= 0x04F5 ||
	            c >= 0x04F8 && c <= 0x04F9 ||
	            c >= 0x0531 && c <= 0x0556 ||
	            c == 0x0559 ||
	            c >= 0x0561 && c <= 0x0586 ||
	            c >= 0x05D0 && c <= 0x05EA ||
	            c >= 0x05F0 && c <= 0x05F2 ||
	            c >= 0x0621 && c <= 0x063A ||
	            c >= 0x0641 && c <= 0x064A ||
	            c >= 0x0671 && c <= 0x06B7 ||
	            c >= 0x06BA && c <= 0x06BE ||
	            c >= 0x06C0 && c <= 0x06CE ||
	            c >= 0x06D0 && c <= 0x06D3 ||
	            c == 0x06D5 ||
	            c >= 0x06E5 && c <= 0x06E6 ||
	            c >= 0x0905 && c <= 0x0939 ||
	            c == 0x093D ||
	            c >= 0x0958 && c <= 0x0961 ||
	            c >= 0x0985 && c <= 0x098C ||
	            c >= 0x098F && c <= 0x0990 ||
	            c >= 0x0993 && c <= 0x09A8 ||
	            c >= 0x09AA && c <= 0x09B0 ||
	            c == 0x09B2 ||
	            c >= 0x09B6 && c <= 0x09B9 ||
	            c >= 0x09DC && c <= 0x09DD ||
	            c >= 0x09DF && c <= 0x09E1 ||
	            c >= 0x09F0 && c <= 0x09F1 ||
	            c >= 0x0A05 && c <= 0x0A0A ||
	            c >= 0x0A0F && c <= 0x0A10 ||
	            c >= 0x0A13 && c <= 0x0A28 ||
	            c >= 0x0A2A && c <= 0x0A30 ||
	            c >= 0x0A32 && c <= 0x0A33 ||
	            c >= 0x0A35 && c <= 0x0A36 ||
	            c >= 0x0A38 && c <= 0x0A39 ||
	            c >= 0x0A59 && c <= 0x0A5C ||
	            c == 0x0A5E ||
	            c >= 0x0A72 && c <= 0x0A74 ||
	            c >= 0x0A85 && c <= 0x0A8B ||
	            c == 0x0A8D ||
	            c >= 0x0A8F && c <= 0x0A91 ||
	            c >= 0x0A93 && c <= 0x0AA8 ||
	            c >= 0x0AAA && c <= 0x0AB0 ||
	            c >= 0x0AB2 && c <= 0x0AB3 ||
	            c >= 0x0AB5 && c <= 0x0AB9 ||
	            c == 0x0ABD ||
	            c == 0x0AE0 ||
	            c >= 0x0B05 && c <= 0x0B0C ||
	            c >= 0x0B0F && c <= 0x0B10 ||
	            c >= 0x0B13 && c <= 0x0B28 ||
	            c >= 0x0B2A && c <= 0x0B30 ||
	            c >= 0x0B32 && c <= 0x0B33 ||
	            c >= 0x0B36 && c <= 0x0B39 ||
	            c == 0x0B3D ||
	            c >= 0x0B5C && c <= 0x0B5D ||
	            c >= 0x0B5F && c <= 0x0B61 ||
	            c >= 0x0B85 && c <= 0x0B8A ||
	            c >= 0x0B8E && c <= 0x0B90 ||
	            c >= 0x0B92 && c <= 0x0B95 ||
	            c >= 0x0B99 && c <= 0x0B9A ||
	            c == 0x0B9C ||
	            c >= 0x0B9E && c <= 0x0B9F ||
	            c >= 0x0BA3 && c <= 0x0BA4 ||
	            c >= 0x0BA8 && c <= 0x0BAA ||
	            c >= 0x0BAE && c <= 0x0BB5 ||
	            c >= 0x0BB7 && c <= 0x0BB9 ||
	            c >= 0x0C05 && c <= 0x0C0C ||
	            c >= 0x0C0E && c <= 0x0C10 ||
	            c >= 0x0C12 && c <= 0x0C28 ||
	            c >= 0x0C2A && c <= 0x0C33 ||
	            c >= 0x0C35 && c <= 0x0C39 ||
	            c >= 0x0C60 && c <= 0x0C61 ||
	            c >= 0x0C85 && c <= 0x0C8C ||
	            c >= 0x0C8E && c <= 0x0C90 ||
	            c >= 0x0C92 && c <= 0x0CA8 ||
	            c >= 0x0CAA && c <= 0x0CB3 ||
	            c >= 0x0CB5 && c <= 0x0CB9 ||
	            c == 0x0CDE ||
	            c >= 0x0CE0 && c <= 0x0CE1 ||
	            c >= 0x0D05 && c <= 0x0D0C ||
	            c >= 0x0D0E && c <= 0x0D10 ||
	            c >= 0x0D12 && c <= 0x0D28 ||
	            c >= 0x0D2A && c <= 0x0D39 ||
	            c >= 0x0D60 && c <= 0x0D61 ||
	            c >= 0x0E01 && c <= 0x0E2E ||
	            c == 0x0E30 ||
	            c >= 0x0E32 && c <= 0x0E33 ||
	            c >= 0x0E40 && c <= 0x0E45 ||
	            c >= 0x0E81 && c <= 0x0E82 ||
	            c == 0x0E84 ||
	            c >= 0x0E87 && c <= 0x0E88 ||
	            c == 0x0E8A ||
	            c == 0x0E8D ||
	            c >= 0x0E94 && c <= 0x0E97 ||
	            c >= 0x0E99 && c <= 0x0E9F ||
	            c >= 0x0EA1 && c <= 0x0EA3 ||
	            c == 0x0EA5 ||
	            c == 0x0EA7 ||
	            c >= 0x0EAA && c <= 0x0EAB ||
	            c >= 0x0EAD && c <= 0x0EAE ||
	            c == 0x0EB0 ||
	            c >= 0x0EB2 && c <= 0x0EB3 ||
	            c == 0x0EBD ||
	            c >= 0x0EC0 && c <= 0x0EC4 ||
	            c >= 0x0F40 && c <= 0x0F47 ||
	            c >= 0x0F49 && c <= 0x0F69 ||
	            c >= 0x10A0 && c <= 0x10C5 ||
	            c >= 0x10D0 && c <= 0x10F6 ||
	            c == 0x1100 ||
	            c >= 0x1102 && c <= 0x1103 ||
	            c >= 0x1105 && c <= 0x1107 ||
	            c == 0x1109 ||
	            c >= 0x110B && c <= 0x110C ||
	            c >= 0x110E && c <= 0x1112 ||
	            c == 0x113C ||
	            c == 0x113E ||
	            c == 0x1140 ||
	            c == 0x114C ||
	            c == 0x114E ||
	            c == 0x1150 ||
	            c >= 0x1154 && c <= 0x1155 ||
	            c == 0x1159 ||
	            c >= 0x115F && c <= 0x1161 ||
	            c == 0x1163 ||
	            c == 0x1165 ||
	            c == 0x1167 ||
	            c == 0x1169 ||
	            c >= 0x116D && c <= 0x116E ||
	            c >= 0x1172 && c <= 0x1173 ||
	            c == 0x1175 ||
	            c == 0x119E ||
	            c == 0x11A8 ||
	            c == 0x11AB ||
	            c >= 0x11AE && c <= 0x11AF ||
	            c >= 0x11B7 && c <= 0x11B8 ||
	            c == 0x11BA ||
	            c >= 0x11BC && c <= 0x11C2 ||
	            c == 0x11EB ||
	            c == 0x11F0 ||
	            c == 0x11F9 ||
	            c >= 0x1E00 && c <= 0x1E9B ||
	            c >= 0x1EA0 && c <= 0x1EF9 ||
	            c >= 0x1F00 && c <= 0x1F15 ||
	            c >= 0x1F18 && c <= 0x1F1D ||
	            c >= 0x1F20 && c <= 0x1F45 ||
	            c >= 0x1F48 && c <= 0x1F4D ||
	            c >= 0x1F50 && c <= 0x1F57 ||
	            c == 0x1F59 ||
	            c == 0x1F5B ||
	            c == 0x1F5D ||
	            c >= 0x1F5F && c <= 0x1F7D ||
	            c >= 0x1F80 && c <= 0x1FB4 ||
	            c >= 0x1FB6 && c <= 0x1FBC ||
	            c == 0x1FBE ||
	            c >= 0x1FC2 && c <= 0x1FC4 ||
	            c >= 0x1FC6 && c <= 0x1FCC ||
	            c >= 0x1FD0 && c <= 0x1FD3 ||
	            c >= 0x1FD6 && c <= 0x1FDB ||
	            c >= 0x1FE0 && c <= 0x1FEC ||
	            c >= 0x1FF2 && c <= 0x1FF4 ||
	            c >= 0x1FF6 && c <= 0x1FFC ||
	            c == 0x2126 ||
	            c >= 0x212A && c <= 0x212B ||
	            c == 0x212E ||
	            c >= 0x2180 && c <= 0x2182 ||
	            c >= 0x3041 && c <= 0x3094 ||
	            c >= 0x30A1 && c <= 0x30FA ||
	            c >= 0x3105 && c <= 0x312C ||
	            c >= 0xAC00 && c <= 0xD7A3 ||
	            c >= 0x4E00 && c <= 0x9FA5 ||
	            c == 0x3007 ||
	            c >= 0x3021 && c <= 0x3029;
	    };

	    Utilities.isNCNameChar = function (c) {
	        return c >= 0x0030 && c <= 0x0039
	            || c >= 0x0660 && c <= 0x0669
	            || c >= 0x06F0 && c <= 0x06F9
	            || c >= 0x0966 && c <= 0x096F
	            || c >= 0x09E6 && c <= 0x09EF
	            || c >= 0x0A66 && c <= 0x0A6F
	            || c >= 0x0AE6 && c <= 0x0AEF
	            || c >= 0x0B66 && c <= 0x0B6F
	            || c >= 0x0BE7 && c <= 0x0BEF
	            || c >= 0x0C66 && c <= 0x0C6F
	            || c >= 0x0CE6 && c <= 0x0CEF
	            || c >= 0x0D66 && c <= 0x0D6F
	            || c >= 0x0E50 && c <= 0x0E59
	            || c >= 0x0ED0 && c <= 0x0ED9
	            || c >= 0x0F20 && c <= 0x0F29
	            || c == 0x002E
	            || c == 0x002D
	            || c == 0x005F
	            || Utilities.isLetter(c)
	            || c >= 0x0300 && c <= 0x0345
	            || c >= 0x0360 && c <= 0x0361
	            || c >= 0x0483 && c <= 0x0486
	            || c >= 0x0591 && c <= 0x05A1
	            || c >= 0x05A3 && c <= 0x05B9
	            || c >= 0x05BB && c <= 0x05BD
	            || c == 0x05BF
	            || c >= 0x05C1 && c <= 0x05C2
	            || c == 0x05C4
	            || c >= 0x064B && c <= 0x0652
	            || c == 0x0670
	            || c >= 0x06D6 && c <= 0x06DC
	            || c >= 0x06DD && c <= 0x06DF
	            || c >= 0x06E0 && c <= 0x06E4
	            || c >= 0x06E7 && c <= 0x06E8
	            || c >= 0x06EA && c <= 0x06ED
	            || c >= 0x0901 && c <= 0x0903
	            || c == 0x093C
	            || c >= 0x093E && c <= 0x094C
	            || c == 0x094D
	            || c >= 0x0951 && c <= 0x0954
	            || c >= 0x0962 && c <= 0x0963
	            || c >= 0x0981 && c <= 0x0983
	            || c == 0x09BC
	            || c == 0x09BE
	            || c == 0x09BF
	            || c >= 0x09C0 && c <= 0x09C4
	            || c >= 0x09C7 && c <= 0x09C8
	            || c >= 0x09CB && c <= 0x09CD
	            || c == 0x09D7
	            || c >= 0x09E2 && c <= 0x09E3
	            || c == 0x0A02
	            || c == 0x0A3C
	            || c == 0x0A3E
	            || c == 0x0A3F
	            || c >= 0x0A40 && c <= 0x0A42
	            || c >= 0x0A47 && c <= 0x0A48
	            || c >= 0x0A4B && c <= 0x0A4D
	            || c >= 0x0A70 && c <= 0x0A71
	            || c >= 0x0A81 && c <= 0x0A83
	            || c == 0x0ABC
	            || c >= 0x0ABE && c <= 0x0AC5
	            || c >= 0x0AC7 && c <= 0x0AC9
	            || c >= 0x0ACB && c <= 0x0ACD
	            || c >= 0x0B01 && c <= 0x0B03
	            || c == 0x0B3C
	            || c >= 0x0B3E && c <= 0x0B43
	            || c >= 0x0B47 && c <= 0x0B48
	            || c >= 0x0B4B && c <= 0x0B4D
	            || c >= 0x0B56 && c <= 0x0B57
	            || c >= 0x0B82 && c <= 0x0B83
	            || c >= 0x0BBE && c <= 0x0BC2
	            || c >= 0x0BC6 && c <= 0x0BC8
	            || c >= 0x0BCA && c <= 0x0BCD
	            || c == 0x0BD7
	            || c >= 0x0C01 && c <= 0x0C03
	            || c >= 0x0C3E && c <= 0x0C44
	            || c >= 0x0C46 && c <= 0x0C48
	            || c >= 0x0C4A && c <= 0x0C4D
	            || c >= 0x0C55 && c <= 0x0C56
	            || c >= 0x0C82 && c <= 0x0C83
	            || c >= 0x0CBE && c <= 0x0CC4
	            || c >= 0x0CC6 && c <= 0x0CC8
	            || c >= 0x0CCA && c <= 0x0CCD
	            || c >= 0x0CD5 && c <= 0x0CD6
	            || c >= 0x0D02 && c <= 0x0D03
	            || c >= 0x0D3E && c <= 0x0D43
	            || c >= 0x0D46 && c <= 0x0D48
	            || c >= 0x0D4A && c <= 0x0D4D
	            || c == 0x0D57
	            || c == 0x0E31
	            || c >= 0x0E34 && c <= 0x0E3A
	            || c >= 0x0E47 && c <= 0x0E4E
	            || c == 0x0EB1
	            || c >= 0x0EB4 && c <= 0x0EB9
	            || c >= 0x0EBB && c <= 0x0EBC
	            || c >= 0x0EC8 && c <= 0x0ECD
	            || c >= 0x0F18 && c <= 0x0F19
	            || c == 0x0F35
	            || c == 0x0F37
	            || c == 0x0F39
	            || c == 0x0F3E
	            || c == 0x0F3F
	            || c >= 0x0F71 && c <= 0x0F84
	            || c >= 0x0F86 && c <= 0x0F8B
	            || c >= 0x0F90 && c <= 0x0F95
	            || c == 0x0F97
	            || c >= 0x0F99 && c <= 0x0FAD
	            || c >= 0x0FB1 && c <= 0x0FB7
	            || c == 0x0FB9
	            || c >= 0x20D0 && c <= 0x20DC
	            || c == 0x20E1
	            || c >= 0x302A && c <= 0x302F
	            || c == 0x3099
	            || c == 0x309A
	            || c == 0x00B7
	            || c == 0x02D0
	            || c == 0x02D1
	            || c == 0x0387
	            || c == 0x0640
	            || c == 0x0E46
	            || c == 0x0EC6
	            || c == 0x3005
	            || c >= 0x3031 && c <= 0x3035
	            || c >= 0x309D && c <= 0x309E
	            || c >= 0x30FC && c <= 0x30FE;
	    };

	    Utilities.coalesceText = function (n) {
	        for (var m = n.firstChild; m != null; m = m.nextSibling) {
	            if (m.nodeType == NodeTypes.TEXT_NODE || m.nodeType == NodeTypes.CDATA_SECTION_NODE) {
	                var s = m.nodeValue;
	                var first = m;
	                m = m.nextSibling;
	                while (m != null && (m.nodeType == NodeTypes.TEXT_NODE || m.nodeType == NodeTypes.CDATA_SECTION_NODE)) {
	                    s += m.nodeValue;
	                    var del = m;
	                    m = m.nextSibling;
	                    del.parentNode.removeChild(del);
	                }
	                if (first.nodeType == NodeTypes.CDATA_SECTION_NODE) {
	                    var p = first.parentNode;
	                    if (first.nextSibling == null) {
	                        p.removeChild(first);
	                        p.appendChild(p.ownerDocument.createTextNode(s));
	                    } else {
	                        var next = first.nextSibling;
	                        p.removeChild(first);
	                        p.insertBefore(p.ownerDocument.createTextNode(s), next);
	                    }
	                } else {
	                    first.nodeValue = s;
	                }
	                if (m == null) {
	                    break;
	                }
	            } else if (m.nodeType == NodeTypes.ELEMENT_NODE) {
	                Utilities.coalesceText(m);
	            }
	        }
	    };

	    Utilities.instance_of = function (o, c) {
	        while (o != null) {
	            if (o.constructor === c) {
	                return true;
	            }
	            if (o === Object) {
	                return false;
	            }
	            o = o.constructor.superclass;
	        }
	        return false;
	    };

	    Utilities.getElementById = function (n, id) {
	        // Note that this does not check the DTD to check for actual
	        // attributes of type ID, so this may be a bit wrong.
	        if (n.nodeType == NodeTypes.ELEMENT_NODE) {
	            if (n.getAttribute("id") == id
	                || n.getAttributeNS(null, "id") == id) {
	                return n;
	            }
	        }
	        for (var m = n.firstChild; m != null; m = m.nextSibling) {
	            var res = Utilities.getElementById(m, id);
	            if (res != null) {
	                return res;
	            }
	        }
	        return null;
	    };

	    // XPathException ////////////////////////////////////////////////////////////

	    var XPathException = (function () {
	        function getMessage(code, exception) {
	            var msg = exception ? ": " + exception.toString() : "";
	            switch (code) {
	                case XPathException.INVALID_EXPRESSION_ERR:
	                    return "Invalid expression" + msg;
	                case XPathException.TYPE_ERR:
	                    return "Type error" + msg;
	            }
	            return null;
	        }

	        function XPathException(code, error, message) {
	            var err = Error.call(this, getMessage(code, error) || message);

	            err.code = code;
	            err.exception = error;

	            return err;
	        }

	        XPathException.prototype = Object.create(Error.prototype);
	        XPathException.prototype.constructor = XPathException;
	        XPathException.superclass = Error;

	        XPathException.prototype.toString = function () {
	            return this.message;
	        };

	        XPathException.fromMessage = function (message, error) {
	            return new XPathException(null, error, message);
	        };

	        XPathException.INVALID_EXPRESSION_ERR = 51;
	        XPathException.TYPE_ERR = 52;

	        return XPathException;
	    })();

	    // XPathExpression ///////////////////////////////////////////////////////////

	    XPathExpression.prototype = {};
	    XPathExpression.prototype.constructor = XPathExpression;
	    XPathExpression.superclass = Object.prototype;

	    function XPathExpression(e, r, p) {
	        this.xpath = p.parse(e);
	        this.context = new XPathContext();
	        this.context.namespaceResolver = new XPathNSResolverWrapper(r);
	    }

	    XPathExpression.getOwnerDocument = function (n) {
	        return n.nodeType === NodeTypes.DOCUMENT_NODE ? n : n.ownerDocument;
	    };

	    XPathExpression.detectHtmlDom = function (n) {
	        if (!n) { return false; }

	        var doc = XPathExpression.getOwnerDocument(n);

	        try {
	            return doc.implementation.hasFeature("HTML", "2.0");
	        } catch (e) {
	            return true;
	        }
	    };

	    XPathExpression.prototype.evaluate = function (n, t, res) {
	        this.context.expressionContextNode = n;
	        // backward compatibility - no reliable way to detect whether the DOM is HTML, but
	        // this library has been using this method up until now, so we will continue to use it
	        // ONLY when using an XPathExpression
	        this.context.caseInsensitive = XPathExpression.detectHtmlDom(n);

	        var result = this.xpath.evaluate(this.context);

	        return new XPathResult(result, t);
	    };

	    // XPathNSResolverWrapper ////////////////////////////////////////////////////

	    XPathNSResolverWrapper.prototype = {};
	    XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
	    XPathNSResolverWrapper.superclass = Object.prototype;

	    function XPathNSResolverWrapper(r) {
	        this.xpathNSResolver = r;
	    }

	    XPathNSResolverWrapper.prototype.getNamespace = function (prefix, n) {
	        if (this.xpathNSResolver == null) {
	            return null;
	        }
	        return this.xpathNSResolver.lookupNamespaceURI(prefix);
	    };

	    // NodeXPathNSResolver ///////////////////////////////////////////////////////

	    NodeXPathNSResolver.prototype = {};
	    NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
	    NodeXPathNSResolver.superclass = Object.prototype;

	    function NodeXPathNSResolver(n) {
	        this.node = n;
	        this.namespaceResolver = new NamespaceResolver();
	    }

	    NodeXPathNSResolver.prototype.lookupNamespaceURI = function (prefix) {
	        return this.namespaceResolver.getNamespace(prefix, this.node);
	    };

	    // XPathResult ///////////////////////////////////////////////////////////////

	    XPathResult.prototype = {};
	    XPathResult.prototype.constructor = XPathResult;
	    XPathResult.superclass = Object.prototype;

	    function XPathResult(v, t) {
	        if (t == XPathResult.ANY_TYPE) {
	            if (v.constructor === XString) {
	                t = XPathResult.STRING_TYPE;
	            } else if (v.constructor === XNumber) {
	                t = XPathResult.NUMBER_TYPE;
	            } else if (v.constructor === XBoolean) {
	                t = XPathResult.BOOLEAN_TYPE;
	            } else if (v.constructor === XNodeSet) {
	                t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
	            }
	        }
	        this.resultType = t;
	        switch (t) {
	            case XPathResult.NUMBER_TYPE:
	                this.numberValue = v.numberValue();
	                return;
	            case XPathResult.STRING_TYPE:
	                this.stringValue = v.stringValue();
	                return;
	            case XPathResult.BOOLEAN_TYPE:
	                this.booleanValue = v.booleanValue();
	                return;
	            case XPathResult.ANY_UNORDERED_NODE_TYPE:
	            case XPathResult.FIRST_ORDERED_NODE_TYPE:
	                if (v.constructor === XNodeSet) {
	                    this.singleNodeValue = v.first();
	                    return;
	                }
	                break;
	            case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
	            case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
	                if (v.constructor === XNodeSet) {
	                    this.invalidIteratorState = false;
	                    this.nodes = v.toArray();
	                    this.iteratorIndex = 0;
	                    return;
	                }
	                break;
	            case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
	            case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
	                if (v.constructor === XNodeSet) {
	                    this.nodes = v.toArray();
	                    this.snapshotLength = this.nodes.length;
	                    return;
	                }
	                break;
	        }
	        throw new XPathException(XPathException.TYPE_ERR);
	    };

	    XPathResult.prototype.iterateNext = function () {
	        if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE
	            && this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
	            throw new XPathException(XPathException.TYPE_ERR);
	        }
	        return this.nodes[this.iteratorIndex++];
	    };

	    XPathResult.prototype.snapshotItem = function (i) {
	        if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE
	            && this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
	            throw new XPathException(XPathException.TYPE_ERR);
	        }
	        return this.nodes[i];
	    };

	    XPathResult.ANY_TYPE = 0;
	    XPathResult.NUMBER_TYPE = 1;
	    XPathResult.STRING_TYPE = 2;
	    XPathResult.BOOLEAN_TYPE = 3;
	    XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
	    XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
	    XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
	    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
	    XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
	    XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

	    // DOM 3 XPath support ///////////////////////////////////////////////////////

	    function installDOM3XPathSupport(doc, p) {
	        doc.createExpression = function (e, r) {
	            try {
	                return new XPathExpression(e, r, p);
	            } catch (e) {
	                throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
	            }
	        };
	        doc.createNSResolver = function (n) {
	            return new NodeXPathNSResolver(n);
	        };
	        doc.evaluate = function (e, cn, r, t, res) {
	            if (t < 0 || t > 9) {
	                throw { code: 0, toString: function () { return "Request type not supported"; } };
	            }
	            return doc.createExpression(e, r, p).evaluate(cn, t, res);
	        };
	    };

	    // ---------------------------------------------------------------------------

	    // Install DOM 3 XPath support for the current document.
	    try {
	        var shouldInstall = true;
	        try {
	            if (document.implementation
	                && document.implementation.hasFeature
	                && document.implementation.hasFeature("XPath", null)) {
	                shouldInstall = false;
	            }
	        } catch (e) {
	        }
	        if (shouldInstall) {
	            installDOM3XPathSupport(document, new XPathParser());
	        }
	    } catch (e) {
	    }

	    // ---------------------------------------------------------------------------
	    // exports for node.js

	    installDOM3XPathSupport(exports, new XPathParser());

	    (function () {
	        var parser = new XPathParser();

	        var defaultNSResolver = new NamespaceResolver();
	        var defaultFunctionResolver = new FunctionResolver();
	        var defaultVariableResolver = new VariableResolver();

	        function makeNSResolverFromFunction(func) {
	            return {
	                getNamespace: function (prefix, node) {
	                    var ns = func(prefix, node);

	                    return ns || defaultNSResolver.getNamespace(prefix, node);
	                }
	            };
	        }

	        function makeNSResolverFromObject(obj) {
	            return makeNSResolverFromFunction(obj.getNamespace.bind(obj));
	        }

	        function makeNSResolverFromMap(map) {
	            return makeNSResolverFromFunction(function (prefix) {
	                return map[prefix];
	            });
	        }

	        function makeNSResolver(resolver) {
	            if (resolver && typeof resolver.getNamespace === "function") {
	                return makeNSResolverFromObject(resolver);
	            }

	            if (typeof resolver === "function") {
	                return makeNSResolverFromFunction(resolver);
	            }

	            // assume prefix -> uri mapping
	            if (typeof resolver === "object") {
	                return makeNSResolverFromMap(resolver);
	            }

	            return defaultNSResolver;
	        }

	        /** Converts native JavaScript types to their XPath library equivalent */
	        function convertValue(value) {
	            if (value === null ||
	                typeof value === "undefined" ||
	                value instanceof XString ||
	                value instanceof XBoolean ||
	                value instanceof XNumber ||
	                value instanceof XNodeSet) {
	                return value;
	            }

	            switch (typeof value) {
	                case "string": return new XString(value);
	                case "boolean": return new XBoolean(value);
	                case "number": return new XNumber(value);
	            }

	            // assume node(s)
	            var ns = new XNodeSet();
	            ns.addArray([].concat(value));
	            return ns;
	        }

	        function makeEvaluator(func) {
	            return function (context) {
	                var args = Array.prototype.slice.call(arguments, 1).map(function (arg) {
	                    return arg.evaluate(context);
	                });
	                var result = func.apply(this, [].concat(context, args));
	                return convertValue(result);
	            };
	        }

	        function makeFunctionResolverFromFunction(func) {
	            return {
	                getFunction: function (name, namespace) {
	                    var found = func(name, namespace);
	                    if (found) {
	                        return makeEvaluator(found);
	                    }
	                    return defaultFunctionResolver.getFunction(name, namespace);
	                }
	            };
	        }

	        function makeFunctionResolverFromObject(obj) {
	            return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));
	        }

	        function makeFunctionResolverFromMap(map) {
	            return makeFunctionResolverFromFunction(function (name) {
	                return map[name];
	            });
	        }

	        function makeFunctionResolver(resolver) {
	            if (resolver && typeof resolver.getFunction === "function") {
	                return makeFunctionResolverFromObject(resolver);
	            }

	            if (typeof resolver === "function") {
	                return makeFunctionResolverFromFunction(resolver);
	            }

	            // assume map
	            if (typeof resolver === "object") {
	                return makeFunctionResolverFromMap(resolver);
	            }

	            return defaultFunctionResolver;
	        }

	        function makeVariableResolverFromFunction(func) {
	            return {
	                getVariable: function (name, namespace) {
	                    var value = func(name, namespace);
	                    return convertValue(value);
	                }
	            };
	        }

	        function makeVariableResolver(resolver) {
	            if (resolver) {
	                if (typeof resolver.getVariable === "function") {
	                    return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));
	                }

	                if (typeof resolver === "function") {
	                    return makeVariableResolverFromFunction(resolver);
	                }

	                // assume map
	                if (typeof resolver === "object") {
	                    return makeVariableResolverFromFunction(function (name) {
	                        return resolver[name];
	                    });
	                }
	            }

	            return defaultVariableResolver;
	        }

	        function copyIfPresent(prop, dest, source) {
	            if (prop in source) { dest[prop] = source[prop]; }
	        }

	        function makeContext(options) {
	            var context = new XPathContext();

	            if (options) {
	                context.namespaceResolver = makeNSResolver(options.namespaces);
	                context.functionResolver = makeFunctionResolver(options.functions);
	                context.variableResolver = makeVariableResolver(options.variables);
	                context.expressionContextNode = options.node;
	                copyIfPresent('allowAnyNamespaceForNoPrefix', context, options);
	                copyIfPresent('isHtml', context, options);
	            } else {
	                context.namespaceResolver = defaultNSResolver;
	            }

	            return context;
	        }

	        function evaluate(parsedExpression, options) {
	            var context = makeContext(options);

	            return parsedExpression.evaluate(context);
	        }

	        var evaluatorPrototype = {
	            evaluate: function (options) {
	                return evaluate(this.expression, options);
	            }

	            , evaluateNumber: function (options) {
	                return this.evaluate(options).numberValue();
	            }

	            , evaluateString: function (options) {
	                return this.evaluate(options).stringValue();
	            }

	            , evaluateBoolean: function (options) {
	                return this.evaluate(options).booleanValue();
	            }

	            , evaluateNodeSet: function (options) {
	                return this.evaluate(options).nodeset();
	            }

	            , select: function (options) {
	                return this.evaluateNodeSet(options).toArray()
	            }

	            , select1: function (options) {
	                return this.select(options)[0];
	            }
	        };

	        function parse(xpath) {
	            var parsed = parser.parse(xpath);

	            return Object.create(evaluatorPrototype, {
	                expression: {
	                    value: parsed
	                }
	            });
	        }

	        exports.parse = parse;
	    })();

	    assign(
	        exports,
	        {
	            XPath: XPath,
	            XPathParser: XPathParser,
	            XPathResult: XPathResult,

	            Step: Step,
	            PathExpr: PathExpr,
	            NodeTest: NodeTest,
	            LocationPath: LocationPath,

	            OrOperation: OrOperation,
	            AndOperation: AndOperation,

	            BarOperation: BarOperation,

	            EqualsOperation: EqualsOperation,
	            NotEqualOperation: NotEqualOperation,
	            LessThanOperation: LessThanOperation,
	            GreaterThanOperation: GreaterThanOperation,
	            LessThanOrEqualOperation: LessThanOrEqualOperation,
	            GreaterThanOrEqualOperation: GreaterThanOrEqualOperation,

	            PlusOperation: PlusOperation,
	            MinusOperation: MinusOperation,
	            MultiplyOperation: MultiplyOperation,
	            DivOperation: DivOperation,
	            ModOperation: ModOperation,
	            UnaryMinusOperation: UnaryMinusOperation,

	            FunctionCall: FunctionCall,
	            VariableReference: VariableReference,

	            XPathContext: XPathContext,

	            XNodeSet: XNodeSet,
	            XBoolean: XBoolean,
	            XString: XString,
	            XNumber: XNumber,

	            NamespaceResolver: NamespaceResolver,
	            FunctionResolver: FunctionResolver,
	            VariableResolver: VariableResolver,

	            Utilities: Utilities,
	        }
	    );

	    // helper
	    exports.select = function (e, doc, single) {
	        return exports.selectWithResolver(e, doc, null, single);
	    };

	    exports.useNamespaces = function (mappings) {
	        var resolver = {
	            mappings: mappings || {},
	            lookupNamespaceURI: function (prefix) {
	                return this.mappings[prefix];
	            }
	        };

	        return function (e, doc, single) {
	            return exports.selectWithResolver(e, doc, resolver, single);
	        };
	    };

	    exports.selectWithResolver = function (e, doc, resolver, single) {
	        var expression = new XPathExpression(e, resolver, new XPathParser());
	        var type = XPathResult.ANY_TYPE;

	        var result = expression.evaluate(doc, type, null);

	        if (result.resultType == XPathResult.STRING_TYPE) {
	            result = result.stringValue;
	        }
	        else if (result.resultType == XPathResult.NUMBER_TYPE) {
	            result = result.numberValue;
	        }
	        else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
	            result = result.booleanValue;
	        }
	        else {
	            result = result.nodes;
	            if (single) {
	                result = result[0];
	            }
	        }

	        return result;
	    };

	    exports.select1 = function (e, doc) {
	        return exports.select(e, doc, true);
	    };

	    var isArrayOfNodes = function (value) {
	        return Array.isArray(value) && value.every(isNodeLike);
	    };

	    var isNodeOfType = function (type) {
	        return function (value) {
	            return isNodeLike(value) && value.nodeType === type;
	        };
	    };

	    assign(
	        exports,
	        {
	            isNodeLike: isNodeLike,
	            isArrayOfNodes: isArrayOfNodes,
	            isElement: isNodeOfType(NodeTypes.ELEMENT_NODE),
	            isAttribute: isNodeOfType(NodeTypes.ATTRIBUTE_NODE),
	            isTextNode: isNodeOfType(NodeTypes.TEXT_NODE),
	            isCDATASection: isNodeOfType(NodeTypes.CDATA_SECTION_NODE),
	            isProcessingInstruction: isNodeOfType(NodeTypes.PROCESSING_INSTRUCTION_NODE),
	            isComment: isNodeOfType(NodeTypes.COMMENT_NODE),
	            isDocumentNode: isNodeOfType(NodeTypes.DOCUMENT_NODE),
	            isDocumentTypeNode: isNodeOfType(NodeTypes.DOCUMENT_TYPE_NODE),
	            isDocumentFragment: isNodeOfType(NodeTypes.DOCUMENT_FRAGMENT_NODE),
	        }
	    );
	    // end non-node wrapper
	})(xpath); 
} (xpath$1));

var xpath = /*@__PURE__*/getDefaultExportFromCjs(xpath$1);

var lib = {};

var conventions$5 = {};

'use strict';

/**
 * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
 *
 * Works with anything that has a `length` property and index access properties,
 * including NodeList.
 *
 * @param {T[] | { length: number; [number]: T }} list
 * @param {function (item: T, index: number, list:T[]):boolean} predicate
 * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac
 * Allows injecting a custom implementation in tests (`Array.prototype` by default).
 * @returns {T | undefined}
 * @template {unknown} T
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
 */
function find$1(list, predicate, ac) {
	if (ac === undefined) {
		ac = Array.prototype;
	}
	if (list && typeof ac.find === 'function') {
		return ac.find.call(list, predicate);
	}
	for (var i = 0; i < list.length; i++) {
		if (hasOwn$2(list, i)) {
			var item = list[i];
			if (predicate.call(undefined, item, i, list)) {
				return item;
			}
		}
	}
}

/**
 * "Shallow freezes" an object to render it immutable.
 * Uses `Object.freeze` if available,
 * otherwise the immutability is only in the type.
 *
 * Is used to create "enum like" objects.
 *
 * If `Object.getOwnPropertyDescriptors` is available,
 * a new object with all properties of object but without any prototype is created and returned
 * after freezing it.
 *
 * @param {T} object
 * The object to freeze.
 * @param {Pick<ObjectConstructor, 'create' | 'freeze' | 'getOwnPropertyDescriptors'>} [oc=Object]
 * `Object` by default,
 * allows to inject custom object constructor for tests.
 * @returns {Readonly<T>}
 * @template {Object} T
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
 * @prettierignore
 */
function freeze(object, oc) {
	if (oc === undefined) {
		oc = Object;
	}
	if (oc && typeof oc.getOwnPropertyDescriptors === 'function') {
		object = oc.create(null, oc.getOwnPropertyDescriptors(object));
	}
	return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object;
}

/**
 * Implementation for `Object.hasOwn` but ES5 compatible.
 *
 * @param {any} object
 * @param {string | number} key
 * @returns {boolean}
 */
function hasOwn$2(object, key) {
	return Object.prototype.hasOwnProperty.call(object, key);
}

/**
 * Since xmldom can not rely on `Object.assign`,
 * it uses/provides a simplified version that is sufficient for its needs.
 *
 * @param {Object} target
 * @param {Object | null | undefined} source
 * @returns {Object}
 * The target with the merged/overridden properties.
 * @throws {TypeError}
 * If target is not an object.
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
 */
function assign$1(target, source) {
	if (target === null || typeof target !== 'object') {
		throw new TypeError('target is not an object');
	}
	for (var key in source) {
		if (hasOwn$2(source, key)) {
			target[key] = source[key];
		}
	}
	return target;
}

/**
 * A number of attributes are boolean attributes.
 * The presence of a boolean attribute on an element represents the `true` value,
 * and the absence of the attribute represents the `false` value.
 *
 * If the attribute is present, its value must either be the empty string, or a value that is
 * an ASCII case-insensitive match for the attribute's canonical name,
 * with no leading or trailing whitespace.
 *
 * Note: The values `"true"` and `"false"` are not allowed on boolean attributes.
 * To represent a `false` value, the attribute has to be omitted altogether.
 *
 * @see https://html.spec.whatwg.org/#boolean-attributes
 * @see https://html.spec.whatwg.org/#attributes-3
 */
var HTML_BOOLEAN_ATTRIBUTES = freeze({
	allowfullscreen: true,
	async: true,
	autofocus: true,
	autoplay: true,
	checked: true,
	controls: true,
	default: true,
	defer: true,
	disabled: true,
	formnovalidate: true,
	hidden: true,
	ismap: true,
	itemscope: true,
	loop: true,
	multiple: true,
	muted: true,
	nomodule: true,
	novalidate: true,
	open: true,
	playsinline: true,
	readonly: true,
	required: true,
	reversed: true,
	selected: true,
});

/**
 * Check if `name` is matching one of the HTML boolean attribute names.
 * This method doesn't check if such attributes are allowed in the context of the current
 * document/parsing.
 *
 * @param {string} name
 * @returns {boolean}
 * @see {@link HTML_BOOLEAN_ATTRIBUTES}
 * @see https://html.spec.whatwg.org/#boolean-attributes
 * @see https://html.spec.whatwg.org/#attributes-3
 */
function isHTMLBooleanAttribute(name) {
	return hasOwn$2(HTML_BOOLEAN_ATTRIBUTES, name.toLowerCase());
}

/**
 * Void elements only have a start tag; end tags must not be specified for void elements.
 * These elements should be written as self-closing like this: `<area />`.
 * This should not be confused with optional tags that HTML allows to omit the end tag for
 * (like `li`, `tr` and others), which can have content after them,
 * so they can not be written as self-closing.
 * xmldom does not have any logic for optional end tags cases,
 * and will report them as a warning.
 * Content that would go into the unopened element,
 * will instead be added as a sibling text node.
 *
 * @type {Readonly<{
 * 	area: boolean;
 * 	col: boolean;
 * 	img: boolean;
 * 	wbr: boolean;
 * 	link: boolean;
 * 	hr: boolean;
 * 	source: boolean;
 * 	br: boolean;
 * 	input: boolean;
 * 	param: boolean;
 * 	meta: boolean;
 * 	embed: boolean;
 * 	track: boolean;
 * 	base: boolean;
 * }>}
 * @see https://html.spec.whatwg.org/#void-elements
 * @see https://html.spec.whatwg.org/#optional-tags
 */
var HTML_VOID_ELEMENTS = freeze({
	area: true,
	base: true,
	br: true,
	col: true,
	embed: true,
	hr: true,
	img: true,
	input: true,
	link: true,
	meta: true,
	param: true,
	source: true,
	track: true,
	wbr: true,
});

/**
 * Check if `tagName` is matching one of the HTML void element names.
 * This method doesn't check if such tags are allowed in the context of the current
 * document/parsing.
 *
 * @param {string} tagName
 * @returns {boolean}
 * @see {@link HTML_VOID_ELEMENTS}
 * @see https://html.spec.whatwg.org/#void-elements
 */
function isHTMLVoidElement$1(tagName) {
	return hasOwn$2(HTML_VOID_ELEMENTS, tagName.toLowerCase());
}

/**
 * Tag names that are raw text elements according to HTML spec.
 * The value denotes whether they are escapable or not.
 *
 * @see {@link isHTMLEscapableRawTextElement}
 * @see {@link isHTMLRawTextElement}
 * @see https://html.spec.whatwg.org/#raw-text-elements
 * @see https://html.spec.whatwg.org/#escapable-raw-text-elements
 */
var HTML_RAW_TEXT_ELEMENTS = freeze({
	script: false,
	style: false,
	textarea: true,
	title: true,
});

/**
 * Check if `tagName` is matching one of the HTML raw text element names.
 * This method doesn't check if such tags are allowed in the context of the current
 * document/parsing.
 *
 * @param {string} tagName
 * @returns {boolean}
 * @see {@link isHTMLEscapableRawTextElement}
 * @see {@link HTML_RAW_TEXT_ELEMENTS}
 * @see https://html.spec.whatwg.org/#raw-text-elements
 * @see https://html.spec.whatwg.org/#escapable-raw-text-elements
 */
function isHTMLRawTextElement$2(tagName) {
	var key = tagName.toLowerCase();
	return hasOwn$2(HTML_RAW_TEXT_ELEMENTS, key) && !HTML_RAW_TEXT_ELEMENTS[key];
}
/**
 * Check if `tagName` is matching one of the HTML escapable raw text element names.
 * This method doesn't check if such tags are allowed in the context of the current
 * document/parsing.
 *
 * @param {string} tagName
 * @returns {boolean}
 * @see {@link isHTMLRawTextElement}
 * @see {@link HTML_RAW_TEXT_ELEMENTS}
 * @see https://html.spec.whatwg.org/#raw-text-elements
 * @see https://html.spec.whatwg.org/#escapable-raw-text-elements
 */
function isHTMLEscapableRawTextElement$1(tagName) {
	var key = tagName.toLowerCase();
	return hasOwn$2(HTML_RAW_TEXT_ELEMENTS, key) && HTML_RAW_TEXT_ELEMENTS[key];
}
/**
 * Only returns true if `value` matches MIME_TYPE.HTML, which indicates an HTML document.
 *
 * @param {string} mimeType
 * @returns {mimeType is 'text/html'}
 * @see https://www.iana.org/assignments/media-types/text/html
 * @see https://en.wikipedia.org/wiki/HTML
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
 */
function isHTMLMimeType$4(mimeType) {
	return mimeType === MIME_TYPE$3.HTML;
}
/**
 * For both the `text/html` and the `application/xhtml+xml` namespace the spec defines that the
 * HTML namespace is provided as the default.
 *
 * @param {string} mimeType
 * @returns {boolean}
 * @see https://dom.spec.whatwg.org/#dom-document-createelement
 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument
 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
 */
function hasDefaultHTMLNamespace$3(mimeType) {
	return isHTMLMimeType$4(mimeType) || mimeType === MIME_TYPE$3.XML_XHTML_APPLICATION;
}

/**
 * All mime types that are allowed as input to `DOMParser.parseFromString`
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02
 *      MDN
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype
 *      WHATWG HTML Spec
 * @see {@link DOMParser.prototype.parseFromString}
 */
var MIME_TYPE$3 = freeze({
	/**
	 * `text/html`, the only mime type that triggers treating an XML document as HTML.
	 *
	 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
	 *      WHATWG HTML Spec
	 */
	HTML: 'text/html',

	/**
	 * `application/xml`, the standard mime type for XML documents.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType
	 *      registration
	 * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_APPLICATION: 'application/xml',

	/**
	 * `text/xml`, an alias for `application/xml`.
	 *
	 * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
	 * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_TEXT: 'text/xml',

	/**
	 * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
	 * but is parsed as an XML document.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType
	 *      registration
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
	 * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
	 */
	XML_XHTML_APPLICATION: 'application/xhtml+xml',

	/**
	 * `image/svg+xml`,
	 *
	 * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
	 * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
	 * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
	 */
	XML_SVG_IMAGE: 'image/svg+xml',
});
/**
 * @typedef {'application/xhtml+xml' | 'application/xml' | 'image/svg+xml' | 'text/html' | 'text/xml'}
 * MimeType
 */
/**
 * @type {MimeType[]}
 * @private
 * Basically `Object.values`, which is not available in ES5.
 */
var _MIME_TYPES = Object.keys(MIME_TYPE$3).map(function (key) {
	return MIME_TYPE$3[key];
});

/**
 * Only returns true if `mimeType` is one of the allowed values for
 * `DOMParser.parseFromString`.
 *
 * @param {string} mimeType
 * @returns {mimeType is 'application/xhtml+xml' | 'application/xml' | 'image/svg+xml' |  'text/html' | 'text/xml'}
 *
 */
function isValidMimeType$2(mimeType) {
	return _MIME_TYPES.indexOf(mimeType) > -1;
}
/**
 * Namespaces that are used in this code base.
 *
 * @see http://www.w3.org/TR/REC-xml-names
 */
var NAMESPACE$4 = freeze({
	/**
	 * The XHTML namespace.
	 *
	 * @see http://www.w3.org/1999/xhtml
	 */
	HTML: 'http://www.w3.org/1999/xhtml',

	/**
	 * The SVG namespace.
	 *
	 * @see http://www.w3.org/2000/svg
	 */
	SVG: 'http://www.w3.org/2000/svg',

	/**
	 * The `xml:` namespace.
	 *
	 * @see http://www.w3.org/XML/1998/namespace
	 */
	XML: 'http://www.w3.org/XML/1998/namespace',

	/**
	 * The `xmlns:` namespace.
	 *
	 * @see https://www.w3.org/2000/xmlns/
	 */
	XMLNS: 'http://www.w3.org/2000/xmlns/',
});

var assign_1 = conventions$5.assign = assign$1;
var find_1 = conventions$5.find = find$1;
var freeze_1 = conventions$5.freeze = freeze;
var HTML_BOOLEAN_ATTRIBUTES_1 = conventions$5.HTML_BOOLEAN_ATTRIBUTES = HTML_BOOLEAN_ATTRIBUTES;
var HTML_RAW_TEXT_ELEMENTS_1 = conventions$5.HTML_RAW_TEXT_ELEMENTS = HTML_RAW_TEXT_ELEMENTS;
var HTML_VOID_ELEMENTS_1 = conventions$5.HTML_VOID_ELEMENTS = HTML_VOID_ELEMENTS;
var hasDefaultHTMLNamespace_1 = conventions$5.hasDefaultHTMLNamespace = hasDefaultHTMLNamespace$3;
var hasOwn_1 = conventions$5.hasOwn = hasOwn$2;
var isHTMLBooleanAttribute_1 = conventions$5.isHTMLBooleanAttribute = isHTMLBooleanAttribute;
var isHTMLRawTextElement_1 = conventions$5.isHTMLRawTextElement = isHTMLRawTextElement$2;
var isHTMLEscapableRawTextElement_1 = conventions$5.isHTMLEscapableRawTextElement = isHTMLEscapableRawTextElement$1;
var isHTMLMimeType_1 = conventions$5.isHTMLMimeType = isHTMLMimeType$4;
var isHTMLVoidElement_1 = conventions$5.isHTMLVoidElement = isHTMLVoidElement$1;
var isValidMimeType_1 = conventions$5.isValidMimeType = isValidMimeType$2;
var MIME_TYPE_1 = conventions$5.MIME_TYPE = MIME_TYPE$3;
var NAMESPACE_1 = conventions$5.NAMESPACE = NAMESPACE$4;

var errors$4 = {};

'use strict';

var conventions$4 = conventions$5;

function extendError(constructor, writableName) {
	constructor.prototype = Object.create(Error.prototype, {
		constructor: { value: constructor },
		name: { value: constructor.name, enumerable: true, writable: writableName },
	});
}

var DOMExceptionName$2 = conventions$4.freeze({
	/**
	 * the default value as defined by the spec
	 */
	Error: 'Error',
	/**
	 * @deprecated
	 * Use RangeError instead.
	 */
	IndexSizeError: 'IndexSizeError',
	/**
	 * @deprecated
	 * Just to match the related static code, not part of the spec.
	 */
	DomstringSizeError: 'DomstringSizeError',
	HierarchyRequestError: 'HierarchyRequestError',
	WrongDocumentError: 'WrongDocumentError',
	InvalidCharacterError: 'InvalidCharacterError',
	/**
	 * @deprecated
	 * Just to match the related static code, not part of the spec.
	 */
	NoDataAllowedError: 'NoDataAllowedError',
	NoModificationAllowedError: 'NoModificationAllowedError',
	NotFoundError: 'NotFoundError',
	NotSupportedError: 'NotSupportedError',
	InUseAttributeError: 'InUseAttributeError',
	InvalidStateError: 'InvalidStateError',
	SyntaxError: 'SyntaxError',
	InvalidModificationError: 'InvalidModificationError',
	NamespaceError: 'NamespaceError',
	/**
	 * @deprecated
	 * Use TypeError for invalid arguments,
	 * "NotSupportedError" DOMException for unsupported operations,
	 * and "NotAllowedError" DOMException for denied requests instead.
	 */
	InvalidAccessError: 'InvalidAccessError',
	/**
	 * @deprecated
	 * Just to match the related static code, not part of the spec.
	 */
	ValidationError: 'ValidationError',
	/**
	 * @deprecated
	 * Use TypeError instead.
	 */
	TypeMismatchError: 'TypeMismatchError',
	SecurityError: 'SecurityError',
	NetworkError: 'NetworkError',
	AbortError: 'AbortError',
	/**
	 * @deprecated
	 * Just to match the related static code, not part of the spec.
	 */
	URLMismatchError: 'URLMismatchError',
	QuotaExceededError: 'QuotaExceededError',
	TimeoutError: 'TimeoutError',
	InvalidNodeTypeError: 'InvalidNodeTypeError',
	DataCloneError: 'DataCloneError',
	EncodingError: 'EncodingError',
	NotReadableError: 'NotReadableError',
	UnknownError: 'UnknownError',
	ConstraintError: 'ConstraintError',
	DataError: 'DataError',
	TransactionInactiveError: 'TransactionInactiveError',
	ReadOnlyError: 'ReadOnlyError',
	VersionError: 'VersionError',
	OperationError: 'OperationError',
	NotAllowedError: 'NotAllowedError',
	OptOutError: 'OptOutError',
});
var DOMExceptionNames = Object.keys(DOMExceptionName$2);

function isValidDomExceptionCode(value) {
	return typeof value === 'number' && value >= 1 && value <= 25;
}
function endsWithError(value) {
	return typeof value === 'string' && value.substring(value.length - DOMExceptionName$2.Error.length) === DOMExceptionName$2.Error;
}
/**
 * DOM operations only raise exceptions in "exceptional" circumstances, i.e., when an operation
 * is impossible to perform (either for logical reasons, because data is lost, or because the
 * implementation has become unstable). In general, DOM methods return specific error values in
 * ordinary processing situations, such as out-of-bound errors when using NodeList.
 *
 * Implementations should raise other exceptions under other circumstances. For example,
 * implementations should raise an implementation-dependent exception if a null argument is
 * passed when null was not expected.
 *
 * This implementation supports the following usages:
 * 1. according to the living standard (both arguments are optional):
 * ```
 * new DOMException("message (can be empty)", DOMExceptionNames.HierarchyRequestError)
 * ```
 * 2. according to previous xmldom implementation (only the first argument is required):
 * ```
 * new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "optional message")
 * ```
 * both result in the proper name being set.
 *
 * @class DOMException
 * @param {number | string} messageOrCode
 * The reason why an operation is not acceptable.
 * If it is a number, it is used to determine the `name`, see
 * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-258A00AF ExceptionCode}
 * @param {string | keyof typeof DOMExceptionName | Error} [nameOrMessage]
 * The `name` to use for the error.
 * If `messageOrCode` is a number, this arguments is used as the `message` instead.
 * @augments Error
 * @see https://webidl.spec.whatwg.org/#idl-DOMException
 * @see https://webidl.spec.whatwg.org/#dfn-error-names-table
 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-17189187
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 */
function DOMException$3(messageOrCode, nameOrMessage) {
	// support old way of passing arguments: first argument is a valid number
	if (isValidDomExceptionCode(messageOrCode)) {
		this.name = DOMExceptionNames[messageOrCode];
		this.message = nameOrMessage || '';
	} else {
		this.message = messageOrCode;
		this.name = endsWithError(nameOrMessage) ? nameOrMessage : DOMExceptionName$2.Error;
	}
	if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException$3);
}
extendError(DOMException$3, true);
Object.defineProperties(DOMException$3.prototype, {
	code: {
		enumerable: true,
		get: function () {
			var code = DOMExceptionNames.indexOf(this.name);
			if (isValidDomExceptionCode(code)) return code;
			return 0;
		},
	},
});

var ExceptionCode$1 = {
	INDEX_SIZE_ERR: 1,
	DOMSTRING_SIZE_ERR: 2,
	HIERARCHY_REQUEST_ERR: 3,
	WRONG_DOCUMENT_ERR: 4,
	INVALID_CHARACTER_ERR: 5,
	NO_DATA_ALLOWED_ERR: 6,
	NO_MODIFICATION_ALLOWED_ERR: 7,
	NOT_FOUND_ERR: 8,
	NOT_SUPPORTED_ERR: 9,
	INUSE_ATTRIBUTE_ERR: 10,
	INVALID_STATE_ERR: 11,
	SYNTAX_ERR: 12,
	INVALID_MODIFICATION_ERR: 13,
	NAMESPACE_ERR: 14,
	INVALID_ACCESS_ERR: 15,
	VALIDATION_ERR: 16,
	TYPE_MISMATCH_ERR: 17,
	SECURITY_ERR: 18,
	NETWORK_ERR: 19,
	ABORT_ERR: 20,
	URL_MISMATCH_ERR: 21,
	QUOTA_EXCEEDED_ERR: 22,
	TIMEOUT_ERR: 23,
	INVALID_NODE_TYPE_ERR: 24,
	DATA_CLONE_ERR: 25,
};

var entries = Object.entries(ExceptionCode$1);
for (var i = 0; i < entries.length; i++) {
	var key = entries[i][0];
	DOMException$3[key] = entries[i][1];
}

/**
 * Creates an error that will not be caught by XMLReader aka the SAX parser.
 *
 * @class
 * @param {string} message
 * @param {any} [locator]
 */
function ParseError$3(message, locator) {
	this.message = message;
	this.locator = locator;
	if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError$3);
}
extendError(ParseError$3);

var DOMException_1 = errors$4.DOMException = DOMException$3;
var DOMExceptionName_1 = errors$4.DOMExceptionName = DOMExceptionName$2;
var ExceptionCode_1 = errors$4.ExceptionCode = ExceptionCode$1;
var ParseError_1 = errors$4.ParseError = ParseError$3;

var dom$2 = {};

var grammar = {};

'use strict';

/**
 * Detects relevant unicode support for regular expressions in the runtime.
 * Should the runtime not accepts the flag `u` or unicode ranges,
 * character classes without unicode handling will be used.
 *
 * @param {typeof RegExp} [RegExpImpl=RegExp]
 * For testing: the RegExp class.
 * @returns {boolean}
 * @see https://node.green/#ES2015-syntax-RegExp--y--and--u--flags
 */
function detectUnicodeSupport(RegExpImpl) {
	try {
		if (typeof RegExpImpl !== 'function') {
			RegExpImpl = RegExp;
		}
		// eslint-disable-next-line es5/no-unicode-regex,es5/no-unicode-code-point-escape
		var match = new RegExpImpl('\u{1d306}', 'u').exec('𝌆');
		return !!match && match[0].length === 2;
	} catch (error) {}
	return false;
}
var UNICODE_SUPPORT = detectUnicodeSupport();

/**
 * Removes `[`, `]` and any trailing quantifiers from the source of a RegExp.
 *
 * @param {RegExp} regexp
 */
function chars(regexp) {
	if (regexp.source[0] !== '[') {
		throw new Error(regexp + ' can not be used with chars');
	}
	return regexp.source.slice(1, regexp.source.lastIndexOf(']'));
}

/**
 * Creates a new character list regular expression,
 * by removing `search` from the source of `regexp`.
 *
 * @param {RegExp} regexp
 * @param {string} search
 * The character(s) to remove.
 * @returns {RegExp}
 */
function chars_without(regexp, search) {
	if (regexp.source[0] !== '[') {
		throw new Error('/' + regexp.source + '/ can not be used with chars_without');
	}
	if (!search || typeof search !== 'string') {
		throw new Error(JSON.stringify(search) + ' is not a valid search');
	}
	if (regexp.source.indexOf(search) === -1) {
		throw new Error('"' + search + '" is not is /' + regexp.source + '/');
	}
	if (search === '-' && regexp.source.indexOf(search) !== 1) {
		throw new Error('"' + search + '" is not at the first postion of /' + regexp.source + '/');
	}
	return new RegExp(regexp.source.replace(search, ''), UNICODE_SUPPORT ? 'u' : '');
}

/**
 * Combines and Regular expressions correctly by using `RegExp.source`.
 *
 * @param {...(RegExp | string)[]} args
 * @returns {RegExp}
 */
function reg(args) {
	var self = this;
	return new RegExp(
		Array.prototype.slice
			.call(arguments)
			.map(function (part) {
				var isStr = typeof part === 'string';
				if (isStr && self === undefined && part === '|') {
					throw new Error('use regg instead of reg to wrap expressions with `|`!');
				}
				return isStr ? part : part.source;
			})
			.join(''),
		UNICODE_SUPPORT ? 'mu' : 'm'
	);
}

/**
 * Like `reg` but wraps the expression in `(?:`,`)` to create a non tracking group.
 *
 * @param {...(RegExp | string)[]} args
 * @returns {RegExp}
 */
function regg(args) {
	if (arguments.length === 0) {
		throw new Error('no parameters provided');
	}
	return reg.apply(regg, ['(?:'].concat(Array.prototype.slice.call(arguments), [')']));
}

// /**
//  * Append ^ to the beginning of the expression.
//  * @param {...(RegExp | string)[]} args
//  * @returns {RegExp}
//  */
// function reg_start(args) {
// 	if (arguments.length === 0) {
// 		throw new Error('no parameters provided');
// 	}
// 	return reg.apply(reg_start, ['^'].concat(Array.prototype.slice.call(arguments)));
// }

// https://www.w3.org/TR/xml/#document
// `[1] document ::= prolog element Misc*`
// https://www.w3.org/TR/xml11/#NT-document
// `[1] document ::= ( prolog element Misc* ) - ( Char* RestrictedChar Char* )`

/**
 * A character usually appearing in wrongly converted strings.
 *
 * @type {string}
 * @see https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character
 * @see https://nodejs.dev/en/api/v18/buffer/#buffers-and-character-encodings
 * @see https://www.unicode.org/faq/utf_bom.html#BOM
 * @readonly
 */
var UNICODE_REPLACEMENT_CHARACTER = '\uFFFD';
// https://www.w3.org/TR/xml/#NT-Char
// any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
// `[2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]`
// https://www.w3.org/TR/xml11/#NT-Char
// `[2] Char ::= [#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]`
// https://www.w3.org/TR/xml11/#NT-RestrictedChar
// `[2a] RestrictedChar ::= [#x1-#x8] | [#xB-#xC] | [#xE-#x1F] | [#x7F-#x84] | [#x86-#x9F]`
// https://www.w3.org/TR/xml11/#charsets
var Char = /[-\x09\x0A\x0D\x20-\x2C\x2E-\uD7FF\uE000-\uFFFD]/; // without \u10000-\uEFFFF
if (UNICODE_SUPPORT) {
	// eslint-disable-next-line es5/no-unicode-code-point-escape
	Char = reg('[', chars(Char), '\\u{10000}-\\u{10FFFF}', ']');
}

var _SChar = /[\x20\x09\x0D\x0A]/;
var SChar_s = chars(_SChar);
// https://www.w3.org/TR/xml11/#NT-S
// `[3] S ::= (#x20 | #x9 | #xD | #xA)+`
var S = reg(_SChar, '+');
// optional whitespace described as `S?` in the grammar,
// simplified to 0-n occurrences of the character class
// instead of 0-1 occurrences of a non-capturing group around S
var S_OPT = reg(_SChar, '*');

// https://www.w3.org/TR/xml11/#NT-NameStartChar
// `[4] NameStartChar ::= ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]`
var NameStartChar =
	/[:_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/; // without \u10000-\uEFFFF
if (UNICODE_SUPPORT) {
	// eslint-disable-next-line es5/no-unicode-code-point-escape
	NameStartChar = reg('[', chars(NameStartChar), '\\u{10000}-\\u{10FFFF}', ']');
}
var NameStartChar_s = chars(NameStartChar);

// https://www.w3.org/TR/xml11/#NT-NameChar
// `[4a] NameChar ::= NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]`
var NameChar = reg('[', NameStartChar_s, chars(/[-.0-9\xB7]/), chars(/[\u0300-\u036F\u203F-\u2040]/), ']');
// https://www.w3.org/TR/xml11/#NT-Name
// `[5] Name ::= NameStartChar (NameChar)*`
var Name = reg(NameStartChar, NameChar, '*');
/*
https://www.w3.org/TR/xml11/#NT-Names
`[6] Names ::= Name (#x20 Name)*`
*/

// https://www.w3.org/TR/xml11/#NT-Nmtoken
// `[7] Nmtoken ::= (NameChar)+`
var Nmtoken = reg(NameChar, '+');
/*
https://www.w3.org/TR/xml11/#NT-Nmtokens
`[8] Nmtokens ::= Nmtoken (#x20 Nmtoken)*`
var Nmtokens = reg(Nmtoken, regg(/\x20/, Nmtoken), '*');
*/

// https://www.w3.org/TR/xml11/#NT-EntityRef
// `[68] EntityRef ::= '&' Name ';'` [WFC: Entity Declared] [VC: Entity Declared] [WFC: Parsed Entity] [WFC: No Recursion]
var EntityRef = reg('&', Name, ';');
// https://www.w3.org/TR/xml11/#NT-CharRef
// `[66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'` [WFC: Legal Character]
var CharRef = regg(/&#[0-9]+;|&#x[0-9a-fA-F]+;/);

/*
https://www.w3.org/TR/xml11/#NT-Reference
- `[67] Reference ::= EntityRef | CharRef`
- `[66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'` [WFC: Legal Character]
- `[68] EntityRef ::= '&' Name ';'` [WFC: Entity Declared] [VC: Entity Declared] [WFC: Parsed Entity] [WFC: No Recursion]
*/
var Reference = regg(EntityRef, '|', CharRef);

// https://www.w3.org/TR/xml11/#NT-PEReference
// `[69] PEReference ::= '%' Name ';'`
// [VC: Entity Declared] [WFC: No Recursion] [WFC: In DTD]
var PEReference = reg('%', Name, ';');

// https://www.w3.org/TR/xml11/#NT-EntityValue
// `[9] EntityValue ::= '"' ([^%&"] | PEReference | Reference)* '"' | "'" ([^%&'] | PEReference | Reference)* "'"`
var EntityValue = regg(
	reg('"', regg(/[^%&"]/, '|', PEReference, '|', Reference), '*', '"'),
	'|',
	reg("'", regg(/[^%&']/, '|', PEReference, '|', Reference), '*', "'")
);

// https://www.w3.org/TR/xml11/#NT-AttValue
// `[10] AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'"`
var AttValue = regg('"', regg(/[^<&"]/, '|', Reference), '*', '"', '|', "'", regg(/[^<&']/, '|', Reference), '*', "'");

// https://www.w3.org/TR/xml-names/#ns-decl
// https://www.w3.org/TR/xml-names/#ns-qualnames
// NameStartChar without ":"
var NCNameStartChar = chars_without(NameStartChar, ':');
// https://www.w3.org/TR/xml-names/#orphans
// `[5] NCNameChar ::= NameChar - ':'`
// An XML NameChar, minus the ":"
var NCNameChar = chars_without(NameChar, ':');
// https://www.w3.org/TR/xml-names/#NT-NCName
// `[4] NCName ::= Name - (Char* ':' Char*)`
// An XML Name, minus the ":"
var NCName = reg(NCNameStartChar, NCNameChar, '*');

/**
https://www.w3.org/TR/xml-names/#ns-qualnames

```
[7] QName ::= PrefixedName | UnprefixedName
				  === (NCName ':' NCName) | NCName
				  === NCName (':' NCName)?
[8] PrefixedName ::= Prefix ':' LocalPart
								 === NCName ':' NCName
[9] UnprefixedName ::= LocalPart
									 === NCName
[10] Prefix ::= NCName
[11] LocalPart ::= NCName
```
*/
var QName = reg(NCName, regg(':', NCName), '?');
var QName_exact = reg('^', QName, '$');
var QName_group = reg('(', QName, ')');

// https://www.w3.org/TR/xml11/#NT-SystemLiteral
// `[11] SystemLiteral ::= ('"' [^"]* '"') | ("'" [^']* "'")`
var SystemLiteral = regg(/"[^"]*"|'[^']*'/);

/*
 https://www.w3.org/TR/xml11/#NT-PI
 ```
 [17] PITarget    ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
 [16] PI    ::= '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
 ```
 target /xml/i is not excluded!
*/
var PI = reg(/^<\?/, '(', Name, ')', regg(S, '(', Char, '*?)'), '?', /\?>/);

// https://www.w3.org/TR/xml11/#NT-PubidChar
// `[13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]`
var PubidChar = /[\x20\x0D\x0Aa-zA-Z0-9-'()+,./:=?;!*#@$_%]/;

// https://www.w3.org/TR/xml11/#NT-PubidLiteral
// `[12] PubidLiteral ::= '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"`
var PubidLiteral = regg('"', PubidChar, '*"', '|', "'", chars_without(PubidChar, "'"), "*'");

// https://www.w3.org/TR/xml11/#NT-CharData
// `[14] CharData    ::= [^<&]* - ([^<&]* ']]>' [^<&]*)`

var COMMENT_START = '<!--';
var COMMENT_END = '-->';
// https://www.w3.org/TR/xml11/#NT-Comment
// `[15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'`
var Comment$2 = reg(COMMENT_START, regg(chars_without(Char, '-'), '|', reg('-', chars_without(Char, '-'))), '*', COMMENT_END);

var PCDATA = '#PCDATA';
// https://www.w3.org/TR/xml11/#NT-Mixed
// `[51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')'`
// https://www.w3.org/TR/xml-names/#NT-Mixed
// `[51] Mixed ::= '(' S? '#PCDATA' (S? '|' S? QName)* S? ')*' | '(' S? '#PCDATA' S? ')'`
// [VC: Proper Group/PE Nesting] [VC: No Duplicate Types]
var Mixed = regg(
	reg(/\(/, S_OPT, PCDATA, regg(S_OPT, /\|/, S_OPT, QName), '*', S_OPT, /\)\*/),
	'|',
	reg(/\(/, S_OPT, PCDATA, S_OPT, /\)/)
);

var _children_quantity = /[?*+]?/;
/*
 `[49] choice ::= '(' S? cp ( S? '|' S? cp )+ S? ')'` [VC: Proper Group/PE Nesting]
 `[50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'` [VC: Proper Group/PE Nesting]
 simplification to solve circular referencing, but doesn't check validity constraint "Proper Group/PE Nesting"
 var _choice_or_seq = reg('[', NameChar_s, SChar_s, chars(_children_quantity), '()|,]*');
 ```
 [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?
         === (Name | '(' S? cp ( S? '|' S? cp )+ S? ')' | '(' S? cp ( S? ',' S? cp )* S? ')') ('?' | '*' | '+')?
         !== (Name | [_choice_or_seq]*) ('?' | '*' | '+')?
 ```
 simplification to solve circular referencing, but doesn't check validity constraint "Proper Group/PE Nesting"
 var cp = reg(regg(Name, '|', _choice_or_seq), _children_quantity);
*/
/*
Inefficient regular expression (High)
This part of the regular expression may cause exponential backtracking on strings starting with '(|' and containing many repetitions of '|'.
https://github.com/xmldom/xmldom/security/code-scanning/91
var choice = regg(/\(/, S_OPT, cp, regg(S_OPT, /\|/, S_OPT, cp), '+', S_OPT, /\)/);
*/
/*
Inefficient regular expression (High)
This part of the regular expression may cause exponential backtracking on strings starting with '(,' and containing many repetitions of ','.
https://github.com/xmldom/xmldom/security/code-scanning/92
var seq = regg(/\(/, S_OPT, cp, regg(S_OPT, /,/, S_OPT, cp), '*', S_OPT, /\)/);
*/

// `[47] children ::= (choice | seq) ('?' | '*' | '+')?`
// simplification to solve circular referencing, but doesn't check validity constraint "Proper Group/PE Nesting"
var children = reg(/\([^>]+\)/, _children_quantity /*regg(choice, '|', seq), _children_quantity*/);

// https://www.w3.org/TR/xml11/#NT-contentspec
// `[46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | children`
var contentspec = regg('EMPTY', '|', 'ANY', '|', Mixed, '|', children);

var ELEMENTDECL_START = '<!ELEMENT';
// https://www.w3.org/TR/xml11/#NT-elementdecl
// `[45] elementdecl ::= '<!ELEMENT' S Name S contentspec S? '>'`
// https://www.w3.org/TR/xml-names/#NT-elementdecl
// `[17] elementdecl ::= '<!ELEMENT' S QName S contentspec S? '>'`
// because of https://www.w3.org/TR/xml11/#NT-PEReference
// since xmldom is not supporting replacements of PEReferences in the DTD
// this also supports PEReference in the possible places
var elementdecl = reg(ELEMENTDECL_START, S, regg(QName, '|', PEReference), S, regg(contentspec, '|', PEReference), S_OPT, '>');

// https://www.w3.org/TR/xml11/#NT-NotationType
// `[58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'`
// [VC: Notation Attributes] [VC: One Notation Per Element Type] [VC: No Notation on Empty Element] [VC: No Duplicate Tokens]
var NotationType = reg('NOTATION', S, /\(/, S_OPT, Name, regg(S_OPT, /\|/, S_OPT, Name), '*', S_OPT, /\)/);
// https://www.w3.org/TR/xml11/#NT-Enumeration
// `[59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'`
// [VC: Enumeration] [VC: No Duplicate Tokens]
var Enumeration = reg(/\(/, S_OPT, Nmtoken, regg(S_OPT, /\|/, S_OPT, Nmtoken), '*', S_OPT, /\)/);

// https://www.w3.org/TR/xml11/#NT-EnumeratedType
// `[57] EnumeratedType ::= NotationType | Enumeration`
var EnumeratedType = regg(NotationType, '|', Enumeration);

/*
```
[55] StringType ::= 'CDATA'
[56] TokenizedType ::= 'ID' [VC: ID] [VC: One ID per Element Type] [VC: ID Attribute Default]
   | 'IDREF' [VC: IDREF]
   | 'IDREFS' [VC: IDREF]
	 | 'ENTITY' [VC: Entity Name]
	 | 'ENTITIES' [VC: Entity Name]
	 | 'NMTOKEN' [VC: Name Token]
	 | 'NMTOKENS' [VC: Name Token]
 [54] AttType ::= StringType | TokenizedType | EnumeratedType
```*/
var AttType = regg(/CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS/, '|', EnumeratedType);

// `[60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue)`
// [WFC: No < in Attribute Values] [WFC: No External Entity References]
// [VC: Fixed Attribute Default] [VC: Required Attribute] [VC: Attribute Default Value Syntactically Correct]
var DefaultDecl = regg(/#REQUIRED|#IMPLIED/, '|', regg(regg('#FIXED', S), '?', AttValue));

// https://www.w3.org/TR/xml11/#NT-AttDef
// [53] AttDef ::= S Name S AttType S DefaultDecl
// https://www.w3.org/TR/xml-names/#NT-AttDef
// [1] NSAttName ::= PrefixedAttName | DefaultAttName
// [2] PrefixedAttName ::= 'xmlns:' NCName [NSC: Reserved Prefixes and Namespace Names]
// [3] DefaultAttName ::= 'xmlns'
// [21] AttDef ::= S (QName | NSAttName) S AttType S DefaultDecl
// 						 === S Name S AttType S DefaultDecl
// xmldom is not distinguishing between QName and NSAttName on this level
// to support XML without namespaces in DTD we can not restrict it to QName
var AttDef = regg(S, Name, S, AttType, S, DefaultDecl);

var ATTLIST_DECL_START = '<!ATTLIST';
// https://www.w3.org/TR/xml11/#NT-AttlistDecl
// `[52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'`
// https://www.w3.org/TR/xml-names/#NT-AttlistDecl
// `[20] AttlistDecl ::= '<!ATTLIST' S QName AttDef* S? '>'`
// to support XML without namespaces in DTD we can not restrict it to QName
var AttlistDecl = reg(ATTLIST_DECL_START, S, Name, AttDef, '*', S_OPT, '>');

// https://html.spec.whatwg.org/multipage/urls-and-fetching.html#about:legacy-compat
var ABOUT_LEGACY_COMPAT = 'about:legacy-compat';
var ABOUT_LEGACY_COMPAT_SystemLiteral = regg('"' + ABOUT_LEGACY_COMPAT + '"', '|', "'" + ABOUT_LEGACY_COMPAT + "'");
var SYSTEM = 'SYSTEM';
var PUBLIC = 'PUBLIC';
// https://www.w3.org/TR/xml11/#NT-ExternalID
// `[75] ExternalID ::= 'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral`
var ExternalID = regg(regg(SYSTEM, S, SystemLiteral), '|', regg(PUBLIC, S, PubidLiteral, S, SystemLiteral));
var ExternalID_match = reg(
	'^',
	regg(
		regg(SYSTEM, S, '(?<SystemLiteralOnly>', SystemLiteral, ')'),
		'|',
		regg(PUBLIC, S, '(?<PubidLiteral>', PubidLiteral, ')', S, '(?<SystemLiteral>', SystemLiteral, ')')
	)
);

// https://www.w3.org/TR/xml11/#NT-NDataDecl
// `[76] NDataDecl ::= S 'NDATA' S Name` [VC: Notation Declared]
var NDataDecl = regg(S, 'NDATA', S, Name);

// https://www.w3.org/TR/xml11/#NT-EntityDef
// `[73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)`
var EntityDef = regg(EntityValue, '|', regg(ExternalID, NDataDecl, '?'));

var ENTITY_DECL_START = '<!ENTITY';
// https://www.w3.org/TR/xml11/#NT-GEDecl
// `[71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'`
var GEDecl = reg(ENTITY_DECL_START, S, Name, S, EntityDef, S_OPT, '>');
// https://www.w3.org/TR/xml11/#NT-PEDef
// `[74] PEDef ::= EntityValue | ExternalID`
var PEDef = regg(EntityValue, '|', ExternalID);
// https://www.w3.org/TR/xml11/#NT-PEDecl
// `[72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'`
var PEDecl = reg(ENTITY_DECL_START, S, '%', S, Name, S, PEDef, S_OPT, '>');
// https://www.w3.org/TR/xml11/#NT-EntityDecl
// `[70] EntityDecl ::= GEDecl | PEDecl`
var EntityDecl = regg(GEDecl, '|', PEDecl);

// https://www.w3.org/TR/xml11/#NT-PublicID
// `[83] PublicID    ::= 'PUBLIC' S PubidLiteral`
var PublicID = reg(PUBLIC, S, PubidLiteral);
// https://www.w3.org/TR/xml11/#NT-NotationDecl
// `[82] NotationDecl    ::= '<!NOTATION' S Name S (ExternalID | PublicID) S? '>'` [VC: Unique Notation Name]
var NotationDecl = reg('<!NOTATION', S, Name, S, regg(ExternalID, '|', PublicID), S_OPT, '>');

// https://www.w3.org/TR/xml11/#NT-Eq
// `[25] Eq ::= S? '=' S?`
var Eq = reg(S_OPT, '=', S_OPT);
// https://www.w3.org/TR/xml/#NT-VersionNum
// `[26] VersionNum ::= '1.' [0-9]+`
// https://www.w3.org/TR/xml11/#NT-VersionNum
// `[26] VersionNum ::= '1.1'`
var VersionNum = /1[.]\d+/;
// https://www.w3.org/TR/xml11/#NT-VersionInfo
// `[24] VersionInfo ::= S 'version' Eq ("'" VersionNum "'" | '"' VersionNum '"')`
var VersionInfo = reg(S, 'version', Eq, regg("'", VersionNum, "'", '|', '"', VersionNum, '"'));
// https://www.w3.org/TR/xml11/#NT-EncName
// `[81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*`
var EncName = /[A-Za-z][-A-Za-z0-9._]*/;
// https://www.w3.org/TR/xml11/#NT-EncDecl
// `[80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" )`
var EncodingDecl = regg(S, 'encoding', Eq, regg('"', EncName, '"', '|', "'", EncName, "'"));
// https://www.w3.org/TR/xml11/#NT-SDDecl
// `[32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no') '"'))`
var SDDecl = regg(S, 'standalone', Eq, regg("'", regg('yes', '|', 'no'), "'", '|', '"', regg('yes', '|', 'no'), '"'));
// https://www.w3.org/TR/xml11/#NT-XMLDecl
// [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
var XMLDecl = reg(/^<\?xml/, VersionInfo, EncodingDecl, '?', SDDecl, '?', S_OPT, /\?>/);

/*
 https://www.w3.org/TR/xml/#NT-markupdecl
 https://www.w3.org/TR/xml11/#NT-markupdecl
 `[29] markupdecl ::= elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment`
 var markupdecl = regg(elementdecl, '|', AttlistDecl, '|', EntityDecl, '|', NotationDecl, '|', PI_unsafe, '|', Comment);
*/
/*
 https://www.w3.org/TR/xml-names/#NT-doctypedecl
`[28a] DeclSep   ::= PEReference | S`
 https://www.w3.org/TR/xml11/#NT-intSubset
```
 [28b] intSubset ::= (markupdecl | DeclSep)*
                 === (markupdecl | PEReference | S)*
```
 [WFC: PE Between Declarations]
 var intSubset = reg(regg(markupdecl, '|', PEReference, '|', S), '*');
*/
var DOCTYPE_DECL_START = '<!DOCTYPE';
/*
 https://www.w3.org/TR/xml11/#NT-doctypedecl
 `[28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'`
 https://www.afterwardsw3.org/TR/xml-names/#NT-doctypedecl
 `[16] doctypedecl ::= '<!DOCTYPE' S QName (S ExternalID)? S? ('[' (markupdecl | PEReference | S)* ']' S?)? '>'`
 var doctypedecl = reg('<!DOCTYPE', S, Name, regg(S, ExternalID), '?', S_OPT, regg(/\[/, intSubset, /]/, S_OPT), '?', '>');
*/

var CDATA_START = '<![CDATA[';
var CDATA_END = ']]>';
var CDStart = /<!\[CDATA\[/;
var CDEnd = /\]\]>/;
var CData = reg(Char, '*?', CDEnd);
/*
 https://www.w3.org/TR/xml/#dt-cdsection
 `[18]   	CDSect	   ::=   	CDStart CData CDEnd`
 `[19]   	CDStart	   ::=   	'<![CDATA['`
 `[20]   	CData	   ::=   	(Char* - (Char* ']]>' Char*))`
 `[21]   	CDEnd	   ::=   	']]>'`
*/
var CDSect = reg(CDStart, CData);

// unit tested
var chars_1 = grammar.chars = chars;
var chars_without_1 = grammar.chars_without = chars_without;
var detectUnicodeSupport_1 = grammar.detectUnicodeSupport = detectUnicodeSupport;
var reg_1 = grammar.reg = reg;
var regg_1 = grammar.regg = regg;
var ABOUT_LEGACY_COMPAT_1 = grammar.ABOUT_LEGACY_COMPAT = ABOUT_LEGACY_COMPAT;
var ABOUT_LEGACY_COMPAT_SystemLiteral_1 = grammar.ABOUT_LEGACY_COMPAT_SystemLiteral = ABOUT_LEGACY_COMPAT_SystemLiteral;
var AttlistDecl_1 = grammar.AttlistDecl = AttlistDecl;
var CDATA_START_1 = grammar.CDATA_START = CDATA_START;
var CDATA_END_1 = grammar.CDATA_END = CDATA_END;
var CDSect_1 = grammar.CDSect = CDSect;
var Char_1 = grammar.Char = Char;
var Comment_1$1 = grammar.Comment = Comment$2;
var COMMENT_START_1 = grammar.COMMENT_START = COMMENT_START;
var COMMENT_END_1 = grammar.COMMENT_END = COMMENT_END;
var DOCTYPE_DECL_START_1 = grammar.DOCTYPE_DECL_START = DOCTYPE_DECL_START;
var elementdecl_1 = grammar.elementdecl = elementdecl;
var EntityDecl_1 = grammar.EntityDecl = EntityDecl;
var EntityValue_1 = grammar.EntityValue = EntityValue;
var ExternalID_1 = grammar.ExternalID = ExternalID;
var ExternalID_match_1 = grammar.ExternalID_match = ExternalID_match;
var Name_1 = grammar.Name = Name;
var NotationDecl_1 = grammar.NotationDecl = NotationDecl;
var Reference_1 = grammar.Reference = Reference;
var PEReference_1 = grammar.PEReference = PEReference;
var PI_1 = grammar.PI = PI;
var PUBLIC_1 = grammar.PUBLIC = PUBLIC;
var PubidLiteral_1 = grammar.PubidLiteral = PubidLiteral;
var QName_1 = grammar.QName = QName;
var QName_exact_1 = grammar.QName_exact = QName_exact;
var QName_group_1 = grammar.QName_group = QName_group;
var S_1 = grammar.S = S;
var SChar_s_1 = grammar.SChar_s = SChar_s;
var S_OPT_1 = grammar.S_OPT = S_OPT;
var SYSTEM_1 = grammar.SYSTEM = SYSTEM;
var SystemLiteral_1 = grammar.SystemLiteral = SystemLiteral;
var UNICODE_REPLACEMENT_CHARACTER_1 = grammar.UNICODE_REPLACEMENT_CHARACTER = UNICODE_REPLACEMENT_CHARACTER;
var UNICODE_SUPPORT_1 = grammar.UNICODE_SUPPORT = UNICODE_SUPPORT;
var XMLDecl_1 = grammar.XMLDecl = XMLDecl;

'use strict';

var conventions$3 = conventions$5;
var find = conventions$3.find;
var hasDefaultHTMLNamespace$2 = conventions$3.hasDefaultHTMLNamespace;
var hasOwn$1 = conventions$3.hasOwn;
var isHTMLMimeType$3 = conventions$3.isHTMLMimeType;
var isHTMLRawTextElement$1 = conventions$3.isHTMLRawTextElement;
var isHTMLVoidElement = conventions$3.isHTMLVoidElement;
var MIME_TYPE$2 = conventions$3.MIME_TYPE;
var NAMESPACE$3 = conventions$3.NAMESPACE;

/**
 * Private DOM Constructor symbol
 *
 * Internal symbol used for construction of all classes whose constructors should be private.
 * Currently used for checks in `Node`, `Document`, `Element`, `Attr`, `CharacterData`, `Text`, `Comment`,
 * `CDATASection`, `DocumentType`, `Notation`, `Entity`, `EntityReference`, `DocumentFragment`, `ProcessingInstruction`
 * so the constructor can't be used from outside the module.
 */
var PDC = Symbol();

var errors$3 = errors$4;
var DOMException$2 = errors$3.DOMException;
var DOMExceptionName$1 = errors$3.DOMExceptionName;

var g$1 = grammar;

/**
 * Checks if the given symbol equals the Private DOM Constructor symbol (PDC)
 * and throws an Illegal constructor exception when the symbols don't match.
 * This ensures that the constructor remains private and can't be used outside this module.
 */
function checkSymbol(symbol) {
	if (symbol !== PDC) {
		throw new TypeError('Illegal constructor');
	}
}

/**
 * A prerequisite for `[].filter`, to drop elements that are empty.
 *
 * @param {string} input
 * The string to be checked.
 * @returns {boolean}
 * Returns `true` if the input string is not empty, `false` otherwise.
 */
function notEmptyString(input) {
	return input !== '';
}
/**
 * Splits a string on ASCII whitespace characters (U+0009 TAB, U+000A LF, U+000C FF, U+000D CR,
 * U+0020 SPACE).
 * It follows the definition from the infra specification from WHATWG.
 *
 * @param {string} input
 * The string to be split.
 * @returns {string[]}
 * An array of the split strings. The array can be empty if the input string is empty or only
 * contains whitespace characters.
 * @see {@link https://infra.spec.whatwg.org/#split-on-ascii-whitespace}
 * @see {@link https://infra.spec.whatwg.org/#ascii-whitespace}
 */
function splitOnASCIIWhitespace(input) {
	// U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
	return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
}

/**
 * Adds element as a key to current if it is not already present.
 *
 * @param {Record<string, boolean | undefined>} current
 * The current record object to which the element will be added as a key.
 * The object's keys are string types and values are either boolean or undefined.
 * @param {string} element
 * The string to be added as a key to the current record.
 * @returns {Record<string, boolean | undefined>}
 * The updated record object after the addition of the new element.
 */
function orderedSetReducer(current, element) {
	if (!hasOwn$1(current, element)) {
		current[element] = true;
	}
	return current;
}

/**
 * Converts a string into an ordered set by splitting the input on ASCII whitespace and
 * ensuring uniqueness of elements.
 * This follows the definition of an ordered set from the infra specification by WHATWG.
 *
 * @param {string} input
 * The input string to be transformed into an ordered set.
 * @returns {string[]}
 * An array of unique strings obtained from the input, preserving the original order.
 * The array can be empty if the input string is empty or only contains whitespace characters.
 * @see {@link https://infra.spec.whatwg.org/#ordered-set}
 */
function toOrderedSet(input) {
	if (!input) return [];
	var list = splitOnASCIIWhitespace(input);
	return Object.keys(list.reduce(orderedSetReducer, {}));
}

/**
 * Uses `list.indexOf` to implement a function that behaves like `Array.prototype.includes`.
 * This function is used in environments where `Array.prototype.includes` may not be available.
 *
 * @param {any[]} list
 * The array in which to search for the element.
 * @returns {function(any): boolean}
 * A function that accepts an element and returns a boolean indicating whether the element is
 * included in the provided list.
 */
function arrayIncludes(list) {
	return function (element) {
		return list && list.indexOf(element) !== -1;
	};
}

/**
 * Validates a qualified name based on the criteria provided in the DOM specification by
 * WHATWG.
 *
 * @param {string} qualifiedName
 * The qualified name to be validated.
 * @throws {DOMException}
 * With code {@link DOMException.INVALID_CHARACTER_ERR} if the qualified name contains an
 * invalid character.
 * @see {@link https://dom.spec.whatwg.org/#validate}
 */
function validateQualifiedName(qualifiedName) {
	if (!g$1.QName_exact.test(qualifiedName)) {
		throw new DOMException$2(DOMException$2.INVALID_CHARACTER_ERR, 'invalid character in qualified name "' + qualifiedName + '"');
	}
}

/**
 * Validates a qualified name and the namespace associated with it,
 * based on the criteria provided in the DOM specification by WHATWG.
 *
 * @param {string | null} namespace
 * The namespace to be validated. It can be a string or null.
 * @param {string} qualifiedName
 * The qualified name to be validated.
 * @returns {[namespace: string | null, prefix: string | null, localName: string]}
 * Returns a tuple with the namespace,
 * prefix and local name of the qualified name.
 * @throws {DOMException}
 * Throws a DOMException if the qualified name or the namespace is not valid.
 * @see {@link https://dom.spec.whatwg.org/#validate-and-extract}
 */
function validateAndExtract(namespace, qualifiedName) {
	validateQualifiedName(qualifiedName);
	namespace = namespace || null;
	/**
	 * @type {string | null}
	 */
	var prefix = null;
	var localName = qualifiedName;
	if (qualifiedName.indexOf(':') >= 0) {
		var splitResult = qualifiedName.split(':');
		prefix = splitResult[0];
		localName = splitResult[1];
	}
	if (prefix !== null && namespace === null) {
		throw new DOMException$2(DOMException$2.NAMESPACE_ERR, 'prefix is non-null and namespace is null');
	}
	if (prefix === 'xml' && namespace !== conventions$3.NAMESPACE.XML) {
		throw new DOMException$2(DOMException$2.NAMESPACE_ERR, 'prefix is "xml" and namespace is not the XML namespace');
	}
	if ((prefix === 'xmlns' || qualifiedName === 'xmlns') && namespace !== conventions$3.NAMESPACE.XMLNS) {
		throw new DOMException$2(
			DOMException$2.NAMESPACE_ERR,
			'either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace'
		);
	}
	if (namespace === conventions$3.NAMESPACE.XMLNS && prefix !== 'xmlns' && qualifiedName !== 'xmlns') {
		throw new DOMException$2(
			DOMException$2.NAMESPACE_ERR,
			'namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns"'
		);
	}
	return [namespace, prefix, localName];
}

/**
 * Copies properties from one object to another.
 * It only copies the object's own (not inherited) properties.
 *
 * @param {Object} src
 * The source object from which properties are copied.
 * @param {Object} dest
 * The destination object to which properties are copied.
 */
function copy(src, dest) {
	for (var p in src) {
		if (hasOwn$1(src, p)) {
			dest[p] = src[p];
		}
	}
}

/**
 * Extends a class with the properties and methods of a super class.
 * It uses a form of prototypal inheritance, and establishes the `constructor` property
 * correctly(?).
 *
 * It is not clear to the current maintainers if this implementation is making sense,
 * since it creates an intermediate prototype function,
 * which all properties of `Super` are copied onto using `_copy`.
 *
 * @param {Object} Class
 * The class that is to be extended.
 * @param {Object} Super
 * The super class from which properties and methods are inherited.
 * @private
 */
function _extends(Class, Super) {
	var pt = Class.prototype;
	if (!(pt instanceof Super)) {
		function t() {}
		t.prototype = Super.prototype;
		t = new t();
		copy(pt, t);
		Class.prototype = pt = t;
	}
	if (pt.constructor != Class) {
		if (typeof Class != 'function') {
			console.error('unknown Class:' + Class);
		}
		pt.constructor = Class;
	}
}

var NodeType = {};
var ELEMENT_NODE = (NodeType.ELEMENT_NODE = 1);
var ATTRIBUTE_NODE = (NodeType.ATTRIBUTE_NODE = 2);
var TEXT_NODE = (NodeType.TEXT_NODE = 3);
var CDATA_SECTION_NODE = (NodeType.CDATA_SECTION_NODE = 4);
var ENTITY_REFERENCE_NODE = (NodeType.ENTITY_REFERENCE_NODE = 5);
var ENTITY_NODE = (NodeType.ENTITY_NODE = 6);
var PROCESSING_INSTRUCTION_NODE = (NodeType.PROCESSING_INSTRUCTION_NODE = 7);
var COMMENT_NODE = (NodeType.COMMENT_NODE = 8);
var DOCUMENT_NODE = (NodeType.DOCUMENT_NODE = 9);
var DOCUMENT_TYPE_NODE = (NodeType.DOCUMENT_TYPE_NODE = 10);
var DOCUMENT_FRAGMENT_NODE = (NodeType.DOCUMENT_FRAGMENT_NODE = 11);
var NOTATION_NODE = (NodeType.NOTATION_NODE = 12);

var DocumentPosition = conventions$3.freeze({
	DOCUMENT_POSITION_DISCONNECTED: 1,
	DOCUMENT_POSITION_PRECEDING: 2,
	DOCUMENT_POSITION_FOLLOWING: 4,
	DOCUMENT_POSITION_CONTAINS: 8,
	DOCUMENT_POSITION_CONTAINED_BY: 16,
	DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32,
});

//helper functions for compareDocumentPosition
/**
 * Finds the common ancestor in two parent chains.
 *
 * @param {Node[]} a
 * The first parent chain.
 * @param {Node[]} b
 * The second parent chain.
 * @returns {Node}
 * The common ancestor node if it exists. If there is no common ancestor, the function will
 * return `null`.
 */
function commonAncestor(a, b) {
	if (b.length < a.length) return commonAncestor(b, a);
	var c = null;
	for (var n in a) {
		if (a[n] !== b[n]) return c;
		c = a[n];
	}
	return c;
}

/**
 * Assigns a unique identifier to a document to ensure consistency while comparing unrelated
 * nodes.
 *
 * @param {Document} doc
 * The document to which a unique identifier is to be assigned.
 * @returns {string}
 * The unique identifier of the document. If the document already had a unique identifier, the
 * function will return the existing one.
 */
function docGUID(doc) {
	if (!doc.guid) doc.guid = Math.random();
	return doc.guid;
}
//-- end of helper functions

/**
 * The NodeList interface provides the abstraction of an ordered collection of nodes,
 * without defining or constraining how this collection is implemented.
 * NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 * You can also access the items of the NodeList with a `for...of` loop.
 *
 * @class NodeList
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * @constructs NodeList
 */
function NodeList$1() {}
NodeList$1.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1
	 * inclusive.
	 *
	 * @type {number}
	 */
	length: 0,
	/**
	 * Returns the item at `index`. If index is greater than or equal to the number of nodes in
	 * the list, this returns null.
	 *
	 * @param index
	 * Unsigned long Index into the collection.
	 * @returns {Node | null}
	 * The node at position `index` in the NodeList,
	 * or null if that is not a valid index.
	 */
	item: function (index) {
		return index >= 0 && index < this.length ? this[index] : null;
	},
	/**
	 * Returns a string representation of the NodeList.
	 *
	 * @param {unknown} nodeFilter
	 * __A filter function? Not implemented according to the spec?__.
	 * @returns {string}
	 * A string representation of the NodeList.
	 */
	toString: function (nodeFilter) {
		for (var buf = [], i = 0; i < this.length; i++) {
			serializeToString(this[i], buf, nodeFilter);
		}
		return buf.join('');
	},
	/**
	 * Filters the NodeList based on a predicate.
	 *
	 * @param {function(Node): boolean} predicate
	 * - A predicate function to filter the NodeList.
	 * @returns {Node[]}
	 * An array of nodes that satisfy the predicate.
	 * @private
	 */
	filter: function (predicate) {
		return Array.prototype.filter.call(this, predicate);
	},
	/**
	 * Returns the first index at which a given node can be found in the NodeList, or -1 if it is
	 * not present.
	 *
	 * @param {Node} item
	 * - The Node item to locate in the NodeList.
	 * @returns {number}
	 * The first index of the node in the NodeList; -1 if not found.
	 * @private
	 */
	indexOf: function (item) {
		return Array.prototype.indexOf.call(this, item);
	},
};
NodeList$1.prototype[Symbol.iterator] = function () {
	var me = this;
	var index = 0;

	return {
		next: function () {
			if (index < me.length) {
				return {
					value: me[index++],
					done: false,
				};
			} else {
				return {
					done: true,
				};
			}
		},
		return: function () {
			return {
				done: true,
			};
		},
	};
};

/**
 * Represents a live collection of nodes that is automatically updated when its associated
 * document changes.
 *
 * @class LiveNodeList
 * @param {Node} node
 * The associated node.
 * @param {function} refresh
 * The function to refresh the live node list.
 * @augments NodeList
 * @constructs LiveNodeList
 */
function LiveNodeList$1(node, refresh) {
	this._node = node;
	this._refresh = refresh;
	_updateLiveList(this);
}
/**
 * Updates the live node list.
 *
 * @param {LiveNodeList} list
 * The live node list to update.
 * @private
 */
function _updateLiveList(list) {
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if (list._inc !== inc) {
		var ls = list._refresh(list._node);
		__set__(list, 'length', ls.length);
		if (!list.$$length || ls.length < list.$$length) {
			for (var i = ls.length; i in list; i++) {
				if (hasOwn$1(list, i)) {
					delete list[i];
				}
			}
		}
		copy(ls, list);
		list._inc = inc;
	}
}
/**
 * Returns the node at position `index` in the LiveNodeList, or null if that is not a valid
 * index.
 *
 * @param {number} i
 * Index into the collection.
 * @returns {Node | null}
 * The node at position `index` in the LiveNodeList, or null if that is not a valid index.
 */
LiveNodeList$1.prototype.item = function (i) {
	_updateLiveList(this);
	return this[i] || null;
};

_extends(LiveNodeList$1, NodeList$1);

/**
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes
 * that can be accessed by name.
 * Note that NamedNodeMap does not inherit from NodeList;
 * NamedNodeMaps are not maintained in any particular order.
 * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal
 * index,
 * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
 * and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities
 *
 * This implementation only supports property indices, but does not support named properties,
 * as specified in the living standard.
 *
 * @class NamedNodeMap
 * @see https://dom.spec.whatwg.org/#interface-namednodemap
 * @see https://webidl.spec.whatwg.org/#dfn-supported-property-names
 * @constructs NamedNodeMap
 */
function NamedNodeMap$1() {}
/**
 * Returns the index of a node within the list.
 *
 * @param {Array} list
 * The list of nodes.
 * @param {Node} node
 * The node to find.
 * @returns {number}
 * The index of the node within the list, or -1 if not found.
 * @private
 */
function _findNodeIndex(list, node) {
	var i = 0;
	while (i < list.length) {
		if (list[i] === node) {
			return i;
		}
		i++;
	}
}
/**
 * Adds a new attribute to the list and updates the owner element of the attribute.
 *
 * @param {Element} el
 * The element which will become the owner of the new attribute.
 * @param {NamedNodeMap} list
 * The list to which the new attribute will be added.
 * @param {Attr} newAttr
 * The new attribute to be added.
 * @param {Attr} oldAttr
 * The old attribute to be replaced, or null if no attribute is to be replaced.
 * @returns {void}
 * @private
 */
function _addNamedNode(el, list, newAttr, oldAttr) {
	if (oldAttr) {
		list[_findNodeIndex(list, oldAttr)] = newAttr;
	} else {
		list[list.length] = newAttr;
		list.length++;
	}
	if (el) {
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if (doc) {
			oldAttr && _onRemoveAttribute(doc, el, oldAttr);
			_onAddAttribute(doc, el, newAttr);
		}
	}
}
/**
 * Removes an attribute from the list and updates the owner element of the attribute.
 *
 * @param {Element} el
 * The element which is the current owner of the attribute.
 * @param {NamedNodeMap} list
 * The list from which the attribute will be removed.
 * @param {Attr} attr
 * The attribute to be removed.
 * @returns {void}
 * @private
 */
function _removeNamedNode(el, list, attr) {
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list, attr);
	if (i >= 0) {
		var lastIndex = list.length - 1;
		while (i <= lastIndex) {
			list[i] = list[++i];
		}
		list.length = lastIndex;
		if (el) {
			var doc = el.ownerDocument;
			if (doc) {
				_onRemoveAttribute(doc, el, attr);
			}
			attr.ownerElement = null;
		}
	}
}
NamedNodeMap$1.prototype = {
	length: 0,
	item: NodeList$1.prototype.item,

	/**
	 * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and
	 * document.
	 *
	 * @param {string} localName
	 * The local name of the attribute.
	 * @returns {Attr | null}
	 * The attribute with the given local name, or null if no such attribute exists.
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name
	 */
	getNamedItem: function (localName) {
		if (this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace()) {
			localName = localName.toLowerCase();
		}
		var i = 0;
		while (i < this.length) {
			var attr = this[i];
			if (attr.nodeName === localName) {
				return attr;
			}
			i++;
		}
		return null;
	},

	/**
	 * Set an attribute.
	 *
	 * @param {Attr} attr
	 * The attribute to set.
	 * @returns {Attr | null}
	 * The old attribute with the same local name and namespace URI as the new one, or null if no
	 * such attribute exists.
	 * @throws {DOMException}
	 * With code:
	 * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another
	 * element.
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
	 */
	setNamedItem: function (attr) {
		var el = attr.ownerElement;
		if (el && el !== this._ownerElement) {
			throw new DOMException$2(DOMException$2.INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
		if (oldAttr === attr) {
			return attr;
		}
		_addNamedNode(this._ownerElement, this, attr, oldAttr);
		return oldAttr;
	},

	/**
	 * Set an attribute, replacing an existing attribute with the same local name and namespace
	 * URI if one exists.
	 *
	 * @param {Attr} attr
	 * The attribute to set.
	 * @returns {Attr | null}
	 * The old attribute with the same local name and namespace URI as the new one, or null if no
	 * such attribute exists.
	 * @throws {DOMException}
	 * Throws a DOMException with the name "InUseAttributeError" if the attribute is already an
	 * attribute of another element.
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
	 */
	setNamedItemNS: function (attr) {
		return this.setNamedItem(attr);
	},

	/**
	 * Removes an attribute specified by the local name.
	 *
	 * @param {string} localName
	 * The local name of the attribute to be removed.
	 * @returns {Attr}
	 * The attribute node that was removed.
	 * @throws {DOMException}
	 * With code:
	 * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.
	 * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name
	 */
	removeNamedItem: function (localName) {
		var attr = this.getNamedItem(localName);
		if (!attr) {
			throw new DOMException$2(DOMException$2.NOT_FOUND_ERR, localName);
		}
		_removeNamedNode(this._ownerElement, this, attr);
		return attr;
	},

	/**
	 * Removes an attribute specified by the namespace and local name.
	 *
	 * @param {string | null} namespaceURI
	 * The namespace URI of the attribute to be removed.
	 * @param {string} localName
	 * The local name of the attribute to be removed.
	 * @returns {Attr}
	 * The attribute node that was removed.
	 * @throws {DOMException}
	 * With code:
	 * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local
	 * name is found.
	 * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace
	 */
	removeNamedItemNS: function (namespaceURI, localName) {
		var attr = this.getNamedItemNS(namespaceURI, localName);
		if (!attr) {
			throw new DOMException$2(DOMException$2.NOT_FOUND_ERR, namespaceURI ? namespaceURI + ' : ' + localName : localName);
		}
		_removeNamedNode(this._ownerElement, this, attr);
		return attr;
	},

	/**
	 * Get an attribute by namespace and local name.
	 *
	 * @param {string | null} namespaceURI
	 * The namespace URI of the attribute.
	 * @param {string} localName
	 * The local name of the attribute.
	 * @returns {Attr | null}
	 * The attribute with the given namespace URI and local name, or null if no such attribute
	 * exists.
	 * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace
	 */
	getNamedItemNS: function (namespaceURI, localName) {
		if (!namespaceURI) {
			namespaceURI = null;
		}
		var i = 0;
		while (i < this.length) {
			var node = this[i];
			if (node.localName === localName && node.namespaceURI === namespaceURI) {
				return node;
			}
			i++;
		}
		return null;
	},
};
NamedNodeMap$1.prototype[Symbol.iterator] = function () {
	var me = this;
	var index = 0;

	return {
		next: function () {
			if (index < me.length) {
				return {
					value: me[index++],
					done: false,
				};
			} else {
				return {
					done: true,
				};
			}
		},
		return: function () {
			return {
				done: true,
			};
		},
	};
};

/**
 * The DOMImplementation interface provides a number of methods for performing operations that
 * are independent of any particular instance of the document object model.
 *
 * The DOMImplementation interface represents an object providing methods which are not
 * dependent on any particular document.
 * Such an object is returned by the `Document.implementation` property.
 *
 * **The individual methods describe the differences compared to the specs**.
 *
 * @class DOMImplementation
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core
 *      (Initial)
 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
 * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
 * @constructs DOMImplementation
 */
function DOMImplementation$2() {}

DOMImplementation$2.prototype = {
	/**
	 * Test if the DOM implementation implements a specific feature and version, as specified in
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.
	 *
	 * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given
	 * feature is supported. The different implementations fairly diverged in what kind of
	 * features were reported. The latest version of the spec settled to force this method to
	 * always return true, where the functionality was accurate and in use.
	 *
	 * @deprecated
	 * It is deprecated and modern browsers return true in all cases.
	 * @function DOMImplementation#hasFeature
	 * @param {string} feature
	 * The name of the feature to test.
	 * @param {string} [version]
	 * This is the version number of the feature to test.
	 * @returns {boolean}
	 * Always returns true.
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
	 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core
	 */
	hasFeature: function (feature, version) {
		return true;
	},
	/**
	 * Creates a DOM Document object of the specified type with its document element. Note that
	 * based on the {@link DocumentType}
	 * given to create the document, the implementation may instantiate specialized
	 * {@link Document} objects that support additional features than the "Core", such as "HTML"
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.
	 * On the other hand, setting the {@link DocumentType} after the document was created makes
	 * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,
	 * such as createHTMLDocument
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},
	 * can be used to obtain specific types of {@link Document} objects.
	 *
	 * __It behaves slightly different from the description in the living standard__:
	 * - There is no interface/class `XMLDocument`, it returns a `Document`
	 * instance (with it's `type` set to `'xml'`).
	 * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
	 *
	 * @function DOMImplementation.createDocument
	 * @param {string | null} namespaceURI
	 * The
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}
	 * of the document element to create or null.
	 * @param {string | null} qualifiedName
	 * The
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}
	 * of the document element to be created or null.
	 * @param {DocumentType | null} [doctype=null]
	 * The type of document to be created or null. When doctype is not null, its
	 * {@link Node#ownerDocument} attribute is set to the document being created. Default is
	 * `null`
	 * @returns {Document}
	 * A new {@link Document} object with its document element. If the NamespaceURI,
	 * qualifiedName, and doctype are null, the returned {@link Document} is empty with no
	 * document element.
	 * @throws {DOMException}
	 * With code:
	 *
	 * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
	 * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
	 * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a
	 * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI
	 * is different from null, or if the qualifiedName has a prefix that is "xml" and the
	 * namespaceURI is different from "{@link http://www.w3.org/XML/1998/namespace}"
	 * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},
	 * or if the DOM implementation does not support the "XML" feature but a non-null namespace
	 * URI was provided, since namespaces were defined by XML.
	 * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document
	 * or was created from a different implementation.
	 * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
	 * "XML" and the language exposed through the Document does not support XML Namespaces (such
	 * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
	 * @since DOM Level 2.
	 * @see {@link #createHTMLDocument}
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM
	 *      Level 3 Core
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM
	 *      Level 2 Core (initial)
	 */
	createDocument: function (namespaceURI, qualifiedName, doctype) {
		var contentType = MIME_TYPE$2.XML_APPLICATION;
		if (namespaceURI === NAMESPACE$3.HTML) {
			contentType = MIME_TYPE$2.XML_XHTML_APPLICATION;
		} else if (namespaceURI === NAMESPACE$3.SVG) {
			contentType = MIME_TYPE$2.XML_SVG_IMAGE;
		}
		var doc = new Document$1(PDC, { contentType: contentType });
		doc.implementation = this;
		doc.childNodes = new NodeList$1();
		doc.doctype = doctype || null;
		if (doctype) {
			doc.appendChild(doctype);
		}
		if (qualifiedName) {
			var root = doc.createElementNS(namespaceURI, qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	/**
	 * Creates an empty DocumentType node. Entity declarations and notations are not made
	 * available. Entity reference expansions and default attribute additions do not occur.
	 *
	 * **This behavior is slightly different from the one in the specs**:
	 * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
	 * - `publicId` and `systemId` contain the raw data including any possible quotes,
	 *   so they can always be serialized back to the original value
	 * - `internalSubset` contains the raw string between `[` and `]` if present,
	 *   but is not parsed or validated in any form.
	 *
	 * @function DOMImplementation#createDocumentType
	 * @param {string} qualifiedName
	 * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified
	 * name} of the document type to be created.
	 * @param {string} [publicId]
	 * The external subset public identifier.
	 * @param {string} [systemId]
	 * The external subset system identifier.
	 * @param {string} [internalSubset]
	 * the internal subset or an empty string if it is not present
	 * @returns {DocumentType}
	 * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.
	 * @throws {DOMException}
	 * With code:
	 *
	 * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
	 * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
	 * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.
	 * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
	 * "XML" and the language exposed through the Document does not support XML Namespaces (such
	 * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
	 * @since DOM Level 2.
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType
	 *      MDN
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living
	 *      Standard
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM
	 *      Level 3 Core
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM
	 *      Level 2 Core
	 * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset
	 * @prettierignore
	 */
	createDocumentType: function (qualifiedName, publicId, systemId, internalSubset) {
		validateQualifiedName(qualifiedName);
		var node = new DocumentType$1(PDC);
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId || '';
		node.systemId = systemId || '';
		node.internalSubset = internalSubset || '';
		node.childNodes = new NodeList$1();

		return node;
	},
	/**
	 * Returns an HTML document, that might already have a basic DOM structure.
	 *
	 * __It behaves slightly different from the description in the living standard__:
	 * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are
	 * omitted)
	 * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
	 *
	 * @param {string | false} [title]
	 * A string containing the title to give the new HTML document.
	 * @returns {Document}
	 * The HTML document.
	 * @since WHATWG Living Standard.
	 * @see {@link #createDocument}
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
	 * @see https://dom.spec.whatwg.org/#html-document
	 */
	createHTMLDocument: function (title) {
		var doc = new Document$1(PDC, { contentType: MIME_TYPE$2.HTML });
		doc.implementation = this;
		doc.childNodes = new NodeList$1();
		if (title !== false) {
			doc.doctype = this.createDocumentType('html');
			doc.doctype.ownerDocument = doc;
			doc.appendChild(doc.doctype);
			var htmlNode = doc.createElement('html');
			doc.appendChild(htmlNode);
			var headNode = doc.createElement('head');
			htmlNode.appendChild(headNode);
			if (typeof title === 'string') {
				var titleNode = doc.createElement('title');
				titleNode.appendChild(doc.createTextNode(title));
				headNode.appendChild(titleNode);
			}
			htmlNode.appendChild(doc.createElement('body'));
		}
		return doc;
	},
};

/**
 * The DOM Node interface is an abstract base class upon which many other DOM API objects are
 * based, thus letting those object types to be used similarly and often interchangeably. As an
 * abstract class, there is no such thing as a plain Node object. All objects that implement
 * Node functionality are based on one of its subclasses. Most notable are Document, Element,
 * and DocumentFragment.
 *
 * In addition, every kind of DOM node is represented by an interface based on Node. These
 * include Attr, CharacterData (which Text, Comment, CDATASection and ProcessingInstruction are
 * all based on), and DocumentType.
 *
 * In some cases, a particular feature of the base Node interface may not apply to one of its
 * child interfaces; in that case, the inheriting node may return null or throw an exception,
 * depending on circumstances. For example, attempting to add children to a node type that
 * cannot have children will throw an exception.
 *
 * **This behavior is slightly different from the in the specs**:
 * - unimplemented interfaces: `EventTarget`
 *
 * @class
 * @abstract
 * @param {Symbol} symbol
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 * @see https://dom.spec.whatwg.org/#node
 * @prettierignore
 */
function Node$1(symbol) {
	checkSymbol(symbol);
}

Node$1.prototype = {
	/**
	 * The first child of this node.
	 *
	 * @type {Node | null}
	 */
	firstChild: null,
	/**
	 * The last child of this node.
	 *
	 * @type {Node | null}
	 */
	lastChild: null,
	/**
	 * The previous sibling of this node.
	 *
	 * @type {Node | null}
	 */
	previousSibling: null,
	/**
	 * The next sibling of this node.
	 *
	 * @type {Node | null}
	 */
	nextSibling: null,
	/**
	 * The parent node of this node.
	 *
	 * @type {Node | null}
	 */
	parentNode: null,
	/**
	 * The parent element of this node.
	 *
	 * @type {Element | null}
	 */
	get parentElement() {
		return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;
	},
	/**
	 * The child nodes of this node.
	 *
	 * @type {NodeList}
	 */
	childNodes: null,
	/**
	 * The document object associated with this node.
	 *
	 * @type {Document | null}
	 */
	ownerDocument: null,
	/**
	 * The value of this node.
	 *
	 * @type {string | null}
	 */
	nodeValue: null,
	/**
	 * The namespace URI of this node.
	 *
	 * @type {string | null}
	 */
	namespaceURI: null,
	/**
	 * The prefix of the namespace for this node.
	 *
	 * @type {string | null}
	 */
	prefix: null,
	/**
	 * The local part of the qualified name of this node.
	 *
	 * @type {string | null}
	 */
	localName: null,
	/**
	 * The baseURI is currently always `about:blank`,
	 * since that's what happens when you create a document from scratch.
	 *
	 * @type {'about:blank'}
	 */
	baseURI: 'about:blank',
	/**
	 * Is true if this node is part of a document.
	 *
	 * @type {boolean}
	 */
	get isConnected() {
		var rootNode = this.getRootNode();
		return rootNode && rootNode.nodeType === rootNode.DOCUMENT_NODE;
	},
	/**
	 * Checks whether `other` is an inclusive descendant of this node.
	 *
	 * @param {Node | null | undefined} other
	 * The node to check.
	 * @returns {boolean}
	 * True if `other` is an inclusive descendant of this node; false otherwise.
	 * @see https://dom.spec.whatwg.org/#dom-node-contains
	 */
	contains: function (other) {
		if (!other) return false;
		var parent = other;
		do {
			if (this === parent) return true;
			parent = other.parentNode;
		} while (parent);
		return false;
	},
	/**
	 * @typedef GetRootNodeOptions
	 * @property {boolean} [composed=false]
	 */
	/**
	 * Searches for the root node of this node.
	 *
	 * **This behavior is slightly different from the in the specs**:
	 * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.
	 *
	 * @param {GetRootNodeOptions} [options]
	 * @returns {Node}
	 * Root node.
	 * @see https://dom.spec.whatwg.org/#dom-node-getrootnode
	 * @see https://dom.spec.whatwg.org/#concept-shadow-including-root
	 */
	getRootNode: function (options) {
		var parent = this;
		do {
			if (!parent.parentNode) {
				return parent;
			}
			parent = parent.parentNode;
		} while (parent);
	},
	/**
	 * Checks whether the given node is equal to this node.
	 *
	 * @param {Node} [otherNode]
	 * @see https://dom.spec.whatwg.org/#concept-node-equals
	 */
	isEqualNode: function (otherNode) {
		if (!otherNode) return false;

		if (this.nodeType !== otherNode.nodeType) return false;

		switch (this.nodeType) {
			case this.DOCUMENT_TYPE_NODE:
				if (this.name !== otherNode.name) return false;
				if (this.publicId !== otherNode.publicId) return false;
				if (this.systemId !== otherNode.systemId) return false;
				break;
			case this.ELEMENT_NODE:
				if (this.namespaceURI !== otherNode.namespaceURI) return false;
				if (this.prefix !== otherNode.prefix) return false;
				if (this.localName !== otherNode.localName) return false;
				if (this.attributes.length !== otherNode.attributes.length) return false;
				for (var i = 0; i < this.attributes.length; i++) {
					var attr = this.attributes.item(i);
					if (!attr.isEqualNode(otherNode.getAttributeNodeNS(attr.namespaceURI, attr.localName))) {
						return false;
					}
				}
				break;
			case this.ATTRIBUTE_NODE:
				if (this.namespaceURI !== otherNode.namespaceURI) return false;
				if (this.localName !== otherNode.localName) return false;
				if (this.value !== otherNode.value) return false;

				break;
			case this.PROCESSING_INSTRUCTION_NODE:
				if (this.target !== otherNode.target || this.data !== otherNode.data) {
					return false;
				}
				break;
			case this.TEXT_NODE:
			case this.COMMENT_NODE:
				if (this.data !== otherNode.data) return false;
				break;
		}

		if (this.childNodes.length !== otherNode.childNodes.length) {
			return false;
		}

		for (var i = 0; i < this.childNodes.length; i++) {
			if (!this.childNodes[i].isEqualNode(otherNode.childNodes[i])) {
				return false;
			}
		}

		return true;
	},
	/**
	 * Checks whether or not the given node is this node.
	 *
	 * @param {Node} [otherNode]
	 */
	isSameNode: function (otherNode) {
		return this === otherNode;
	},
	/**
	 * Inserts a node before a reference node as a child of this node.
	 *
	 * @param {Node} newChild
	 * The new child node to be inserted.
	 * @param {Node | null} refChild
	 * The reference node before which newChild will be inserted.
	 * @returns {Node}
	 * The new child node successfully inserted.
	 * @throws {DOMException}
	 * Throws a DOMException if inserting the node would result in a DOM tree that is not
	 * well-formed, or if `child` is provided but is not a child of `parent`.
	 * See {@link _insertBefore} for more details.
	 * @since Modified in DOM L2
	 */
	insertBefore: function (newChild, refChild) {
		return _insertBefore(this, newChild, refChild);
	},
	/**
	 * Replaces an old child node with a new child node within this node.
	 *
	 * @param {Node} newChild
	 * The new node that is to replace the old node.
	 * If it already exists in the DOM, it is removed from its original position.
	 * @param {Node} oldChild
	 * The existing child node to be replaced.
	 * @returns {Node}
	 * Returns the replaced child node.
	 * @throws {DOMException}
	 * Throws a DOMException if replacing the node would result in a DOM tree that is not
	 * well-formed, or if `oldChild` is not a child of `this`.
	 * This can also occur if the pre-replacement validity assertion fails.
	 * See {@link _insertBefore}, {@link Node.removeChild}, and
	 * {@link assertPreReplacementValidityInDocument} for more details.
	 * @see https://dom.spec.whatwg.org/#concept-node-replace
	 */
	replaceChild: function (newChild, oldChild) {
		_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
		if (oldChild) {
			this.removeChild(oldChild);
		}
	},
	/**
	 * Removes an existing child node from this node.
	 *
	 * @param {Node} oldChild
	 * The child node to be removed.
	 * @returns {Node}
	 * Returns the removed child node.
	 * @throws {DOMException}
	 * Throws a DOMException if `oldChild` is not a child of `this`.
	 * See {@link _removeChild} for more details.
	 */
	removeChild: function (oldChild) {
		return _removeChild(this, oldChild);
	},
	/**
	 * Appends a child node to this node.
	 *
	 * @param {Node} newChild
	 * The child node to be appended to this node.
	 * If it already exists in the DOM, it is removed from its original position.
	 * @returns {Node}
	 * Returns the appended child node.
	 * @throws {DOMException}
	 * Throws a DOMException if appending the node would result in a DOM tree that is not
	 * well-formed, or if `newChild` is not a valid Node.
	 * See {@link insertBefore} for more details.
	 */
	appendChild: function (newChild) {
		return this.insertBefore(newChild, null);
	},
	/**
	 * Determines whether this node has any child nodes.
	 *
	 * @returns {boolean}
	 * Returns true if this node has any child nodes, and false otherwise.
	 */
	hasChildNodes: function () {
		return this.firstChild != null;
	},
	/**
	 * Creates a copy of the calling node.
	 *
	 * @param {boolean} deep
	 * If true, the contents of the node are recursively copied.
	 * If false, only the node itself (and its attributes, if it is an element) are copied.
	 * @returns {Node}
	 * Returns the newly created copy of the node.
	 * @throws {DOMException}
	 * May throw a DOMException if operations within {@link Element#setAttributeNode} or
	 * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their
	 * specific constraints.
	 * @see {@link cloneNode}
	 */
	cloneNode: function (deep) {
		return cloneNode(this.ownerDocument || this, this, deep);
	},
	/**
	 * Puts the specified node and all of its subtree into a "normalized" form. In a normalized
	 * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.
	 *
	 * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`
	 * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text
	 * nodes.
	 *
	 * This method operates recursively, so it also normalizes any and all descendent nodes within
	 * the subtree.
	 *
	 * @throws {DOMException}
	 * May throw a DOMException if operations within removeChild or appendData (which are
	 * potentially invoked in this method) do not meet their specific constraints.
	 * @since Modified in DOM Level 2
	 * @see {@link Node.removeChild}
	 * @see {@link CharacterData.appendData}
	 */
	normalize: function () {
		var child = this.firstChild;
		while (child) {
			var next = child.nextSibling;
			if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
				this.removeChild(next);
				child.appendData(next.data);
			} else {
				child.normalize();
				child = next;
			}
		}
	},
	/**
	 * Checks whether the DOM implementation implements a specific feature and its version.
	 *
	 * @deprecated
	 * Since `DOMImplementation.hasFeature` is deprecated and always returns true.
	 * @param {string} feature
	 * The package name of the feature to test. This is the same name that can be passed to the
	 * method `hasFeature` on `DOMImplementation`.
	 * @param {string} version
	 * This is the version number of the package name to test.
	 * @returns {boolean}
	 * Returns true in all cases in the current implementation.
	 * @since Introduced in DOM Level 2
	 * @see {@link DOMImplementation.hasFeature}
	 */
	isSupported: function (feature, version) {
		return this.ownerDocument.implementation.hasFeature(feature, version);
	},
	/**
	 * Look up the prefix associated to the given namespace URI, starting from this node.
	 * **The default namespace declarations are ignored by this method.**
	 * See Namespace Prefix Lookup for details on the algorithm used by this method.
	 *
	 * **This behavior is different from the in the specs**:
	 * - no node type specific handling
	 * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
	 *
	 * @param {string | null} namespaceURI
	 * The namespace URI for which to find the associated prefix.
	 * @returns {string | null}
	 * The associated prefix, if found; otherwise, null.
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
	 * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
	 * @see https://github.com/xmldom/xmldom/issues/322
	 * @prettierignore
	 */
	lookupPrefix: function (namespaceURI) {
		var el = this;
		while (el) {
			var map = el._nsMap;
			//console.dir(map)
			if (map) {
				for (var n in map) {
					if (hasOwn$1(map, n) && map[n] === namespaceURI) {
						return n;
					}
				}
			}
			el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
		}
		return null;
	},
	/**
	 * This function is used to look up the namespace URI associated with the given prefix,
	 * starting from this node.
	 *
	 * **This behavior is different from the in the specs**:
	 * - no node type specific handling
	 * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
	 *
	 * @param {string | null} prefix
	 * The prefix for which to find the associated namespace URI.
	 * @returns {string | null}
	 * The associated namespace URI, if found; otherwise, null.
	 * @since DOM Level 3
	 * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI
	 * @prettierignore
	 */
	lookupNamespaceURI: function (prefix) {
		var el = this;
		while (el) {
			var map = el._nsMap;
			//console.dir(map)
			if (map) {
				if (hasOwn$1(map, prefix)) {
					return map[prefix];
				}
			}
			el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
		}
		return null;
	},
	/**
	 * Determines whether the given namespace URI is the default namespace.
	 *
	 * The function works by looking up the prefix associated with the given namespace URI. If no
	 * prefix is found (i.e., the namespace URI is not registered in the namespace map of this
	 * node or any of its ancestors), it returns `true`, implying the namespace URI is considered
	 * the default.
	 *
	 * **This behavior is different from the in the specs**:
	 * - no node type specific handling
	 * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
	 *
	 * @param {string | null} namespaceURI
	 * The namespace URI to be checked.
	 * @returns {boolean}
	 * Returns true if the given namespace URI is the default namespace, false otherwise.
	 * @since DOM Level 3
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace
	 * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
	 * @prettierignore
	 */
	isDefaultNamespace: function (namespaceURI) {
		var prefix = this.lookupPrefix(namespaceURI);
		return prefix == null;
	},
	/**
	 * Compares the reference node with a node with regard to their position in the document and
	 * according to the document order.
	 *
	 * @param {Node} other
	 * The node to compare the reference node to.
	 * @returns {number}
	 * Returns how the node is positioned relatively to the reference node according to the
	 * bitmask. 0 if reference node and given node are the same.
	 * @since DOM Level 3
	 * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare
	 * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
	 */
	compareDocumentPosition: function (other) {
		if (this === other) return 0;
		var node1 = other;
		var node2 = this;
		var attr1 = null;
		var attr2 = null;
		if (node1 instanceof Attr$1) {
			attr1 = node1;
			node1 = attr1.ownerElement;
		}
		if (node2 instanceof Attr$1) {
			attr2 = node2;
			node2 = attr2.ownerElement;
			if (attr1 && node1 && node2 === node1) {
				for (var i = 0, attr; (attr = node2.attributes[i]); i++) {
					if (attr === attr1)
						return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
					if (attr === attr2)
						return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
				}
			}
		}
		if (!node1 || !node2 || node2.ownerDocument !== node1.ownerDocument) {
			return (
				DocumentPosition.DOCUMENT_POSITION_DISCONNECTED +
				DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC +
				(docGUID(node2.ownerDocument) > docGUID(node1.ownerDocument)
					? DocumentPosition.DOCUMENT_POSITION_FOLLOWING
					: DocumentPosition.DOCUMENT_POSITION_PRECEDING)
			);
		}
		if (attr2 && node1 === node2) {
			return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
		}
		if (attr1 && node1 === node2) {
			return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
		}

		var chain1 = [];
		var ancestor1 = node1.parentNode;
		while (ancestor1) {
			if (!attr2 && ancestor1 === node2) {
				return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
			}
			chain1.push(ancestor1);
			ancestor1 = ancestor1.parentNode;
		}
		chain1.reverse();

		var chain2 = [];
		var ancestor2 = node2.parentNode;
		while (ancestor2) {
			if (!attr1 && ancestor2 === node1) {
				return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
			}
			chain2.push(ancestor2);
			ancestor2 = ancestor2.parentNode;
		}
		chain2.reverse();

		var ca = commonAncestor(chain1, chain2);
		for (var n in ca.childNodes) {
			var child = ca.childNodes[n];
			if (child === node2) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
			if (child === node1) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;
			if (chain2.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
			if (chain1.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;
		}
		return 0;
	},
};

/**
 * Encodes special XML characters to their corresponding entities.
 *
 * @param {string} c
 * The character to be encoded.
 * @returns {string}
 * The encoded character.
 * @private
 */
function _xmlEncoder(c) {
	return (
		(c == '<' && '&lt;') || (c == '>' && '&gt;') || (c == '&' && '&amp;') || (c == '"' && '&quot;') || '&#' + c.charCodeAt() + ';'
	);
}

copy(NodeType, Node$1);
copy(NodeType, Node$1.prototype);
copy(DocumentPosition, Node$1);
copy(DocumentPosition, Node$1.prototype);

/**
 * @param callback
 * Return true for continue,false for break.
 * @returns
 * boolean true: break visit;
 */
function _visitNode(node, callback) {
	if (callback(node)) {
		return true;
	}
	if ((node = node.firstChild)) {
		do {
			if (_visitNode(node, callback)) {
				return true;
			}
		} while ((node = node.nextSibling));
	}
}

/**
 * @typedef DocumentOptions
 * @property {string} [contentType=MIME_TYPE.XML_APPLICATION]
 */
/**
 * The Document interface describes the common properties and methods for any kind of document.
 *
 * It should usually be created using `new DOMImplementation().createDocument(...)`
 * or `new DOMImplementation().createHTMLDocument(...)`.
 *
 * The constructor is considered a private API and offers to initially set the `contentType`
 * property via it's options parameter.
 *
 * @class
 * @param {Symbol} symbol
 * @param {DocumentOptions} [options]
 * @augments Node
 * @private
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document
 * @see https://dom.spec.whatwg.org/#interface-document
 */
function Document$1(symbol, options) {
	checkSymbol(symbol);

	var opt = options || {};
	this.ownerDocument = this;
	/**
	 * The mime type of the document is determined at creation time and can not be modified.
	 *
	 * @type {string}
	 * @see https://dom.spec.whatwg.org/#concept-document-content-type
	 * @see {@link DOMImplementation}
	 * @see {@link MIME_TYPE}
	 * @readonly
	 */
	this.contentType = opt.contentType || MIME_TYPE$2.XML_APPLICATION;
	/**
	 * @type {'html' | 'xml'}
	 * @see https://dom.spec.whatwg.org/#concept-document-type
	 * @see {@link DOMImplementation}
	 * @readonly
	 */
	this.type = isHTMLMimeType$3(this.contentType) ? 'html' : 'xml';
}

/**
 * Updates the namespace mapping of an element when a new attribute is added.
 *
 * @param {Document} doc
 * The document that the element belongs to.
 * @param {Element} el
 * The element to which the attribute is being added.
 * @param {Attr} newAttr
 * The new attribute being added.
 * @private
 */
function _onAddAttribute(doc, el, newAttr) {
	doc && doc._inc++;
	var ns = newAttr.namespaceURI;
	if (ns === NAMESPACE$3.XMLNS) {
		//update namespace
		el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;
	}
}

/**
 * Updates the namespace mapping of an element when an attribute is removed.
 *
 * @param {Document} doc
 * The document that the element belongs to.
 * @param {Element} el
 * The element from which the attribute is being removed.
 * @param {Attr} newAttr
 * The attribute being removed.
 * @param {boolean} remove
 * Indicates whether the attribute is to be removed.
 * @private
 */
function _onRemoveAttribute(doc, el, newAttr, remove) {
	doc && doc._inc++;
	var ns = newAttr.namespaceURI;
	if (ns === NAMESPACE$3.XMLNS) {
		//update namespace
		delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];
	}
}

/**
 * Updates `parent.childNodes`, adjusting the indexed items and its `length`.
 * If `newChild` is provided and has no nextSibling, it will be appended.
 * Otherwise, it's assumed that an item has been removed or inserted,
 * and `parent.firstNode` and its `.nextSibling` to re-indexing all child nodes of `parent`.
 *
 * @param {Document} doc
 * The parent document of `el`.
 * @param {Node} parent
 * The parent node whose childNodes list needs to be updated.
 * @param {Node} [newChild]
 * The new child node to be appended. If not provided, the function assumes a node has been
 * removed.
 * @private
 */
function _onUpdateChild(doc, parent, newChild) {
	if (doc && doc._inc) {
		doc._inc++;
		var childNodes = parent.childNodes;
		// assumes nextSibling and previousSibling were already configured upfront
		if (newChild && !newChild.nextSibling) {
			// if an item has been appended, we only need to update the last index and the length
			childNodes[childNodes.length++] = newChild;
		} else {
			// otherwise we need to reindex all items,
			// which can take a while when processing nodes with a lot of children
			var child = parent.firstChild;
			var i = 0;
			while (child) {
				childNodes[i++] = child;
				child = child.nextSibling;
			}
			childNodes.length = i;
			delete childNodes[childNodes.length];
		}
	}
}

/**
 * Removes the connections between `parentNode` and `child`
 * and any existing `child.previousSibling` or `child.nextSibling`.
 *
 * @param {Node} parentNode
 * The parent node from which the child node is to be removed.
 * @param {Node} child
 * The child node to be removed from the parentNode.
 * @returns {Node}
 * Returns the child node that was removed.
 * @throws {DOMException}
 * With code:
 * - {@link DOMException.NOT_FOUND_ERR} If the parentNode is not the parent of the child node.
 * @private
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 */
function _removeChild(parentNode, child) {
	if (parentNode !== child.parentNode) {
		throw new DOMException$2(DOMException$2.NOT_FOUND_ERR, "child's parent is not parent");
	}
	var oldPreviousSibling = child.previousSibling;
	var oldNextSibling = child.nextSibling;
	if (oldPreviousSibling) {
		oldPreviousSibling.nextSibling = oldNextSibling;
	} else {
		parentNode.firstChild = oldNextSibling;
	}
	if (oldNextSibling) {
		oldNextSibling.previousSibling = oldPreviousSibling;
	} else {
		parentNode.lastChild = oldPreviousSibling;
	}
	_onUpdateChild(parentNode.ownerDocument, parentNode);
	child.parentNode = null;
	child.previousSibling = null;
	child.nextSibling = null;
	return child;
}

/**
 * Returns `true` if `node` can be a parent for insertion.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function hasValidParentNodeType(node) {
	return (
		node &&
		(node.nodeType === Node$1.DOCUMENT_NODE || node.nodeType === Node$1.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node$1.ELEMENT_NODE)
	);
}

/**
 * Returns `true` if `node` can be inserted according to it's `nodeType`.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function hasInsertableNodeType(node) {
	return (
		node &&
		(node.nodeType === Node$1.CDATA_SECTION_NODE ||
			node.nodeType === Node$1.COMMENT_NODE ||
			node.nodeType === Node$1.DOCUMENT_FRAGMENT_NODE ||
			node.nodeType === Node$1.DOCUMENT_TYPE_NODE ||
			node.nodeType === Node$1.ELEMENT_NODE ||
			node.nodeType === Node$1.PROCESSING_INSTRUCTION_NODE ||
			node.nodeType === Node$1.TEXT_NODE)
	);
}

/**
 * Returns true if `node` is a DOCTYPE node.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function isDocTypeNode(node) {
	return node && node.nodeType === Node$1.DOCUMENT_TYPE_NODE;
}

/**
 * Returns true if the node is an element.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function isElementNode(node) {
	return node && node.nodeType === Node$1.ELEMENT_NODE;
}
/**
 * Returns true if `node` is a text node.
 *
 * @param {Node} node
 * @returns {boolean}
 */
function isTextNode(node) {
	return node && node.nodeType === Node$1.TEXT_NODE;
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Document} doc
 * The document node.
 * @param {Node} child
 * The node that would become the nextSibling if the element would be inserted.
 * @returns {boolean}
 * `true` if an element can be inserted before child.
 * @private
 */
function isElementInsertionPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];
	if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Node} doc
 * The document node.
 * @param {Node} child
 * The node that would become the nextSibling if the element would be inserted.
 * @returns {boolean}
 * `true` if an element can be inserted before child.
 * @private
 */
function isElementReplacementPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];

	function hasElementChildThatIsNotChild(node) {
		return isElementNode(node) && node !== child;
	}

	if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * Asserts pre-insertion validity of a node into a parent before a child.
 * Throws errors for invalid node combinations that would result in an ill-formed DOM.
 *
 * @param {Node} parent
 * The parent node to insert `node` into.
 * @param {Node} node
 * The node to insert.
 * @param {Node | null} child
 * The node that should become the `nextSibling` of `node`. If null, no sibling is considered.
 * @throws {DOMException}
 * With code:
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `parent` is not a Document,
 * DocumentFragment, or Element node.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a host-including inclusive
 * ancestor of `parent`. (Currently not implemented)
 * - {@link DOMException.NOT_FOUND_ERR} If `child` is non-null and its `parent` is not
 * `parent`.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is not a DocumentFragment,
 * DocumentType, Element, or CharacterData node.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If either `node` is a Text node and `parent` is
 * a document, or if `node` is a doctype and `parent` is not a document.
 * @private
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidity1to5(parent, node, child) {
	// 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
	if (!hasValidParentNodeType(parent)) {
		throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);
	}
	// 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
	// not implemented!
	// 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
	if (child && child.parentNode !== parent) {
		throw new DOMException$2(DOMException$2.NOT_FOUND_ERR, 'child not in parent');
	}
	if (
		// 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
		!hasInsertableNodeType(node) ||
		// 5. If either `node` is a Text node and `parent` is a document,
		// the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
		// || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
		// or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
		(isDocTypeNode(node) && parent.nodeType !== Node$1.DOCUMENT_NODE)
	) {
		throw new DOMException$2(
			DOMException$2.HIERARCHY_REQUEST_ERR,
			'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType
		);
	}
}

/**
 * Asserts pre-insertion validity of a node into a document before a child.
 * Throws errors for invalid node combinations that would result in an ill-formed DOM.
 *
 * @param {Document} parent
 * The parent node to insert `node` into.
 * @param {Node} node
 * The node to insert.
 * @param {Node | undefined} child
 * The node that should become the `nextSibling` of `node`. If undefined, no sibling is
 * considered.
 * @returns {Node}
 * @throws {DOMException}
 * With code:
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentFragment with more than
 * one element child or has a Text node child.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentFragment with one
 * element child and either `parent` has an element child, `child` is a doctype, or `child` is
 * non-null and a doctype is following `child`.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is an Element and `parent` has an
 * element child, `child` is a doctype, or `child` is non-null and a doctype is following
 * `child`.
 * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentType and `parent` has a
 * doctype child, `child` is non-null and an element is preceding `child`, or `child` is null
 * and `parent` has an element child.
 * @private
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node$1.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If node has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child,
		// `child` is a doctype, or `child` is non-null and a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child, `child` is a doctype,
		// or `child` is non-null and a doctype is following `child`.
		if (!isElementInsertionPossible(parent, child)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		// `parent` has a doctype child,
		if (find(parentChildNodes, isDocTypeNode)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// `child` is non-null and an element is preceding `child`,
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
		// or `child` is null and `parent` has an element child.
		if (!child && parentElementChild) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');
		}
	}
}

/**
 * @param {Document} parent
 * The parent node to insert `node` into.
 * @param {Node} node
 * The node to insert.
 * @param {Node | undefined} child
 * the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws {DOMException}
 * For several node combinations that would create a DOM that is not well-formed.
 * @throws {DOMException}
 * If `child` is provided but is not a child of `parent`.
 * @private
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreReplacementValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node$1.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If `node` has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child that is not `child` or a doctype is following `child`.
		if (!isElementReplacementPossible(parent, child)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		function hasDoctypeChildThatIsNotChild(node) {
			return isDocTypeNode(node) && node !== child;
		}

		// `parent` has a doctype child that is not `child`,
		if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// or an element is preceding `child`.
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException$2(DOMException$2.HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
	}
}

/**
 * Inserts a node into a parent node before a child node.
 *
 * @param {Node} parent
 * The parent node to insert the node into.
 * @param {Node} node
 * The node to insert into the parent.
 * @param {Node | null} child
 * The node that should become the next sibling of the node.
 * If null, the function inserts the node at the end of the children of the parent node.
 * @param {Function} [_inDocumentAssertion]
 * An optional function to check pre-insertion validity if parent is a document node.
 * Defaults to {@link assertPreInsertionValidityInDocument}
 * @returns {Node}
 * Returns the inserted node.
 * @throws {DOMException}
 * Throws a DOMException if inserting the node would result in a DOM tree that is not
 * well-formed. See {@link assertPreInsertionValidity1to5},
 * {@link assertPreInsertionValidityInDocument}.
 * @throws {DOMException}
 * Throws a DOMException if child is provided but is not a child of the parent. See
 * {@link Node.removeChild}
 * @private
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function _insertBefore(parent, node, child, _inDocumentAssertion) {
	// To ensure pre-insertion validity of a node into a parent before a child, run these steps:
	assertPreInsertionValidity1to5(parent, node, child);

	// If parent is a document, and any of the statements below, switched on the interface node implements,
	// are true, then throw a "HierarchyRequestError" DOMException.
	if (parent.nodeType === Node$1.DOCUMENT_NODE) {
		(_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
	}

	var cp = node.parentNode;
	if (cp) {
		cp.removeChild(node); //remove and update
	}
	if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
		var newFirst = node.firstChild;
		if (newFirst == null) {
			return node;
		}
		var newLast = node.lastChild;
	} else {
		newFirst = newLast = node;
	}
	var pre = child ? child.previousSibling : parent.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = child;

	if (pre) {
		pre.nextSibling = newFirst;
	} else {
		parent.firstChild = newFirst;
	}
	if (child == null) {
		parent.lastChild = newLast;
	} else {
		child.previousSibling = newLast;
	}
	do {
		newFirst.parentNode = parent;
	} while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
	_onUpdateChild(parent.ownerDocument || parent, parent, node);
	if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
		node.firstChild = node.lastChild = null;
	}

	return node;
}

Document$1.prototype = {
	/**
	 * The implementation that created this document.
	 *
	 * @type DOMImplementation
	 * @readonly
	 */
	implementation: null,
	nodeName: '#document',
	nodeType: DOCUMENT_NODE,
	/**
	 * The DocumentType node of the document.
	 *
	 * @type DocumentType
	 * @readonly
	 */
	doctype: null,
	documentElement: null,
	_inc: 1,

	insertBefore: function (newChild, refChild) {
		//raises
		if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
			var child = newChild.firstChild;
			while (child) {
				var next = child.nextSibling;
				this.insertBefore(child, refChild);
				child = next;
			}
			return newChild;
		}
		_insertBefore(this, newChild, refChild);
		newChild.ownerDocument = this;
		if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
			this.documentElement = newChild;
		}

		return newChild;
	},
	removeChild: function (oldChild) {
		var removed = _removeChild(this, oldChild);
		if (removed === this.documentElement) {
			this.documentElement = null;
		}
		return removed;
	},
	replaceChild: function (newChild, oldChild) {
		//raises
		_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
		newChild.ownerDocument = this;
		if (oldChild) {
			this.removeChild(oldChild);
		}
		if (isElementNode(newChild)) {
			this.documentElement = newChild;
		}
	},
	// Introduced in DOM Level 2:
	importNode: function (importedNode, deep) {
		return importNode(this, importedNode, deep);
	},
	// Introduced in DOM Level 2:
	getElementById: function (id) {
		var rtv = null;
		_visitNode(this.documentElement, function (node) {
			if (node.nodeType == ELEMENT_NODE) {
				if (node.getAttribute('id') == id) {
					rtv = node;
					return true;
				}
			}
		});
		return rtv;
	},

	/**
	 * Creates a new `Element` that is owned by this `Document`.
	 * In HTML Documents `localName` is the lower cased `tagName`,
	 * otherwise no transformation is being applied.
	 * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.
	 *
	 * __This implementation differs from the specification:__ - The provided name is not checked
	 * against the `Name` production,
	 * so no related error will be thrown.
	 * - There is no interface `HTMLElement`, it is always an `Element`.
	 * - There is no support for a second argument to indicate using custom elements.
	 *
	 * @param {string} tagName
	 * @returns {Element}
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
	 * @see https://dom.spec.whatwg.org/#dom-document-createelement
	 * @see https://dom.spec.whatwg.org/#concept-create-element
	 */
	createElement: function (tagName) {
		var node = new Element$1(PDC);
		node.ownerDocument = this;
		if (this.type === 'html') {
			tagName = tagName.toLowerCase();
		}
		if (hasDefaultHTMLNamespace$2(this.contentType)) {
			node.namespaceURI = NAMESPACE$3.HTML;
		}
		node.nodeName = tagName;
		node.tagName = tagName;
		node.localName = tagName;
		node.childNodes = new NodeList$1();
		var attrs = (node.attributes = new NamedNodeMap$1());
		attrs._ownerElement = node;
		return node;
	},
	/**
	 * @returns {DocumentFragment}
	 */
	createDocumentFragment: function () {
		var node = new DocumentFragment$1(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList$1();
		return node;
	},
	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	createTextNode: function (data) {
		var node = new Text$1(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList$1();
		node.appendData(data);
		return node;
	},
	/**
	 * @param {string} data
	 * @returns {Comment}
	 */
	createComment: function (data) {
		var node = new Comment$1(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList$1();
		node.appendData(data);
		return node;
	},
	/**
	 * @param {string} data
	 * @returns {CDATASection}
	 */
	createCDATASection: function (data) {
		var node = new CDATASection$1(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList$1();
		node.appendData(data);
		return node;
	},
	/**
	 * @param {string} target
	 * @param {string} data
	 * @returns {ProcessingInstruction}
	 */
	createProcessingInstruction: function (target, data) {
		var node = new ProcessingInstruction$1(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList$1();
		node.nodeName = node.target = target;
		node.nodeValue = node.data = data;
		return node;
	},
	/**
	 * Creates an `Attr` node that is owned by this document.
	 * In HTML Documents `localName` is the lower cased `name`,
	 * otherwise no transformation is being applied.
	 *
	 * __This implementation differs from the specification:__ - The provided name is not checked
	 * against the `Name` production,
	 * so no related error will be thrown.
	 *
	 * @param {string} name
	 * @returns {Attr}
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute
	 * @see https://dom.spec.whatwg.org/#dom-document-createattribute
	 */
	createAttribute: function (name) {
		if (!g$1.QName_exact.test(name)) {
			throw new DOMException$2(DOMException$2.INVALID_CHARACTER_ERR, 'invalid character in name "' + name + '"');
		}
		if (this.type === 'html') {
			name = name.toLowerCase();
		}
		return this._createAttribute(name);
	},
	_createAttribute: function (name) {
		var node = new Attr$1(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList$1();
		node.name = name;
		node.nodeName = name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	/**
	 * Creates an EntityReference object.
	 * The current implementation does not fill the `childNodes` with those of the corresponding
	 * `Entity`
	 *
	 * @deprecated
	 * In DOM Level 4.
	 * @param {string} name
	 * The name of the entity to reference. No namespace well-formedness checks are performed.
	 * @returns {EntityReference}
	 * @throws {DOMException}
	 * With code `INVALID_CHARACTER_ERR` when `name` is not valid.
	 * @throws {DOMException}
	 * with code `NOT_SUPPORTED_ERR` when the document is of type `html`
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE
	 */
	createEntityReference: function (name) {
		if (!g$1.Name.test(name)) {
			throw new DOMException$2(DOMException$2.INVALID_CHARACTER_ERR, 'not a valid xml name "' + name + '"');
		}
		if (this.type === 'html') {
			throw new DOMException$2('document is an html document', DOMExceptionName$1.NotSupportedError);
		}

		var node = new EntityReference$1(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList$1();
		node.nodeName = name;
		return node;
	},
	// Introduced in DOM Level 2:
	/**
	 * @param {string} namespaceURI
	 * @param {string} qualifiedName
	 * @returns {Element}
	 */
	createElementNS: function (namespaceURI, qualifiedName) {
		var validated = validateAndExtract(namespaceURI, qualifiedName);
		var node = new Element$1(PDC);
		var attrs = (node.attributes = new NamedNodeMap$1());
		node.childNodes = new NodeList$1();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = validated[0];
		node.prefix = validated[1];
		node.localName = validated[2];
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	/**
	 * @param {string} namespaceURI
	 * @param {string} qualifiedName
	 * @returns {Attr}
	 */
	createAttributeNS: function (namespaceURI, qualifiedName) {
		var validated = validateAndExtract(namespaceURI, qualifiedName);
		var node = new Attr$1(PDC);
		node.ownerDocument = this;
		node.childNodes = new NodeList$1();
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.specified = true;
		node.namespaceURI = validated[0];
		node.prefix = validated[1];
		node.localName = validated[2];
		return node;
	},
};
_extends(Document$1, Node$1);

function Element$1(symbol) {
	checkSymbol(symbol);

	this._nsMap = Object.create(null);
}
Element$1.prototype = {
	nodeType: ELEMENT_NODE,
	/**
	 * The attributes of this element.
	 *
	 * @type {NamedNodeMap | null}
	 */
	attributes: null,
	getQualifiedName: function () {
		return this.prefix ? this.prefix + ':' + this.localName : this.localName;
	},
	_isInHTMLDocumentAndNamespace: function () {
		return this.ownerDocument.type === 'html' && this.namespaceURI === NAMESPACE$3.HTML;
	},
	/**
	 * Implementaton of Level2 Core function hasAttributes.
	 *
	 * @returns {boolean}
	 * True if attribute list is not empty.
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs
	 */
	hasAttributes: function () {
		return !!(this.attributes && this.attributes.length);
	},
	hasAttribute: function (name) {
		return !!this.getAttributeNode(name);
	},
	/**
	 * Returns element’s first attribute whose qualified name is `name`, and `null`
	 * if there is no such attribute.
	 *
	 * @param {string} name
	 * @returns {string | null}
	 */
	getAttribute: function (name) {
		var attr = this.getAttributeNode(name);
		return attr ? attr.value : null;
	},
	getAttributeNode: function (name) {
		if (this._isInHTMLDocumentAndNamespace()) {
			name = name.toLowerCase();
		}
		return this.attributes.getNamedItem(name);
	},
	/**
	 * Sets the value of element’s first attribute whose qualified name is qualifiedName to value.
	 *
	 * @param {string} name
	 * @param {string} value
	 */
	setAttribute: function (name, value) {
		if (this._isInHTMLDocumentAndNamespace()) {
			name = name.toLowerCase();
		}
		var attr = this.getAttributeNode(name);
		if (attr) {
			attr.value = attr.nodeValue = '' + value;
		} else {
			attr = this.ownerDocument._createAttribute(name);
			attr.value = attr.nodeValue = '' + value;
			this.setAttributeNode(attr);
		}
	},
	removeAttribute: function (name) {
		var attr = this.getAttributeNode(name);
		attr && this.removeAttributeNode(attr);
	},
	setAttributeNode: function (newAttr) {
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS: function (newAttr) {
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode: function (oldAttr) {
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS: function (namespaceURI, localName) {
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},

	hasAttributeNS: function (namespaceURI, localName) {
		return this.getAttributeNodeNS(namespaceURI, localName) != null;
	},
	/**
	 * Returns element’s attribute whose namespace is `namespaceURI` and local name is
	 * `localName`,
	 * or `null` if there is no such attribute.
	 *
	 * @param {string} namespaceURI
	 * @param {string} localName
	 * @returns {string | null}
	 */
	getAttributeNS: function (namespaceURI, localName) {
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr ? attr.value : null;
	},
	/**
	 * Sets the value of element’s attribute whose namespace is `namespaceURI` and local name is
	 * `localName` to value.
	 *
	 * @param {string} namespaceURI
	 * @param {string} qualifiedName
	 * @param {string} value
	 * @see https://dom.spec.whatwg.org/#dom-element-setattributens
	 */
	setAttributeNS: function (namespaceURI, qualifiedName, value) {
		var validated = validateAndExtract(namespaceURI, qualifiedName);
		var localName = validated[2];
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		if (attr) {
			attr.value = attr.nodeValue = '' + value;
		} else {
			attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
			attr.value = attr.nodeValue = '' + value;
			this.setAttributeNode(attr);
		}
	},
	getAttributeNodeNS: function (namespaceURI, localName) {
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},

	/**
	 * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).
	 *
	 * Returns an empty list if `classNames` is an empty string or only contains HTML white space
	 * characters.
	 *
	 * Warning: This returns a live LiveNodeList.
	 * Changes in the DOM will reflect in the array as the changes occur.
	 * If an element selected by this array no longer qualifies for the selector,
	 * it will automatically be removed. Be aware of this for iteration purposes.
	 *
	 * @param {string} classNames
	 * Is a string representing the class name(s) to match; multiple class names are separated by
	 * (ASCII-)whitespace.
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
	 * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
	 */
	getElementsByClassName: function (classNames) {
		var classNamesSet = toOrderedSet(classNames);
		return new LiveNodeList$1(this, function (base) {
			var ls = [];
			if (classNamesSet.length > 0) {
				_visitNode(base, function (node) {
					if (node !== base && node.nodeType === ELEMENT_NODE) {
						var nodeClassNames = node.getAttribute('class');
						// can be null if the attribute does not exist
						if (nodeClassNames) {
							// before splitting and iterating just compare them for the most common case
							var matches = classNames === nodeClassNames;
							if (!matches) {
								var nodeClassNamesSet = toOrderedSet(nodeClassNames);
								matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
							}
							if (matches) {
								ls.push(node);
							}
						}
					}
				});
			}
			return ls;
		});
	},

	/**
	 * Returns a LiveNodeList of elements with the given qualifiedName.
	 * Searching for all descendants can be done by passing `*` as `qualifiedName`.
	 *
	 * All descendants of the specified element are searched, but not the element itself.
	 * The returned list is live, which means it updates itself with the DOM tree automatically.
	 * Therefore, there is no need to call `Element.getElementsByTagName()`
	 * with the same element and arguments repeatedly if the DOM changes in between calls.
	 *
	 * When called on an HTML element in an HTML document,
	 * `getElementsByTagName` lower-cases the argument before searching for it.
	 * This is undesirable when trying to match camel-cased SVG elements (such as
	 * `<linearGradient>`) in an HTML document.
	 * Instead, use `Element.getElementsByTagNameNS()`,
	 * which preserves the capitalization of the tag name.
	 *
	 * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,
	 * except that it only searches for elements that are descendants of the specified element.
	 *
	 * @param {string} qualifiedName
	 * @returns {LiveNodeList}
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
	 * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname
	 */
	getElementsByTagName: function (qualifiedName) {
		var isHTMLDocument = (this.nodeType === DOCUMENT_NODE ? this : this.ownerDocument).type === 'html';
		var lowerQualifiedName = qualifiedName.toLowerCase();
		return new LiveNodeList$1(this, function (base) {
			var ls = [];
			_visitNode(base, function (node) {
				if (node === base || node.nodeType !== ELEMENT_NODE) {
					return;
				}
				if (qualifiedName === '*') {
					ls.push(node);
				} else {
					var nodeQualifiedName = node.getQualifiedName();
					var matchingQName = isHTMLDocument && node.namespaceURI === NAMESPACE$3.HTML ? lowerQualifiedName : qualifiedName;
					if (nodeQualifiedName === matchingQName) {
						ls.push(node);
					}
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS: function (namespaceURI, localName) {
		return new LiveNodeList$1(this, function (base) {
			var ls = [];
			_visitNode(base, function (node) {
				if (
					node !== base &&
					node.nodeType === ELEMENT_NODE &&
					(namespaceURI === '*' || node.namespaceURI === namespaceURI) &&
					(localName === '*' || node.localName == localName)
				) {
					ls.push(node);
				}
			});
			return ls;
		});
	},
};
Document$1.prototype.getElementsByClassName = Element$1.prototype.getElementsByClassName;
Document$1.prototype.getElementsByTagName = Element$1.prototype.getElementsByTagName;
Document$1.prototype.getElementsByTagNameNS = Element$1.prototype.getElementsByTagNameNS;

_extends(Element$1, Node$1);
function Attr$1(symbol) {
	checkSymbol(symbol);

	this.namespaceURI = null;
	this.prefix = null;
	this.ownerElement = null;
}
Attr$1.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr$1, Node$1);

function CharacterData$1(symbol) {
	checkSymbol(symbol);
}
CharacterData$1.prototype = {
	data: '',
	substringData: function (offset, count) {
		return this.data.substring(offset, offset + count);
	},
	appendData: function (text) {
		text = this.data + text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function (offset, text) {
		this.replaceData(offset, 0, text);
	},
	deleteData: function (offset, count) {
		this.replaceData(offset, count, '');
	},
	replaceData: function (offset, count, text) {
		var start = this.data.substring(0, offset);
		var end = this.data.substring(offset + count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
};
_extends(CharacterData$1, Node$1);
function Text$1(symbol) {
	checkSymbol(symbol);
}
Text$1.prototype = {
	nodeName: '#text',
	nodeType: TEXT_NODE,
	splitText: function (offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if (this.parentNode) {
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	},
};
_extends(Text$1, CharacterData$1);
function Comment$1(symbol) {
	checkSymbol(symbol);
}
Comment$1.prototype = {
	nodeName: '#comment',
	nodeType: COMMENT_NODE,
};
_extends(Comment$1, CharacterData$1);

function CDATASection$1(symbol) {
	checkSymbol(symbol);
}
CDATASection$1.prototype = {
	nodeName: '#cdata-section',
	nodeType: CDATA_SECTION_NODE,
};
_extends(CDATASection$1, Text$1);

function DocumentType$1(symbol) {
	checkSymbol(symbol);
}
DocumentType$1.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType$1, Node$1);

function Notation$1(symbol) {
	checkSymbol(symbol);
}
Notation$1.prototype.nodeType = NOTATION_NODE;
_extends(Notation$1, Node$1);

function Entity$1(symbol) {
	checkSymbol(symbol);
}
Entity$1.prototype.nodeType = ENTITY_NODE;
_extends(Entity$1, Node$1);

function EntityReference$1(symbol) {
	checkSymbol(symbol);
}
EntityReference$1.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference$1, Node$1);

function DocumentFragment$1(symbol) {
	checkSymbol(symbol);
}
DocumentFragment$1.prototype.nodeName = '#document-fragment';
DocumentFragment$1.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment$1, Node$1);

function ProcessingInstruction$1(symbol) {
	checkSymbol(symbol);
}
ProcessingInstruction$1.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction$1, CharacterData$1);
function XMLSerializer$1() {}
XMLSerializer$1.prototype.serializeToString = function (node, nodeFilter) {
	return nodeSerializeToString.call(node, nodeFilter);
};
Node$1.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(nodeFilter) {
	var buf = [];
	var refNode = (this.nodeType === DOCUMENT_NODE && this.documentElement) || this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;

	if (uri && prefix == null) {
		var prefix = refNode.lookupPrefix(uri);
		if (prefix == null) {
			var visibleNamespaces = [
				{ namespace: uri, prefix: null },
				//{namespace:uri,prefix:''}
			];
		}
	}
	serializeToString(this, buf, nodeFilter, visibleNamespaces);
	return buf.join('');
}

function needNamespaceDefine(node, isHTML, visibleNamespaces) {
	var prefix = node.prefix || '';
	var uri = node.namespaceURI;
	// According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
	// and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
	// > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
	// in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
	// and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
	// > [...] Furthermore, the attribute value [...] must not be an empty string.
	// so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
	if (!uri) {
		return false;
	}
	if ((prefix === 'xml' && uri === NAMESPACE$3.XML) || uri === NAMESPACE$3.XMLNS) {
		return false;
	}

	var i = visibleNamespaces.length;
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		if (ns.prefix === prefix) {
			return ns.namespace !== uri;
		}
	}
	return true;
}
/**
 * Literal whitespace other than space that appear in attribute values are serialized as
 * their entity references, so they will be preserved.
 * (In contrast to whitespace literals in the input which are normalized to spaces).
 *
 * Well-formed constraint: No < in Attribute Values:
 * > The replacement text of any entity referred to directly or indirectly
 * > in an attribute value must not contain a <.
 *
 * @see https://www.w3.org/TR/xml11/#CleanAttrVals
 * @see https://www.w3.org/TR/xml11/#NT-AttValue
 * @see https://www.w3.org/TR/xml11/#AVNormalize
 * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
 * @prettierignore
 */
function addSerializedAttribute(buf, qualifiedName, value) {
	buf.push(' ', qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
}

function serializeToString(node, buf, nodeFilter, visibleNamespaces) {
	if (!visibleNamespaces) {
		visibleNamespaces = [];
	}
	var doc = node.nodeType === DOCUMENT_NODE ? node : node.ownerDocument;
	var isHTML = doc.type === 'html';

	if (nodeFilter) {
		node = nodeFilter(node);
		if (node) {
			if (typeof node == 'string') {
				buf.push(node);
				return;
			}
		} else {
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}

	switch (node.nodeType) {
		case ELEMENT_NODE:
			var attrs = node.attributes;
			var len = attrs.length;
			var child = node.firstChild;
			var nodeName = node.tagName;

			var prefixedNodeName = nodeName;
			if (!isHTML && !node.prefix && node.namespaceURI) {
				var defaultNS;
				// lookup current default ns from `xmlns` attribute
				for (var ai = 0; ai < attrs.length; ai++) {
					if (attrs.item(ai).name === 'xmlns') {
						defaultNS = attrs.item(ai).value;
						break;
					}
				}
				if (!defaultNS) {
					// lookup current default ns in visibleNamespaces
					for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
						var namespace = visibleNamespaces[nsi];
						if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
							defaultNS = namespace.namespace;
							break;
						}
					}
				}
				if (defaultNS !== node.namespaceURI) {
					for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
						var namespace = visibleNamespaces[nsi];
						if (namespace.namespace === node.namespaceURI) {
							if (namespace.prefix) {
								prefixedNodeName = namespace.prefix + ':' + nodeName;
							}
							break;
						}
					}
				}
			}

			buf.push('<', prefixedNodeName);

			for (var i = 0; i < len; i++) {
				// add namespaces for attributes
				var attr = attrs.item(i);
				if (attr.prefix == 'xmlns') {
					visibleNamespaces.push({
						prefix: attr.localName,
						namespace: attr.value,
					});
				} else if (attr.nodeName == 'xmlns') {
					visibleNamespaces.push({ prefix: '', namespace: attr.value });
				}
			}

			for (var i = 0; i < len; i++) {
				var attr = attrs.item(i);
				if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
					var prefix = attr.prefix || '';
					var uri = attr.namespaceURI;
					addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : 'xmlns', uri);
					visibleNamespaces.push({ prefix: prefix, namespace: uri });
				}
				serializeToString(attr, buf, nodeFilter, visibleNamespaces);
			}

			// add namespace for current node
			if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
				var prefix = node.prefix || '';
				var uri = node.namespaceURI;
				addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : 'xmlns', uri);
				visibleNamespaces.push({ prefix: prefix, namespace: uri });
			}
			// in XML elements can be closed when they have no children
			var canCloseTag = !child;
			if (canCloseTag && (isHTML || node.namespaceURI === NAMESPACE$3.HTML)) {
				// in HTML (doc or ns) only void elements can be closed right away
				canCloseTag = isHTMLVoidElement(nodeName);
			}
			if (canCloseTag) {
				buf.push('/>');
			} else {
				buf.push('>');
				//if is cdata child node
				if (isHTML && isHTMLRawTextElement$1(nodeName)) {
					while (child) {
						if (child.data) {
							buf.push(child.data);
						} else {
							serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
						}
						child = child.nextSibling;
					}
				} else {
					while (child) {
						serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
						child = child.nextSibling;
					}
				}
				buf.push('</', prefixedNodeName, '>');
			}
			// remove added visible namespaces
			//visibleNamespaces.length = startVisibleNamespaces;
			return;
		case DOCUMENT_NODE:
		case DOCUMENT_FRAGMENT_NODE:
			var child = node.firstChild;
			while (child) {
				serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
				child = child.nextSibling;
			}
			return;
		case ATTRIBUTE_NODE:
			return addSerializedAttribute(buf, node.name, node.value);
		case TEXT_NODE:
			/*
			 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
			 * except when used as markup delimiters, or within a comment, a processing instruction,
			 * or a CDATA section.
			 * If they are needed elsewhere, they must be escaped using either numeric character
			 * references or the strings `&amp;` and `&lt;` respectively.
			 * The right angle bracket (>) may be represented using the string " &gt; ",
			 * and must, for compatibility, be escaped using either `&gt;`,
			 * or a character reference when it appears in the string `]]>` in content,
			 * when that string is not marking the end of a CDATA section.
			 *
			 * In the content of elements, character data is any string of characters which does not
			 * contain the start-delimiter of any markup and does not include the CDATA-section-close
			 * delimiter, `]]>`.
			 *
			 * @see https://www.w3.org/TR/xml/#NT-CharData
			 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
			 */
			return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
		case CDATA_SECTION_NODE:
			return buf.push(g$1.CDATA_START, node.data, g$1.CDATA_END);
		case COMMENT_NODE:
			return buf.push(g$1.COMMENT_START, node.data, g$1.COMMENT_END);
		case DOCUMENT_TYPE_NODE:
			var pubid = node.publicId;
			var sysid = node.systemId;
			buf.push(g$1.DOCTYPE_DECL_START, ' ', node.name);
			if (pubid) {
				buf.push(' ', g$1.PUBLIC, ' ', pubid);
				if (sysid && sysid !== '.') {
					buf.push(' ', sysid);
				}
			} else if (sysid && sysid !== '.') {
				buf.push(' ', g$1.SYSTEM, ' ', sysid);
			}
			if (node.internalSubset) {
				buf.push(' [', node.internalSubset, ']');
			}
			buf.push('>');
			return;
		case PROCESSING_INSTRUCTION_NODE:
			return buf.push('<?', node.target, ' ', node.data, '?>');
		case ENTITY_REFERENCE_NODE:
			return buf.push('&', node.nodeName, ';');
		//case ENTITY_NODE:
		//case NOTATION_NODE:
		default:
			buf.push('??', node.nodeName);
	}
}
function importNode(doc, node, deep) {
	var node2;
	switch (node.nodeType) {
		case ELEMENT_NODE:
			node2 = node.cloneNode(false);
			node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
		//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
		case DOCUMENT_FRAGMENT_NODE:
			break;
		case ATTRIBUTE_NODE:
			deep = true;
			break;
		//case ENTITY_REFERENCE_NODE:
		//case PROCESSING_INSTRUCTION_NODE:
		////case TEXT_NODE:
		//case CDATA_SECTION_NODE:
		//case COMMENT_NODE:
		//	deep = false;
		//	break;
		//case DOCUMENT_NODE:
		//case DOCUMENT_TYPE_NODE:
		//cannot be imported.
		//case ENTITY_NODE:
		//case NOTATION_NODE：
		//can not hit in level3
		//default:throw e;
	}
	if (!node2) {
		node2 = node.cloneNode(false); //false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if (deep) {
		var child = node.firstChild;
		while (child) {
			node2.appendChild(importNode(doc, child, deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

/**
 * Creates a copy of a node from an existing one.
 *
 * @param {Document} doc
 * The Document object representing the document that the new node will belong to.
 * @param {Node} node
 * The node to clone.
 * @param {boolean} deep
 * If true, the contents of the node are recursively copied.
 * If false, only the node itself (and its attributes, if it is an element) are copied.
 * @returns {Node}
 * Returns the newly created copy of the node.
 * @throws {DOMException}
 * May throw a DOMException if operations within setAttributeNode or appendChild (which are
 * potentially invoked in this function) do not meet their specific constraints.
 */
function cloneNode(doc, node, deep) {
	var node2 = new node.constructor(PDC);
	for (var n in node) {
		if (hasOwn$1(node, n)) {
			var v = node[n];
			if (typeof v != 'object') {
				if (v != node2[n]) {
					node2[n] = v;
				}
			}
		}
	}
	if (node.childNodes) {
		node2.childNodes = new NodeList$1();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
		case ELEMENT_NODE:
			var attrs = node.attributes;
			var attrs2 = (node2.attributes = new NamedNodeMap$1());
			var len = attrs.length;
			attrs2._ownerElement = node2;
			for (var i = 0; i < len; i++) {
				node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
			}
			break;
		case ATTRIBUTE_NODE:
			deep = true;
	}
	if (deep) {
		var child = node.firstChild;
		while (child) {
			node2.appendChild(cloneNode(doc, child, deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object, key, value) {
	object[key] = value;
}
//do dynamic
try {
	if (Object.defineProperty) {
		Object.defineProperty(LiveNodeList$1.prototype, 'length', {
			get: function () {
				_updateLiveList(this);
				return this.$$length;
			},
		});

		Object.defineProperty(Node$1.prototype, 'textContent', {
			get: function () {
				return getTextContent(this);
			},

			set: function (data) {
				switch (this.nodeType) {
					case ELEMENT_NODE:
					case DOCUMENT_FRAGMENT_NODE:
						while (this.firstChild) {
							this.removeChild(this.firstChild);
						}
						if (data || String(data)) {
							this.appendChild(this.ownerDocument.createTextNode(data));
						}
						break;

					default:
						this.data = data;
						this.value = data;
						this.nodeValue = data;
				}
			},
		});

		function getTextContent(node) {
			switch (node.nodeType) {
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					var buf = [];
					node = node.firstChild;
					while (node) {
						if (node.nodeType !== 7 && node.nodeType !== 8) {
							buf.push(getTextContent(node));
						}
						node = node.nextSibling;
					}
					return buf.join('');
				default:
					return node.nodeValue;
			}
		}

		__set__ = function (object, key, value) {
			//console.log(value)
			object['$$' + key] = value;
		};
	}
} catch (e) {
	//ie8
}

var _updateLiveList_1 = dom$2._updateLiveList = _updateLiveList;
var Attr_1 = dom$2.Attr = Attr$1;
var CDATASection_1 = dom$2.CDATASection = CDATASection$1;
var CharacterData_1 = dom$2.CharacterData = CharacterData$1;
var Comment_1 = dom$2.Comment = Comment$1;
var Document_1 = dom$2.Document = Document$1;
var DocumentFragment_1 = dom$2.DocumentFragment = DocumentFragment$1;
var DocumentType_1 = dom$2.DocumentType = DocumentType$1;
var DOMImplementation_1 = dom$2.DOMImplementation = DOMImplementation$2;
var Element_1 = dom$2.Element = Element$1;
var Entity_1 = dom$2.Entity = Entity$1;
var EntityReference_1 = dom$2.EntityReference = EntityReference$1;
var LiveNodeList_1 = dom$2.LiveNodeList = LiveNodeList$1;
var NamedNodeMap_1 = dom$2.NamedNodeMap = NamedNodeMap$1;
var Node_1 = dom$2.Node = Node$1;
var NodeList_1 = dom$2.NodeList = NodeList$1;
var Notation_1 = dom$2.Notation = Notation$1;
var Text_1 = dom$2.Text = Text$1;
var ProcessingInstruction_1 = dom$2.ProcessingInstruction = ProcessingInstruction$1;
var XMLSerializer_1 = dom$2.XMLSerializer = XMLSerializer$1;

var domParser$1 = {};

var entities$2 = {};

(function (exports) {
	'use strict';

	var freeze = conventions$5.freeze;

	/**
	 * The entities that are predefined in every XML document.
	 *
	 * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
	 * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
	 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML
	 *      Wikipedia
	 */
	exports.XML_ENTITIES = freeze({
		amp: '&',
		apos: "'",
		gt: '>',
		lt: '<',
		quot: '"',
	});

	/**
	 * A map of all entities that are detected in an HTML document.
	 * They contain all entries from `XML_ENTITIES`.
	 *
	 * @see {@link XML_ENTITIES}
	 * @see {@link DOMParser.parseFromString}
	 * @see {@link DOMImplementation.prototype.createHTMLDocument}
	 * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5)
	 *      Spec
	 * @see https://html.spec.whatwg.org/entities.json JSON
	 * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
	 * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
	 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML
	 *      Wikipedia (HTML)
	 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML
	 *      Wikpedia (XHTML)
	 */
	exports.HTML_ENTITIES = freeze({
		Aacute: '\u00C1',
		aacute: '\u00E1',
		Abreve: '\u0102',
		abreve: '\u0103',
		ac: '\u223E',
		acd: '\u223F',
		acE: '\u223E\u0333',
		Acirc: '\u00C2',
		acirc: '\u00E2',
		acute: '\u00B4',
		Acy: '\u0410',
		acy: '\u0430',
		AElig: '\u00C6',
		aelig: '\u00E6',
		af: '\u2061',
		Afr: '\uD835\uDD04',
		afr: '\uD835\uDD1E',
		Agrave: '\u00C0',
		agrave: '\u00E0',
		alefsym: '\u2135',
		aleph: '\u2135',
		Alpha: '\u0391',
		alpha: '\u03B1',
		Amacr: '\u0100',
		amacr: '\u0101',
		amalg: '\u2A3F',
		AMP: '\u0026',
		amp: '\u0026',
		And: '\u2A53',
		and: '\u2227',
		andand: '\u2A55',
		andd: '\u2A5C',
		andslope: '\u2A58',
		andv: '\u2A5A',
		ang: '\u2220',
		ange: '\u29A4',
		angle: '\u2220',
		angmsd: '\u2221',
		angmsdaa: '\u29A8',
		angmsdab: '\u29A9',
		angmsdac: '\u29AA',
		angmsdad: '\u29AB',
		angmsdae: '\u29AC',
		angmsdaf: '\u29AD',
		angmsdag: '\u29AE',
		angmsdah: '\u29AF',
		angrt: '\u221F',
		angrtvb: '\u22BE',
		angrtvbd: '\u299D',
		angsph: '\u2222',
		angst: '\u00C5',
		angzarr: '\u237C',
		Aogon: '\u0104',
		aogon: '\u0105',
		Aopf: '\uD835\uDD38',
		aopf: '\uD835\uDD52',
		ap: '\u2248',
		apacir: '\u2A6F',
		apE: '\u2A70',
		ape: '\u224A',
		apid: '\u224B',
		apos: '\u0027',
		ApplyFunction: '\u2061',
		approx: '\u2248',
		approxeq: '\u224A',
		Aring: '\u00C5',
		aring: '\u00E5',
		Ascr: '\uD835\uDC9C',
		ascr: '\uD835\uDCB6',
		Assign: '\u2254',
		ast: '\u002A',
		asymp: '\u2248',
		asympeq: '\u224D',
		Atilde: '\u00C3',
		atilde: '\u00E3',
		Auml: '\u00C4',
		auml: '\u00E4',
		awconint: '\u2233',
		awint: '\u2A11',
		backcong: '\u224C',
		backepsilon: '\u03F6',
		backprime: '\u2035',
		backsim: '\u223D',
		backsimeq: '\u22CD',
		Backslash: '\u2216',
		Barv: '\u2AE7',
		barvee: '\u22BD',
		Barwed: '\u2306',
		barwed: '\u2305',
		barwedge: '\u2305',
		bbrk: '\u23B5',
		bbrktbrk: '\u23B6',
		bcong: '\u224C',
		Bcy: '\u0411',
		bcy: '\u0431',
		bdquo: '\u201E',
		becaus: '\u2235',
		Because: '\u2235',
		because: '\u2235',
		bemptyv: '\u29B0',
		bepsi: '\u03F6',
		bernou: '\u212C',
		Bernoullis: '\u212C',
		Beta: '\u0392',
		beta: '\u03B2',
		beth: '\u2136',
		between: '\u226C',
		Bfr: '\uD835\uDD05',
		bfr: '\uD835\uDD1F',
		bigcap: '\u22C2',
		bigcirc: '\u25EF',
		bigcup: '\u22C3',
		bigodot: '\u2A00',
		bigoplus: '\u2A01',
		bigotimes: '\u2A02',
		bigsqcup: '\u2A06',
		bigstar: '\u2605',
		bigtriangledown: '\u25BD',
		bigtriangleup: '\u25B3',
		biguplus: '\u2A04',
		bigvee: '\u22C1',
		bigwedge: '\u22C0',
		bkarow: '\u290D',
		blacklozenge: '\u29EB',
		blacksquare: '\u25AA',
		blacktriangle: '\u25B4',
		blacktriangledown: '\u25BE',
		blacktriangleleft: '\u25C2',
		blacktriangleright: '\u25B8',
		blank: '\u2423',
		blk12: '\u2592',
		blk14: '\u2591',
		blk34: '\u2593',
		block: '\u2588',
		bne: '\u003D\u20E5',
		bnequiv: '\u2261\u20E5',
		bNot: '\u2AED',
		bnot: '\u2310',
		Bopf: '\uD835\uDD39',
		bopf: '\uD835\uDD53',
		bot: '\u22A5',
		bottom: '\u22A5',
		bowtie: '\u22C8',
		boxbox: '\u29C9',
		boxDL: '\u2557',
		boxDl: '\u2556',
		boxdL: '\u2555',
		boxdl: '\u2510',
		boxDR: '\u2554',
		boxDr: '\u2553',
		boxdR: '\u2552',
		boxdr: '\u250C',
		boxH: '\u2550',
		boxh: '\u2500',
		boxHD: '\u2566',
		boxHd: '\u2564',
		boxhD: '\u2565',
		boxhd: '\u252C',
		boxHU: '\u2569',
		boxHu: '\u2567',
		boxhU: '\u2568',
		boxhu: '\u2534',
		boxminus: '\u229F',
		boxplus: '\u229E',
		boxtimes: '\u22A0',
		boxUL: '\u255D',
		boxUl: '\u255C',
		boxuL: '\u255B',
		boxul: '\u2518',
		boxUR: '\u255A',
		boxUr: '\u2559',
		boxuR: '\u2558',
		boxur: '\u2514',
		boxV: '\u2551',
		boxv: '\u2502',
		boxVH: '\u256C',
		boxVh: '\u256B',
		boxvH: '\u256A',
		boxvh: '\u253C',
		boxVL: '\u2563',
		boxVl: '\u2562',
		boxvL: '\u2561',
		boxvl: '\u2524',
		boxVR: '\u2560',
		boxVr: '\u255F',
		boxvR: '\u255E',
		boxvr: '\u251C',
		bprime: '\u2035',
		Breve: '\u02D8',
		breve: '\u02D8',
		brvbar: '\u00A6',
		Bscr: '\u212C',
		bscr: '\uD835\uDCB7',
		bsemi: '\u204F',
		bsim: '\u223D',
		bsime: '\u22CD',
		bsol: '\u005C',
		bsolb: '\u29C5',
		bsolhsub: '\u27C8',
		bull: '\u2022',
		bullet: '\u2022',
		bump: '\u224E',
		bumpE: '\u2AAE',
		bumpe: '\u224F',
		Bumpeq: '\u224E',
		bumpeq: '\u224F',
		Cacute: '\u0106',
		cacute: '\u0107',
		Cap: '\u22D2',
		cap: '\u2229',
		capand: '\u2A44',
		capbrcup: '\u2A49',
		capcap: '\u2A4B',
		capcup: '\u2A47',
		capdot: '\u2A40',
		CapitalDifferentialD: '\u2145',
		caps: '\u2229\uFE00',
		caret: '\u2041',
		caron: '\u02C7',
		Cayleys: '\u212D',
		ccaps: '\u2A4D',
		Ccaron: '\u010C',
		ccaron: '\u010D',
		Ccedil: '\u00C7',
		ccedil: '\u00E7',
		Ccirc: '\u0108',
		ccirc: '\u0109',
		Cconint: '\u2230',
		ccups: '\u2A4C',
		ccupssm: '\u2A50',
		Cdot: '\u010A',
		cdot: '\u010B',
		cedil: '\u00B8',
		Cedilla: '\u00B8',
		cemptyv: '\u29B2',
		cent: '\u00A2',
		CenterDot: '\u00B7',
		centerdot: '\u00B7',
		Cfr: '\u212D',
		cfr: '\uD835\uDD20',
		CHcy: '\u0427',
		chcy: '\u0447',
		check: '\u2713',
		checkmark: '\u2713',
		Chi: '\u03A7',
		chi: '\u03C7',
		cir: '\u25CB',
		circ: '\u02C6',
		circeq: '\u2257',
		circlearrowleft: '\u21BA',
		circlearrowright: '\u21BB',
		circledast: '\u229B',
		circledcirc: '\u229A',
		circleddash: '\u229D',
		CircleDot: '\u2299',
		circledR: '\u00AE',
		circledS: '\u24C8',
		CircleMinus: '\u2296',
		CirclePlus: '\u2295',
		CircleTimes: '\u2297',
		cirE: '\u29C3',
		cire: '\u2257',
		cirfnint: '\u2A10',
		cirmid: '\u2AEF',
		cirscir: '\u29C2',
		ClockwiseContourIntegral: '\u2232',
		CloseCurlyDoubleQuote: '\u201D',
		CloseCurlyQuote: '\u2019',
		clubs: '\u2663',
		clubsuit: '\u2663',
		Colon: '\u2237',
		colon: '\u003A',
		Colone: '\u2A74',
		colone: '\u2254',
		coloneq: '\u2254',
		comma: '\u002C',
		commat: '\u0040',
		comp: '\u2201',
		compfn: '\u2218',
		complement: '\u2201',
		complexes: '\u2102',
		cong: '\u2245',
		congdot: '\u2A6D',
		Congruent: '\u2261',
		Conint: '\u222F',
		conint: '\u222E',
		ContourIntegral: '\u222E',
		Copf: '\u2102',
		copf: '\uD835\uDD54',
		coprod: '\u2210',
		Coproduct: '\u2210',
		COPY: '\u00A9',
		copy: '\u00A9',
		copysr: '\u2117',
		CounterClockwiseContourIntegral: '\u2233',
		crarr: '\u21B5',
		Cross: '\u2A2F',
		cross: '\u2717',
		Cscr: '\uD835\uDC9E',
		cscr: '\uD835\uDCB8',
		csub: '\u2ACF',
		csube: '\u2AD1',
		csup: '\u2AD0',
		csupe: '\u2AD2',
		ctdot: '\u22EF',
		cudarrl: '\u2938',
		cudarrr: '\u2935',
		cuepr: '\u22DE',
		cuesc: '\u22DF',
		cularr: '\u21B6',
		cularrp: '\u293D',
		Cup: '\u22D3',
		cup: '\u222A',
		cupbrcap: '\u2A48',
		CupCap: '\u224D',
		cupcap: '\u2A46',
		cupcup: '\u2A4A',
		cupdot: '\u228D',
		cupor: '\u2A45',
		cups: '\u222A\uFE00',
		curarr: '\u21B7',
		curarrm: '\u293C',
		curlyeqprec: '\u22DE',
		curlyeqsucc: '\u22DF',
		curlyvee: '\u22CE',
		curlywedge: '\u22CF',
		curren: '\u00A4',
		curvearrowleft: '\u21B6',
		curvearrowright: '\u21B7',
		cuvee: '\u22CE',
		cuwed: '\u22CF',
		cwconint: '\u2232',
		cwint: '\u2231',
		cylcty: '\u232D',
		Dagger: '\u2021',
		dagger: '\u2020',
		daleth: '\u2138',
		Darr: '\u21A1',
		dArr: '\u21D3',
		darr: '\u2193',
		dash: '\u2010',
		Dashv: '\u2AE4',
		dashv: '\u22A3',
		dbkarow: '\u290F',
		dblac: '\u02DD',
		Dcaron: '\u010E',
		dcaron: '\u010F',
		Dcy: '\u0414',
		dcy: '\u0434',
		DD: '\u2145',
		dd: '\u2146',
		ddagger: '\u2021',
		ddarr: '\u21CA',
		DDotrahd: '\u2911',
		ddotseq: '\u2A77',
		deg: '\u00B0',
		Del: '\u2207',
		Delta: '\u0394',
		delta: '\u03B4',
		demptyv: '\u29B1',
		dfisht: '\u297F',
		Dfr: '\uD835\uDD07',
		dfr: '\uD835\uDD21',
		dHar: '\u2965',
		dharl: '\u21C3',
		dharr: '\u21C2',
		DiacriticalAcute: '\u00B4',
		DiacriticalDot: '\u02D9',
		DiacriticalDoubleAcute: '\u02DD',
		DiacriticalGrave: '\u0060',
		DiacriticalTilde: '\u02DC',
		diam: '\u22C4',
		Diamond: '\u22C4',
		diamond: '\u22C4',
		diamondsuit: '\u2666',
		diams: '\u2666',
		die: '\u00A8',
		DifferentialD: '\u2146',
		digamma: '\u03DD',
		disin: '\u22F2',
		div: '\u00F7',
		divide: '\u00F7',
		divideontimes: '\u22C7',
		divonx: '\u22C7',
		DJcy: '\u0402',
		djcy: '\u0452',
		dlcorn: '\u231E',
		dlcrop: '\u230D',
		dollar: '\u0024',
		Dopf: '\uD835\uDD3B',
		dopf: '\uD835\uDD55',
		Dot: '\u00A8',
		dot: '\u02D9',
		DotDot: '\u20DC',
		doteq: '\u2250',
		doteqdot: '\u2251',
		DotEqual: '\u2250',
		dotminus: '\u2238',
		dotplus: '\u2214',
		dotsquare: '\u22A1',
		doublebarwedge: '\u2306',
		DoubleContourIntegral: '\u222F',
		DoubleDot: '\u00A8',
		DoubleDownArrow: '\u21D3',
		DoubleLeftArrow: '\u21D0',
		DoubleLeftRightArrow: '\u21D4',
		DoubleLeftTee: '\u2AE4',
		DoubleLongLeftArrow: '\u27F8',
		DoubleLongLeftRightArrow: '\u27FA',
		DoubleLongRightArrow: '\u27F9',
		DoubleRightArrow: '\u21D2',
		DoubleRightTee: '\u22A8',
		DoubleUpArrow: '\u21D1',
		DoubleUpDownArrow: '\u21D5',
		DoubleVerticalBar: '\u2225',
		DownArrow: '\u2193',
		Downarrow: '\u21D3',
		downarrow: '\u2193',
		DownArrowBar: '\u2913',
		DownArrowUpArrow: '\u21F5',
		DownBreve: '\u0311',
		downdownarrows: '\u21CA',
		downharpoonleft: '\u21C3',
		downharpoonright: '\u21C2',
		DownLeftRightVector: '\u2950',
		DownLeftTeeVector: '\u295E',
		DownLeftVector: '\u21BD',
		DownLeftVectorBar: '\u2956',
		DownRightTeeVector: '\u295F',
		DownRightVector: '\u21C1',
		DownRightVectorBar: '\u2957',
		DownTee: '\u22A4',
		DownTeeArrow: '\u21A7',
		drbkarow: '\u2910',
		drcorn: '\u231F',
		drcrop: '\u230C',
		Dscr: '\uD835\uDC9F',
		dscr: '\uD835\uDCB9',
		DScy: '\u0405',
		dscy: '\u0455',
		dsol: '\u29F6',
		Dstrok: '\u0110',
		dstrok: '\u0111',
		dtdot: '\u22F1',
		dtri: '\u25BF',
		dtrif: '\u25BE',
		duarr: '\u21F5',
		duhar: '\u296F',
		dwangle: '\u29A6',
		DZcy: '\u040F',
		dzcy: '\u045F',
		dzigrarr: '\u27FF',
		Eacute: '\u00C9',
		eacute: '\u00E9',
		easter: '\u2A6E',
		Ecaron: '\u011A',
		ecaron: '\u011B',
		ecir: '\u2256',
		Ecirc: '\u00CA',
		ecirc: '\u00EA',
		ecolon: '\u2255',
		Ecy: '\u042D',
		ecy: '\u044D',
		eDDot: '\u2A77',
		Edot: '\u0116',
		eDot: '\u2251',
		edot: '\u0117',
		ee: '\u2147',
		efDot: '\u2252',
		Efr: '\uD835\uDD08',
		efr: '\uD835\uDD22',
		eg: '\u2A9A',
		Egrave: '\u00C8',
		egrave: '\u00E8',
		egs: '\u2A96',
		egsdot: '\u2A98',
		el: '\u2A99',
		Element: '\u2208',
		elinters: '\u23E7',
		ell: '\u2113',
		els: '\u2A95',
		elsdot: '\u2A97',
		Emacr: '\u0112',
		emacr: '\u0113',
		empty: '\u2205',
		emptyset: '\u2205',
		EmptySmallSquare: '\u25FB',
		emptyv: '\u2205',
		EmptyVerySmallSquare: '\u25AB',
		emsp: '\u2003',
		emsp13: '\u2004',
		emsp14: '\u2005',
		ENG: '\u014A',
		eng: '\u014B',
		ensp: '\u2002',
		Eogon: '\u0118',
		eogon: '\u0119',
		Eopf: '\uD835\uDD3C',
		eopf: '\uD835\uDD56',
		epar: '\u22D5',
		eparsl: '\u29E3',
		eplus: '\u2A71',
		epsi: '\u03B5',
		Epsilon: '\u0395',
		epsilon: '\u03B5',
		epsiv: '\u03F5',
		eqcirc: '\u2256',
		eqcolon: '\u2255',
		eqsim: '\u2242',
		eqslantgtr: '\u2A96',
		eqslantless: '\u2A95',
		Equal: '\u2A75',
		equals: '\u003D',
		EqualTilde: '\u2242',
		equest: '\u225F',
		Equilibrium: '\u21CC',
		equiv: '\u2261',
		equivDD: '\u2A78',
		eqvparsl: '\u29E5',
		erarr: '\u2971',
		erDot: '\u2253',
		Escr: '\u2130',
		escr: '\u212F',
		esdot: '\u2250',
		Esim: '\u2A73',
		esim: '\u2242',
		Eta: '\u0397',
		eta: '\u03B7',
		ETH: '\u00D0',
		eth: '\u00F0',
		Euml: '\u00CB',
		euml: '\u00EB',
		euro: '\u20AC',
		excl: '\u0021',
		exist: '\u2203',
		Exists: '\u2203',
		expectation: '\u2130',
		ExponentialE: '\u2147',
		exponentiale: '\u2147',
		fallingdotseq: '\u2252',
		Fcy: '\u0424',
		fcy: '\u0444',
		female: '\u2640',
		ffilig: '\uFB03',
		fflig: '\uFB00',
		ffllig: '\uFB04',
		Ffr: '\uD835\uDD09',
		ffr: '\uD835\uDD23',
		filig: '\uFB01',
		FilledSmallSquare: '\u25FC',
		FilledVerySmallSquare: '\u25AA',
		fjlig: '\u0066\u006A',
		flat: '\u266D',
		fllig: '\uFB02',
		fltns: '\u25B1',
		fnof: '\u0192',
		Fopf: '\uD835\uDD3D',
		fopf: '\uD835\uDD57',
		ForAll: '\u2200',
		forall: '\u2200',
		fork: '\u22D4',
		forkv: '\u2AD9',
		Fouriertrf: '\u2131',
		fpartint: '\u2A0D',
		frac12: '\u00BD',
		frac13: '\u2153',
		frac14: '\u00BC',
		frac15: '\u2155',
		frac16: '\u2159',
		frac18: '\u215B',
		frac23: '\u2154',
		frac25: '\u2156',
		frac34: '\u00BE',
		frac35: '\u2157',
		frac38: '\u215C',
		frac45: '\u2158',
		frac56: '\u215A',
		frac58: '\u215D',
		frac78: '\u215E',
		frasl: '\u2044',
		frown: '\u2322',
		Fscr: '\u2131',
		fscr: '\uD835\uDCBB',
		gacute: '\u01F5',
		Gamma: '\u0393',
		gamma: '\u03B3',
		Gammad: '\u03DC',
		gammad: '\u03DD',
		gap: '\u2A86',
		Gbreve: '\u011E',
		gbreve: '\u011F',
		Gcedil: '\u0122',
		Gcirc: '\u011C',
		gcirc: '\u011D',
		Gcy: '\u0413',
		gcy: '\u0433',
		Gdot: '\u0120',
		gdot: '\u0121',
		gE: '\u2267',
		ge: '\u2265',
		gEl: '\u2A8C',
		gel: '\u22DB',
		geq: '\u2265',
		geqq: '\u2267',
		geqslant: '\u2A7E',
		ges: '\u2A7E',
		gescc: '\u2AA9',
		gesdot: '\u2A80',
		gesdoto: '\u2A82',
		gesdotol: '\u2A84',
		gesl: '\u22DB\uFE00',
		gesles: '\u2A94',
		Gfr: '\uD835\uDD0A',
		gfr: '\uD835\uDD24',
		Gg: '\u22D9',
		gg: '\u226B',
		ggg: '\u22D9',
		gimel: '\u2137',
		GJcy: '\u0403',
		gjcy: '\u0453',
		gl: '\u2277',
		gla: '\u2AA5',
		glE: '\u2A92',
		glj: '\u2AA4',
		gnap: '\u2A8A',
		gnapprox: '\u2A8A',
		gnE: '\u2269',
		gne: '\u2A88',
		gneq: '\u2A88',
		gneqq: '\u2269',
		gnsim: '\u22E7',
		Gopf: '\uD835\uDD3E',
		gopf: '\uD835\uDD58',
		grave: '\u0060',
		GreaterEqual: '\u2265',
		GreaterEqualLess: '\u22DB',
		GreaterFullEqual: '\u2267',
		GreaterGreater: '\u2AA2',
		GreaterLess: '\u2277',
		GreaterSlantEqual: '\u2A7E',
		GreaterTilde: '\u2273',
		Gscr: '\uD835\uDCA2',
		gscr: '\u210A',
		gsim: '\u2273',
		gsime: '\u2A8E',
		gsiml: '\u2A90',
		Gt: '\u226B',
		GT: '\u003E',
		gt: '\u003E',
		gtcc: '\u2AA7',
		gtcir: '\u2A7A',
		gtdot: '\u22D7',
		gtlPar: '\u2995',
		gtquest: '\u2A7C',
		gtrapprox: '\u2A86',
		gtrarr: '\u2978',
		gtrdot: '\u22D7',
		gtreqless: '\u22DB',
		gtreqqless: '\u2A8C',
		gtrless: '\u2277',
		gtrsim: '\u2273',
		gvertneqq: '\u2269\uFE00',
		gvnE: '\u2269\uFE00',
		Hacek: '\u02C7',
		hairsp: '\u200A',
		half: '\u00BD',
		hamilt: '\u210B',
		HARDcy: '\u042A',
		hardcy: '\u044A',
		hArr: '\u21D4',
		harr: '\u2194',
		harrcir: '\u2948',
		harrw: '\u21AD',
		Hat: '\u005E',
		hbar: '\u210F',
		Hcirc: '\u0124',
		hcirc: '\u0125',
		hearts: '\u2665',
		heartsuit: '\u2665',
		hellip: '\u2026',
		hercon: '\u22B9',
		Hfr: '\u210C',
		hfr: '\uD835\uDD25',
		HilbertSpace: '\u210B',
		hksearow: '\u2925',
		hkswarow: '\u2926',
		hoarr: '\u21FF',
		homtht: '\u223B',
		hookleftarrow: '\u21A9',
		hookrightarrow: '\u21AA',
		Hopf: '\u210D',
		hopf: '\uD835\uDD59',
		horbar: '\u2015',
		HorizontalLine: '\u2500',
		Hscr: '\u210B',
		hscr: '\uD835\uDCBD',
		hslash: '\u210F',
		Hstrok: '\u0126',
		hstrok: '\u0127',
		HumpDownHump: '\u224E',
		HumpEqual: '\u224F',
		hybull: '\u2043',
		hyphen: '\u2010',
		Iacute: '\u00CD',
		iacute: '\u00ED',
		ic: '\u2063',
		Icirc: '\u00CE',
		icirc: '\u00EE',
		Icy: '\u0418',
		icy: '\u0438',
		Idot: '\u0130',
		IEcy: '\u0415',
		iecy: '\u0435',
		iexcl: '\u00A1',
		iff: '\u21D4',
		Ifr: '\u2111',
		ifr: '\uD835\uDD26',
		Igrave: '\u00CC',
		igrave: '\u00EC',
		ii: '\u2148',
		iiiint: '\u2A0C',
		iiint: '\u222D',
		iinfin: '\u29DC',
		iiota: '\u2129',
		IJlig: '\u0132',
		ijlig: '\u0133',
		Im: '\u2111',
		Imacr: '\u012A',
		imacr: '\u012B',
		image: '\u2111',
		ImaginaryI: '\u2148',
		imagline: '\u2110',
		imagpart: '\u2111',
		imath: '\u0131',
		imof: '\u22B7',
		imped: '\u01B5',
		Implies: '\u21D2',
		in: '\u2208',
		incare: '\u2105',
		infin: '\u221E',
		infintie: '\u29DD',
		inodot: '\u0131',
		Int: '\u222C',
		int: '\u222B',
		intcal: '\u22BA',
		integers: '\u2124',
		Integral: '\u222B',
		intercal: '\u22BA',
		Intersection: '\u22C2',
		intlarhk: '\u2A17',
		intprod: '\u2A3C',
		InvisibleComma: '\u2063',
		InvisibleTimes: '\u2062',
		IOcy: '\u0401',
		iocy: '\u0451',
		Iogon: '\u012E',
		iogon: '\u012F',
		Iopf: '\uD835\uDD40',
		iopf: '\uD835\uDD5A',
		Iota: '\u0399',
		iota: '\u03B9',
		iprod: '\u2A3C',
		iquest: '\u00BF',
		Iscr: '\u2110',
		iscr: '\uD835\uDCBE',
		isin: '\u2208',
		isindot: '\u22F5',
		isinE: '\u22F9',
		isins: '\u22F4',
		isinsv: '\u22F3',
		isinv: '\u2208',
		it: '\u2062',
		Itilde: '\u0128',
		itilde: '\u0129',
		Iukcy: '\u0406',
		iukcy: '\u0456',
		Iuml: '\u00CF',
		iuml: '\u00EF',
		Jcirc: '\u0134',
		jcirc: '\u0135',
		Jcy: '\u0419',
		jcy: '\u0439',
		Jfr: '\uD835\uDD0D',
		jfr: '\uD835\uDD27',
		jmath: '\u0237',
		Jopf: '\uD835\uDD41',
		jopf: '\uD835\uDD5B',
		Jscr: '\uD835\uDCA5',
		jscr: '\uD835\uDCBF',
		Jsercy: '\u0408',
		jsercy: '\u0458',
		Jukcy: '\u0404',
		jukcy: '\u0454',
		Kappa: '\u039A',
		kappa: '\u03BA',
		kappav: '\u03F0',
		Kcedil: '\u0136',
		kcedil: '\u0137',
		Kcy: '\u041A',
		kcy: '\u043A',
		Kfr: '\uD835\uDD0E',
		kfr: '\uD835\uDD28',
		kgreen: '\u0138',
		KHcy: '\u0425',
		khcy: '\u0445',
		KJcy: '\u040C',
		kjcy: '\u045C',
		Kopf: '\uD835\uDD42',
		kopf: '\uD835\uDD5C',
		Kscr: '\uD835\uDCA6',
		kscr: '\uD835\uDCC0',
		lAarr: '\u21DA',
		Lacute: '\u0139',
		lacute: '\u013A',
		laemptyv: '\u29B4',
		lagran: '\u2112',
		Lambda: '\u039B',
		lambda: '\u03BB',
		Lang: '\u27EA',
		lang: '\u27E8',
		langd: '\u2991',
		langle: '\u27E8',
		lap: '\u2A85',
		Laplacetrf: '\u2112',
		laquo: '\u00AB',
		Larr: '\u219E',
		lArr: '\u21D0',
		larr: '\u2190',
		larrb: '\u21E4',
		larrbfs: '\u291F',
		larrfs: '\u291D',
		larrhk: '\u21A9',
		larrlp: '\u21AB',
		larrpl: '\u2939',
		larrsim: '\u2973',
		larrtl: '\u21A2',
		lat: '\u2AAB',
		lAtail: '\u291B',
		latail: '\u2919',
		late: '\u2AAD',
		lates: '\u2AAD\uFE00',
		lBarr: '\u290E',
		lbarr: '\u290C',
		lbbrk: '\u2772',
		lbrace: '\u007B',
		lbrack: '\u005B',
		lbrke: '\u298B',
		lbrksld: '\u298F',
		lbrkslu: '\u298D',
		Lcaron: '\u013D',
		lcaron: '\u013E',
		Lcedil: '\u013B',
		lcedil: '\u013C',
		lceil: '\u2308',
		lcub: '\u007B',
		Lcy: '\u041B',
		lcy: '\u043B',
		ldca: '\u2936',
		ldquo: '\u201C',
		ldquor: '\u201E',
		ldrdhar: '\u2967',
		ldrushar: '\u294B',
		ldsh: '\u21B2',
		lE: '\u2266',
		le: '\u2264',
		LeftAngleBracket: '\u27E8',
		LeftArrow: '\u2190',
		Leftarrow: '\u21D0',
		leftarrow: '\u2190',
		LeftArrowBar: '\u21E4',
		LeftArrowRightArrow: '\u21C6',
		leftarrowtail: '\u21A2',
		LeftCeiling: '\u2308',
		LeftDoubleBracket: '\u27E6',
		LeftDownTeeVector: '\u2961',
		LeftDownVector: '\u21C3',
		LeftDownVectorBar: '\u2959',
		LeftFloor: '\u230A',
		leftharpoondown: '\u21BD',
		leftharpoonup: '\u21BC',
		leftleftarrows: '\u21C7',
		LeftRightArrow: '\u2194',
		Leftrightarrow: '\u21D4',
		leftrightarrow: '\u2194',
		leftrightarrows: '\u21C6',
		leftrightharpoons: '\u21CB',
		leftrightsquigarrow: '\u21AD',
		LeftRightVector: '\u294E',
		LeftTee: '\u22A3',
		LeftTeeArrow: '\u21A4',
		LeftTeeVector: '\u295A',
		leftthreetimes: '\u22CB',
		LeftTriangle: '\u22B2',
		LeftTriangleBar: '\u29CF',
		LeftTriangleEqual: '\u22B4',
		LeftUpDownVector: '\u2951',
		LeftUpTeeVector: '\u2960',
		LeftUpVector: '\u21BF',
		LeftUpVectorBar: '\u2958',
		LeftVector: '\u21BC',
		LeftVectorBar: '\u2952',
		lEg: '\u2A8B',
		leg: '\u22DA',
		leq: '\u2264',
		leqq: '\u2266',
		leqslant: '\u2A7D',
		les: '\u2A7D',
		lescc: '\u2AA8',
		lesdot: '\u2A7F',
		lesdoto: '\u2A81',
		lesdotor: '\u2A83',
		lesg: '\u22DA\uFE00',
		lesges: '\u2A93',
		lessapprox: '\u2A85',
		lessdot: '\u22D6',
		lesseqgtr: '\u22DA',
		lesseqqgtr: '\u2A8B',
		LessEqualGreater: '\u22DA',
		LessFullEqual: '\u2266',
		LessGreater: '\u2276',
		lessgtr: '\u2276',
		LessLess: '\u2AA1',
		lesssim: '\u2272',
		LessSlantEqual: '\u2A7D',
		LessTilde: '\u2272',
		lfisht: '\u297C',
		lfloor: '\u230A',
		Lfr: '\uD835\uDD0F',
		lfr: '\uD835\uDD29',
		lg: '\u2276',
		lgE: '\u2A91',
		lHar: '\u2962',
		lhard: '\u21BD',
		lharu: '\u21BC',
		lharul: '\u296A',
		lhblk: '\u2584',
		LJcy: '\u0409',
		ljcy: '\u0459',
		Ll: '\u22D8',
		ll: '\u226A',
		llarr: '\u21C7',
		llcorner: '\u231E',
		Lleftarrow: '\u21DA',
		llhard: '\u296B',
		lltri: '\u25FA',
		Lmidot: '\u013F',
		lmidot: '\u0140',
		lmoust: '\u23B0',
		lmoustache: '\u23B0',
		lnap: '\u2A89',
		lnapprox: '\u2A89',
		lnE: '\u2268',
		lne: '\u2A87',
		lneq: '\u2A87',
		lneqq: '\u2268',
		lnsim: '\u22E6',
		loang: '\u27EC',
		loarr: '\u21FD',
		lobrk: '\u27E6',
		LongLeftArrow: '\u27F5',
		Longleftarrow: '\u27F8',
		longleftarrow: '\u27F5',
		LongLeftRightArrow: '\u27F7',
		Longleftrightarrow: '\u27FA',
		longleftrightarrow: '\u27F7',
		longmapsto: '\u27FC',
		LongRightArrow: '\u27F6',
		Longrightarrow: '\u27F9',
		longrightarrow: '\u27F6',
		looparrowleft: '\u21AB',
		looparrowright: '\u21AC',
		lopar: '\u2985',
		Lopf: '\uD835\uDD43',
		lopf: '\uD835\uDD5D',
		loplus: '\u2A2D',
		lotimes: '\u2A34',
		lowast: '\u2217',
		lowbar: '\u005F',
		LowerLeftArrow: '\u2199',
		LowerRightArrow: '\u2198',
		loz: '\u25CA',
		lozenge: '\u25CA',
		lozf: '\u29EB',
		lpar: '\u0028',
		lparlt: '\u2993',
		lrarr: '\u21C6',
		lrcorner: '\u231F',
		lrhar: '\u21CB',
		lrhard: '\u296D',
		lrm: '\u200E',
		lrtri: '\u22BF',
		lsaquo: '\u2039',
		Lscr: '\u2112',
		lscr: '\uD835\uDCC1',
		Lsh: '\u21B0',
		lsh: '\u21B0',
		lsim: '\u2272',
		lsime: '\u2A8D',
		lsimg: '\u2A8F',
		lsqb: '\u005B',
		lsquo: '\u2018',
		lsquor: '\u201A',
		Lstrok: '\u0141',
		lstrok: '\u0142',
		Lt: '\u226A',
		LT: '\u003C',
		lt: '\u003C',
		ltcc: '\u2AA6',
		ltcir: '\u2A79',
		ltdot: '\u22D6',
		lthree: '\u22CB',
		ltimes: '\u22C9',
		ltlarr: '\u2976',
		ltquest: '\u2A7B',
		ltri: '\u25C3',
		ltrie: '\u22B4',
		ltrif: '\u25C2',
		ltrPar: '\u2996',
		lurdshar: '\u294A',
		luruhar: '\u2966',
		lvertneqq: '\u2268\uFE00',
		lvnE: '\u2268\uFE00',
		macr: '\u00AF',
		male: '\u2642',
		malt: '\u2720',
		maltese: '\u2720',
		Map: '\u2905',
		map: '\u21A6',
		mapsto: '\u21A6',
		mapstodown: '\u21A7',
		mapstoleft: '\u21A4',
		mapstoup: '\u21A5',
		marker: '\u25AE',
		mcomma: '\u2A29',
		Mcy: '\u041C',
		mcy: '\u043C',
		mdash: '\u2014',
		mDDot: '\u223A',
		measuredangle: '\u2221',
		MediumSpace: '\u205F',
		Mellintrf: '\u2133',
		Mfr: '\uD835\uDD10',
		mfr: '\uD835\uDD2A',
		mho: '\u2127',
		micro: '\u00B5',
		mid: '\u2223',
		midast: '\u002A',
		midcir: '\u2AF0',
		middot: '\u00B7',
		minus: '\u2212',
		minusb: '\u229F',
		minusd: '\u2238',
		minusdu: '\u2A2A',
		MinusPlus: '\u2213',
		mlcp: '\u2ADB',
		mldr: '\u2026',
		mnplus: '\u2213',
		models: '\u22A7',
		Mopf: '\uD835\uDD44',
		mopf: '\uD835\uDD5E',
		mp: '\u2213',
		Mscr: '\u2133',
		mscr: '\uD835\uDCC2',
		mstpos: '\u223E',
		Mu: '\u039C',
		mu: '\u03BC',
		multimap: '\u22B8',
		mumap: '\u22B8',
		nabla: '\u2207',
		Nacute: '\u0143',
		nacute: '\u0144',
		nang: '\u2220\u20D2',
		nap: '\u2249',
		napE: '\u2A70\u0338',
		napid: '\u224B\u0338',
		napos: '\u0149',
		napprox: '\u2249',
		natur: '\u266E',
		natural: '\u266E',
		naturals: '\u2115',
		nbsp: '\u00A0',
		nbump: '\u224E\u0338',
		nbumpe: '\u224F\u0338',
		ncap: '\u2A43',
		Ncaron: '\u0147',
		ncaron: '\u0148',
		Ncedil: '\u0145',
		ncedil: '\u0146',
		ncong: '\u2247',
		ncongdot: '\u2A6D\u0338',
		ncup: '\u2A42',
		Ncy: '\u041D',
		ncy: '\u043D',
		ndash: '\u2013',
		ne: '\u2260',
		nearhk: '\u2924',
		neArr: '\u21D7',
		nearr: '\u2197',
		nearrow: '\u2197',
		nedot: '\u2250\u0338',
		NegativeMediumSpace: '\u200B',
		NegativeThickSpace: '\u200B',
		NegativeThinSpace: '\u200B',
		NegativeVeryThinSpace: '\u200B',
		nequiv: '\u2262',
		nesear: '\u2928',
		nesim: '\u2242\u0338',
		NestedGreaterGreater: '\u226B',
		NestedLessLess: '\u226A',
		NewLine: '\u000A',
		nexist: '\u2204',
		nexists: '\u2204',
		Nfr: '\uD835\uDD11',
		nfr: '\uD835\uDD2B',
		ngE: '\u2267\u0338',
		nge: '\u2271',
		ngeq: '\u2271',
		ngeqq: '\u2267\u0338',
		ngeqslant: '\u2A7E\u0338',
		nges: '\u2A7E\u0338',
		nGg: '\u22D9\u0338',
		ngsim: '\u2275',
		nGt: '\u226B\u20D2',
		ngt: '\u226F',
		ngtr: '\u226F',
		nGtv: '\u226B\u0338',
		nhArr: '\u21CE',
		nharr: '\u21AE',
		nhpar: '\u2AF2',
		ni: '\u220B',
		nis: '\u22FC',
		nisd: '\u22FA',
		niv: '\u220B',
		NJcy: '\u040A',
		njcy: '\u045A',
		nlArr: '\u21CD',
		nlarr: '\u219A',
		nldr: '\u2025',
		nlE: '\u2266\u0338',
		nle: '\u2270',
		nLeftarrow: '\u21CD',
		nleftarrow: '\u219A',
		nLeftrightarrow: '\u21CE',
		nleftrightarrow: '\u21AE',
		nleq: '\u2270',
		nleqq: '\u2266\u0338',
		nleqslant: '\u2A7D\u0338',
		nles: '\u2A7D\u0338',
		nless: '\u226E',
		nLl: '\u22D8\u0338',
		nlsim: '\u2274',
		nLt: '\u226A\u20D2',
		nlt: '\u226E',
		nltri: '\u22EA',
		nltrie: '\u22EC',
		nLtv: '\u226A\u0338',
		nmid: '\u2224',
		NoBreak: '\u2060',
		NonBreakingSpace: '\u00A0',
		Nopf: '\u2115',
		nopf: '\uD835\uDD5F',
		Not: '\u2AEC',
		not: '\u00AC',
		NotCongruent: '\u2262',
		NotCupCap: '\u226D',
		NotDoubleVerticalBar: '\u2226',
		NotElement: '\u2209',
		NotEqual: '\u2260',
		NotEqualTilde: '\u2242\u0338',
		NotExists: '\u2204',
		NotGreater: '\u226F',
		NotGreaterEqual: '\u2271',
		NotGreaterFullEqual: '\u2267\u0338',
		NotGreaterGreater: '\u226B\u0338',
		NotGreaterLess: '\u2279',
		NotGreaterSlantEqual: '\u2A7E\u0338',
		NotGreaterTilde: '\u2275',
		NotHumpDownHump: '\u224E\u0338',
		NotHumpEqual: '\u224F\u0338',
		notin: '\u2209',
		notindot: '\u22F5\u0338',
		notinE: '\u22F9\u0338',
		notinva: '\u2209',
		notinvb: '\u22F7',
		notinvc: '\u22F6',
		NotLeftTriangle: '\u22EA',
		NotLeftTriangleBar: '\u29CF\u0338',
		NotLeftTriangleEqual: '\u22EC',
		NotLess: '\u226E',
		NotLessEqual: '\u2270',
		NotLessGreater: '\u2278',
		NotLessLess: '\u226A\u0338',
		NotLessSlantEqual: '\u2A7D\u0338',
		NotLessTilde: '\u2274',
		NotNestedGreaterGreater: '\u2AA2\u0338',
		NotNestedLessLess: '\u2AA1\u0338',
		notni: '\u220C',
		notniva: '\u220C',
		notnivb: '\u22FE',
		notnivc: '\u22FD',
		NotPrecedes: '\u2280',
		NotPrecedesEqual: '\u2AAF\u0338',
		NotPrecedesSlantEqual: '\u22E0',
		NotReverseElement: '\u220C',
		NotRightTriangle: '\u22EB',
		NotRightTriangleBar: '\u29D0\u0338',
		NotRightTriangleEqual: '\u22ED',
		NotSquareSubset: '\u228F\u0338',
		NotSquareSubsetEqual: '\u22E2',
		NotSquareSuperset: '\u2290\u0338',
		NotSquareSupersetEqual: '\u22E3',
		NotSubset: '\u2282\u20D2',
		NotSubsetEqual: '\u2288',
		NotSucceeds: '\u2281',
		NotSucceedsEqual: '\u2AB0\u0338',
		NotSucceedsSlantEqual: '\u22E1',
		NotSucceedsTilde: '\u227F\u0338',
		NotSuperset: '\u2283\u20D2',
		NotSupersetEqual: '\u2289',
		NotTilde: '\u2241',
		NotTildeEqual: '\u2244',
		NotTildeFullEqual: '\u2247',
		NotTildeTilde: '\u2249',
		NotVerticalBar: '\u2224',
		npar: '\u2226',
		nparallel: '\u2226',
		nparsl: '\u2AFD\u20E5',
		npart: '\u2202\u0338',
		npolint: '\u2A14',
		npr: '\u2280',
		nprcue: '\u22E0',
		npre: '\u2AAF\u0338',
		nprec: '\u2280',
		npreceq: '\u2AAF\u0338',
		nrArr: '\u21CF',
		nrarr: '\u219B',
		nrarrc: '\u2933\u0338',
		nrarrw: '\u219D\u0338',
		nRightarrow: '\u21CF',
		nrightarrow: '\u219B',
		nrtri: '\u22EB',
		nrtrie: '\u22ED',
		nsc: '\u2281',
		nsccue: '\u22E1',
		nsce: '\u2AB0\u0338',
		Nscr: '\uD835\uDCA9',
		nscr: '\uD835\uDCC3',
		nshortmid: '\u2224',
		nshortparallel: '\u2226',
		nsim: '\u2241',
		nsime: '\u2244',
		nsimeq: '\u2244',
		nsmid: '\u2224',
		nspar: '\u2226',
		nsqsube: '\u22E2',
		nsqsupe: '\u22E3',
		nsub: '\u2284',
		nsubE: '\u2AC5\u0338',
		nsube: '\u2288',
		nsubset: '\u2282\u20D2',
		nsubseteq: '\u2288',
		nsubseteqq: '\u2AC5\u0338',
		nsucc: '\u2281',
		nsucceq: '\u2AB0\u0338',
		nsup: '\u2285',
		nsupE: '\u2AC6\u0338',
		nsupe: '\u2289',
		nsupset: '\u2283\u20D2',
		nsupseteq: '\u2289',
		nsupseteqq: '\u2AC6\u0338',
		ntgl: '\u2279',
		Ntilde: '\u00D1',
		ntilde: '\u00F1',
		ntlg: '\u2278',
		ntriangleleft: '\u22EA',
		ntrianglelefteq: '\u22EC',
		ntriangleright: '\u22EB',
		ntrianglerighteq: '\u22ED',
		Nu: '\u039D',
		nu: '\u03BD',
		num: '\u0023',
		numero: '\u2116',
		numsp: '\u2007',
		nvap: '\u224D\u20D2',
		nVDash: '\u22AF',
		nVdash: '\u22AE',
		nvDash: '\u22AD',
		nvdash: '\u22AC',
		nvge: '\u2265\u20D2',
		nvgt: '\u003E\u20D2',
		nvHarr: '\u2904',
		nvinfin: '\u29DE',
		nvlArr: '\u2902',
		nvle: '\u2264\u20D2',
		nvlt: '\u003C\u20D2',
		nvltrie: '\u22B4\u20D2',
		nvrArr: '\u2903',
		nvrtrie: '\u22B5\u20D2',
		nvsim: '\u223C\u20D2',
		nwarhk: '\u2923',
		nwArr: '\u21D6',
		nwarr: '\u2196',
		nwarrow: '\u2196',
		nwnear: '\u2927',
		Oacute: '\u00D3',
		oacute: '\u00F3',
		oast: '\u229B',
		ocir: '\u229A',
		Ocirc: '\u00D4',
		ocirc: '\u00F4',
		Ocy: '\u041E',
		ocy: '\u043E',
		odash: '\u229D',
		Odblac: '\u0150',
		odblac: '\u0151',
		odiv: '\u2A38',
		odot: '\u2299',
		odsold: '\u29BC',
		OElig: '\u0152',
		oelig: '\u0153',
		ofcir: '\u29BF',
		Ofr: '\uD835\uDD12',
		ofr: '\uD835\uDD2C',
		ogon: '\u02DB',
		Ograve: '\u00D2',
		ograve: '\u00F2',
		ogt: '\u29C1',
		ohbar: '\u29B5',
		ohm: '\u03A9',
		oint: '\u222E',
		olarr: '\u21BA',
		olcir: '\u29BE',
		olcross: '\u29BB',
		oline: '\u203E',
		olt: '\u29C0',
		Omacr: '\u014C',
		omacr: '\u014D',
		Omega: '\u03A9',
		omega: '\u03C9',
		Omicron: '\u039F',
		omicron: '\u03BF',
		omid: '\u29B6',
		ominus: '\u2296',
		Oopf: '\uD835\uDD46',
		oopf: '\uD835\uDD60',
		opar: '\u29B7',
		OpenCurlyDoubleQuote: '\u201C',
		OpenCurlyQuote: '\u2018',
		operp: '\u29B9',
		oplus: '\u2295',
		Or: '\u2A54',
		or: '\u2228',
		orarr: '\u21BB',
		ord: '\u2A5D',
		order: '\u2134',
		orderof: '\u2134',
		ordf: '\u00AA',
		ordm: '\u00BA',
		origof: '\u22B6',
		oror: '\u2A56',
		orslope: '\u2A57',
		orv: '\u2A5B',
		oS: '\u24C8',
		Oscr: '\uD835\uDCAA',
		oscr: '\u2134',
		Oslash: '\u00D8',
		oslash: '\u00F8',
		osol: '\u2298',
		Otilde: '\u00D5',
		otilde: '\u00F5',
		Otimes: '\u2A37',
		otimes: '\u2297',
		otimesas: '\u2A36',
		Ouml: '\u00D6',
		ouml: '\u00F6',
		ovbar: '\u233D',
		OverBar: '\u203E',
		OverBrace: '\u23DE',
		OverBracket: '\u23B4',
		OverParenthesis: '\u23DC',
		par: '\u2225',
		para: '\u00B6',
		parallel: '\u2225',
		parsim: '\u2AF3',
		parsl: '\u2AFD',
		part: '\u2202',
		PartialD: '\u2202',
		Pcy: '\u041F',
		pcy: '\u043F',
		percnt: '\u0025',
		period: '\u002E',
		permil: '\u2030',
		perp: '\u22A5',
		pertenk: '\u2031',
		Pfr: '\uD835\uDD13',
		pfr: '\uD835\uDD2D',
		Phi: '\u03A6',
		phi: '\u03C6',
		phiv: '\u03D5',
		phmmat: '\u2133',
		phone: '\u260E',
		Pi: '\u03A0',
		pi: '\u03C0',
		pitchfork: '\u22D4',
		piv: '\u03D6',
		planck: '\u210F',
		planckh: '\u210E',
		plankv: '\u210F',
		plus: '\u002B',
		plusacir: '\u2A23',
		plusb: '\u229E',
		pluscir: '\u2A22',
		plusdo: '\u2214',
		plusdu: '\u2A25',
		pluse: '\u2A72',
		PlusMinus: '\u00B1',
		plusmn: '\u00B1',
		plussim: '\u2A26',
		plustwo: '\u2A27',
		pm: '\u00B1',
		Poincareplane: '\u210C',
		pointint: '\u2A15',
		Popf: '\u2119',
		popf: '\uD835\uDD61',
		pound: '\u00A3',
		Pr: '\u2ABB',
		pr: '\u227A',
		prap: '\u2AB7',
		prcue: '\u227C',
		prE: '\u2AB3',
		pre: '\u2AAF',
		prec: '\u227A',
		precapprox: '\u2AB7',
		preccurlyeq: '\u227C',
		Precedes: '\u227A',
		PrecedesEqual: '\u2AAF',
		PrecedesSlantEqual: '\u227C',
		PrecedesTilde: '\u227E',
		preceq: '\u2AAF',
		precnapprox: '\u2AB9',
		precneqq: '\u2AB5',
		precnsim: '\u22E8',
		precsim: '\u227E',
		Prime: '\u2033',
		prime: '\u2032',
		primes: '\u2119',
		prnap: '\u2AB9',
		prnE: '\u2AB5',
		prnsim: '\u22E8',
		prod: '\u220F',
		Product: '\u220F',
		profalar: '\u232E',
		profline: '\u2312',
		profsurf: '\u2313',
		prop: '\u221D',
		Proportion: '\u2237',
		Proportional: '\u221D',
		propto: '\u221D',
		prsim: '\u227E',
		prurel: '\u22B0',
		Pscr: '\uD835\uDCAB',
		pscr: '\uD835\uDCC5',
		Psi: '\u03A8',
		psi: '\u03C8',
		puncsp: '\u2008',
		Qfr: '\uD835\uDD14',
		qfr: '\uD835\uDD2E',
		qint: '\u2A0C',
		Qopf: '\u211A',
		qopf: '\uD835\uDD62',
		qprime: '\u2057',
		Qscr: '\uD835\uDCAC',
		qscr: '\uD835\uDCC6',
		quaternions: '\u210D',
		quatint: '\u2A16',
		quest: '\u003F',
		questeq: '\u225F',
		QUOT: '\u0022',
		quot: '\u0022',
		rAarr: '\u21DB',
		race: '\u223D\u0331',
		Racute: '\u0154',
		racute: '\u0155',
		radic: '\u221A',
		raemptyv: '\u29B3',
		Rang: '\u27EB',
		rang: '\u27E9',
		rangd: '\u2992',
		range: '\u29A5',
		rangle: '\u27E9',
		raquo: '\u00BB',
		Rarr: '\u21A0',
		rArr: '\u21D2',
		rarr: '\u2192',
		rarrap: '\u2975',
		rarrb: '\u21E5',
		rarrbfs: '\u2920',
		rarrc: '\u2933',
		rarrfs: '\u291E',
		rarrhk: '\u21AA',
		rarrlp: '\u21AC',
		rarrpl: '\u2945',
		rarrsim: '\u2974',
		Rarrtl: '\u2916',
		rarrtl: '\u21A3',
		rarrw: '\u219D',
		rAtail: '\u291C',
		ratail: '\u291A',
		ratio: '\u2236',
		rationals: '\u211A',
		RBarr: '\u2910',
		rBarr: '\u290F',
		rbarr: '\u290D',
		rbbrk: '\u2773',
		rbrace: '\u007D',
		rbrack: '\u005D',
		rbrke: '\u298C',
		rbrksld: '\u298E',
		rbrkslu: '\u2990',
		Rcaron: '\u0158',
		rcaron: '\u0159',
		Rcedil: '\u0156',
		rcedil: '\u0157',
		rceil: '\u2309',
		rcub: '\u007D',
		Rcy: '\u0420',
		rcy: '\u0440',
		rdca: '\u2937',
		rdldhar: '\u2969',
		rdquo: '\u201D',
		rdquor: '\u201D',
		rdsh: '\u21B3',
		Re: '\u211C',
		real: '\u211C',
		realine: '\u211B',
		realpart: '\u211C',
		reals: '\u211D',
		rect: '\u25AD',
		REG: '\u00AE',
		reg: '\u00AE',
		ReverseElement: '\u220B',
		ReverseEquilibrium: '\u21CB',
		ReverseUpEquilibrium: '\u296F',
		rfisht: '\u297D',
		rfloor: '\u230B',
		Rfr: '\u211C',
		rfr: '\uD835\uDD2F',
		rHar: '\u2964',
		rhard: '\u21C1',
		rharu: '\u21C0',
		rharul: '\u296C',
		Rho: '\u03A1',
		rho: '\u03C1',
		rhov: '\u03F1',
		RightAngleBracket: '\u27E9',
		RightArrow: '\u2192',
		Rightarrow: '\u21D2',
		rightarrow: '\u2192',
		RightArrowBar: '\u21E5',
		RightArrowLeftArrow: '\u21C4',
		rightarrowtail: '\u21A3',
		RightCeiling: '\u2309',
		RightDoubleBracket: '\u27E7',
		RightDownTeeVector: '\u295D',
		RightDownVector: '\u21C2',
		RightDownVectorBar: '\u2955',
		RightFloor: '\u230B',
		rightharpoondown: '\u21C1',
		rightharpoonup: '\u21C0',
		rightleftarrows: '\u21C4',
		rightleftharpoons: '\u21CC',
		rightrightarrows: '\u21C9',
		rightsquigarrow: '\u219D',
		RightTee: '\u22A2',
		RightTeeArrow: '\u21A6',
		RightTeeVector: '\u295B',
		rightthreetimes: '\u22CC',
		RightTriangle: '\u22B3',
		RightTriangleBar: '\u29D0',
		RightTriangleEqual: '\u22B5',
		RightUpDownVector: '\u294F',
		RightUpTeeVector: '\u295C',
		RightUpVector: '\u21BE',
		RightUpVectorBar: '\u2954',
		RightVector: '\u21C0',
		RightVectorBar: '\u2953',
		ring: '\u02DA',
		risingdotseq: '\u2253',
		rlarr: '\u21C4',
		rlhar: '\u21CC',
		rlm: '\u200F',
		rmoust: '\u23B1',
		rmoustache: '\u23B1',
		rnmid: '\u2AEE',
		roang: '\u27ED',
		roarr: '\u21FE',
		robrk: '\u27E7',
		ropar: '\u2986',
		Ropf: '\u211D',
		ropf: '\uD835\uDD63',
		roplus: '\u2A2E',
		rotimes: '\u2A35',
		RoundImplies: '\u2970',
		rpar: '\u0029',
		rpargt: '\u2994',
		rppolint: '\u2A12',
		rrarr: '\u21C9',
		Rrightarrow: '\u21DB',
		rsaquo: '\u203A',
		Rscr: '\u211B',
		rscr: '\uD835\uDCC7',
		Rsh: '\u21B1',
		rsh: '\u21B1',
		rsqb: '\u005D',
		rsquo: '\u2019',
		rsquor: '\u2019',
		rthree: '\u22CC',
		rtimes: '\u22CA',
		rtri: '\u25B9',
		rtrie: '\u22B5',
		rtrif: '\u25B8',
		rtriltri: '\u29CE',
		RuleDelayed: '\u29F4',
		ruluhar: '\u2968',
		rx: '\u211E',
		Sacute: '\u015A',
		sacute: '\u015B',
		sbquo: '\u201A',
		Sc: '\u2ABC',
		sc: '\u227B',
		scap: '\u2AB8',
		Scaron: '\u0160',
		scaron: '\u0161',
		sccue: '\u227D',
		scE: '\u2AB4',
		sce: '\u2AB0',
		Scedil: '\u015E',
		scedil: '\u015F',
		Scirc: '\u015C',
		scirc: '\u015D',
		scnap: '\u2ABA',
		scnE: '\u2AB6',
		scnsim: '\u22E9',
		scpolint: '\u2A13',
		scsim: '\u227F',
		Scy: '\u0421',
		scy: '\u0441',
		sdot: '\u22C5',
		sdotb: '\u22A1',
		sdote: '\u2A66',
		searhk: '\u2925',
		seArr: '\u21D8',
		searr: '\u2198',
		searrow: '\u2198',
		sect: '\u00A7',
		semi: '\u003B',
		seswar: '\u2929',
		setminus: '\u2216',
		setmn: '\u2216',
		sext: '\u2736',
		Sfr: '\uD835\uDD16',
		sfr: '\uD835\uDD30',
		sfrown: '\u2322',
		sharp: '\u266F',
		SHCHcy: '\u0429',
		shchcy: '\u0449',
		SHcy: '\u0428',
		shcy: '\u0448',
		ShortDownArrow: '\u2193',
		ShortLeftArrow: '\u2190',
		shortmid: '\u2223',
		shortparallel: '\u2225',
		ShortRightArrow: '\u2192',
		ShortUpArrow: '\u2191',
		shy: '\u00AD',
		Sigma: '\u03A3',
		sigma: '\u03C3',
		sigmaf: '\u03C2',
		sigmav: '\u03C2',
		sim: '\u223C',
		simdot: '\u2A6A',
		sime: '\u2243',
		simeq: '\u2243',
		simg: '\u2A9E',
		simgE: '\u2AA0',
		siml: '\u2A9D',
		simlE: '\u2A9F',
		simne: '\u2246',
		simplus: '\u2A24',
		simrarr: '\u2972',
		slarr: '\u2190',
		SmallCircle: '\u2218',
		smallsetminus: '\u2216',
		smashp: '\u2A33',
		smeparsl: '\u29E4',
		smid: '\u2223',
		smile: '\u2323',
		smt: '\u2AAA',
		smte: '\u2AAC',
		smtes: '\u2AAC\uFE00',
		SOFTcy: '\u042C',
		softcy: '\u044C',
		sol: '\u002F',
		solb: '\u29C4',
		solbar: '\u233F',
		Sopf: '\uD835\uDD4A',
		sopf: '\uD835\uDD64',
		spades: '\u2660',
		spadesuit: '\u2660',
		spar: '\u2225',
		sqcap: '\u2293',
		sqcaps: '\u2293\uFE00',
		sqcup: '\u2294',
		sqcups: '\u2294\uFE00',
		Sqrt: '\u221A',
		sqsub: '\u228F',
		sqsube: '\u2291',
		sqsubset: '\u228F',
		sqsubseteq: '\u2291',
		sqsup: '\u2290',
		sqsupe: '\u2292',
		sqsupset: '\u2290',
		sqsupseteq: '\u2292',
		squ: '\u25A1',
		Square: '\u25A1',
		square: '\u25A1',
		SquareIntersection: '\u2293',
		SquareSubset: '\u228F',
		SquareSubsetEqual: '\u2291',
		SquareSuperset: '\u2290',
		SquareSupersetEqual: '\u2292',
		SquareUnion: '\u2294',
		squarf: '\u25AA',
		squf: '\u25AA',
		srarr: '\u2192',
		Sscr: '\uD835\uDCAE',
		sscr: '\uD835\uDCC8',
		ssetmn: '\u2216',
		ssmile: '\u2323',
		sstarf: '\u22C6',
		Star: '\u22C6',
		star: '\u2606',
		starf: '\u2605',
		straightepsilon: '\u03F5',
		straightphi: '\u03D5',
		strns: '\u00AF',
		Sub: '\u22D0',
		sub: '\u2282',
		subdot: '\u2ABD',
		subE: '\u2AC5',
		sube: '\u2286',
		subedot: '\u2AC3',
		submult: '\u2AC1',
		subnE: '\u2ACB',
		subne: '\u228A',
		subplus: '\u2ABF',
		subrarr: '\u2979',
		Subset: '\u22D0',
		subset: '\u2282',
		subseteq: '\u2286',
		subseteqq: '\u2AC5',
		SubsetEqual: '\u2286',
		subsetneq: '\u228A',
		subsetneqq: '\u2ACB',
		subsim: '\u2AC7',
		subsub: '\u2AD5',
		subsup: '\u2AD3',
		succ: '\u227B',
		succapprox: '\u2AB8',
		succcurlyeq: '\u227D',
		Succeeds: '\u227B',
		SucceedsEqual: '\u2AB0',
		SucceedsSlantEqual: '\u227D',
		SucceedsTilde: '\u227F',
		succeq: '\u2AB0',
		succnapprox: '\u2ABA',
		succneqq: '\u2AB6',
		succnsim: '\u22E9',
		succsim: '\u227F',
		SuchThat: '\u220B',
		Sum: '\u2211',
		sum: '\u2211',
		sung: '\u266A',
		Sup: '\u22D1',
		sup: '\u2283',
		sup1: '\u00B9',
		sup2: '\u00B2',
		sup3: '\u00B3',
		supdot: '\u2ABE',
		supdsub: '\u2AD8',
		supE: '\u2AC6',
		supe: '\u2287',
		supedot: '\u2AC4',
		Superset: '\u2283',
		SupersetEqual: '\u2287',
		suphsol: '\u27C9',
		suphsub: '\u2AD7',
		suplarr: '\u297B',
		supmult: '\u2AC2',
		supnE: '\u2ACC',
		supne: '\u228B',
		supplus: '\u2AC0',
		Supset: '\u22D1',
		supset: '\u2283',
		supseteq: '\u2287',
		supseteqq: '\u2AC6',
		supsetneq: '\u228B',
		supsetneqq: '\u2ACC',
		supsim: '\u2AC8',
		supsub: '\u2AD4',
		supsup: '\u2AD6',
		swarhk: '\u2926',
		swArr: '\u21D9',
		swarr: '\u2199',
		swarrow: '\u2199',
		swnwar: '\u292A',
		szlig: '\u00DF',
		Tab: '\u0009',
		target: '\u2316',
		Tau: '\u03A4',
		tau: '\u03C4',
		tbrk: '\u23B4',
		Tcaron: '\u0164',
		tcaron: '\u0165',
		Tcedil: '\u0162',
		tcedil: '\u0163',
		Tcy: '\u0422',
		tcy: '\u0442',
		tdot: '\u20DB',
		telrec: '\u2315',
		Tfr: '\uD835\uDD17',
		tfr: '\uD835\uDD31',
		there4: '\u2234',
		Therefore: '\u2234',
		therefore: '\u2234',
		Theta: '\u0398',
		theta: '\u03B8',
		thetasym: '\u03D1',
		thetav: '\u03D1',
		thickapprox: '\u2248',
		thicksim: '\u223C',
		ThickSpace: '\u205F\u200A',
		thinsp: '\u2009',
		ThinSpace: '\u2009',
		thkap: '\u2248',
		thksim: '\u223C',
		THORN: '\u00DE',
		thorn: '\u00FE',
		Tilde: '\u223C',
		tilde: '\u02DC',
		TildeEqual: '\u2243',
		TildeFullEqual: '\u2245',
		TildeTilde: '\u2248',
		times: '\u00D7',
		timesb: '\u22A0',
		timesbar: '\u2A31',
		timesd: '\u2A30',
		tint: '\u222D',
		toea: '\u2928',
		top: '\u22A4',
		topbot: '\u2336',
		topcir: '\u2AF1',
		Topf: '\uD835\uDD4B',
		topf: '\uD835\uDD65',
		topfork: '\u2ADA',
		tosa: '\u2929',
		tprime: '\u2034',
		TRADE: '\u2122',
		trade: '\u2122',
		triangle: '\u25B5',
		triangledown: '\u25BF',
		triangleleft: '\u25C3',
		trianglelefteq: '\u22B4',
		triangleq: '\u225C',
		triangleright: '\u25B9',
		trianglerighteq: '\u22B5',
		tridot: '\u25EC',
		trie: '\u225C',
		triminus: '\u2A3A',
		TripleDot: '\u20DB',
		triplus: '\u2A39',
		trisb: '\u29CD',
		tritime: '\u2A3B',
		trpezium: '\u23E2',
		Tscr: '\uD835\uDCAF',
		tscr: '\uD835\uDCC9',
		TScy: '\u0426',
		tscy: '\u0446',
		TSHcy: '\u040B',
		tshcy: '\u045B',
		Tstrok: '\u0166',
		tstrok: '\u0167',
		twixt: '\u226C',
		twoheadleftarrow: '\u219E',
		twoheadrightarrow: '\u21A0',
		Uacute: '\u00DA',
		uacute: '\u00FA',
		Uarr: '\u219F',
		uArr: '\u21D1',
		uarr: '\u2191',
		Uarrocir: '\u2949',
		Ubrcy: '\u040E',
		ubrcy: '\u045E',
		Ubreve: '\u016C',
		ubreve: '\u016D',
		Ucirc: '\u00DB',
		ucirc: '\u00FB',
		Ucy: '\u0423',
		ucy: '\u0443',
		udarr: '\u21C5',
		Udblac: '\u0170',
		udblac: '\u0171',
		udhar: '\u296E',
		ufisht: '\u297E',
		Ufr: '\uD835\uDD18',
		ufr: '\uD835\uDD32',
		Ugrave: '\u00D9',
		ugrave: '\u00F9',
		uHar: '\u2963',
		uharl: '\u21BF',
		uharr: '\u21BE',
		uhblk: '\u2580',
		ulcorn: '\u231C',
		ulcorner: '\u231C',
		ulcrop: '\u230F',
		ultri: '\u25F8',
		Umacr: '\u016A',
		umacr: '\u016B',
		uml: '\u00A8',
		UnderBar: '\u005F',
		UnderBrace: '\u23DF',
		UnderBracket: '\u23B5',
		UnderParenthesis: '\u23DD',
		Union: '\u22C3',
		UnionPlus: '\u228E',
		Uogon: '\u0172',
		uogon: '\u0173',
		Uopf: '\uD835\uDD4C',
		uopf: '\uD835\uDD66',
		UpArrow: '\u2191',
		Uparrow: '\u21D1',
		uparrow: '\u2191',
		UpArrowBar: '\u2912',
		UpArrowDownArrow: '\u21C5',
		UpDownArrow: '\u2195',
		Updownarrow: '\u21D5',
		updownarrow: '\u2195',
		UpEquilibrium: '\u296E',
		upharpoonleft: '\u21BF',
		upharpoonright: '\u21BE',
		uplus: '\u228E',
		UpperLeftArrow: '\u2196',
		UpperRightArrow: '\u2197',
		Upsi: '\u03D2',
		upsi: '\u03C5',
		upsih: '\u03D2',
		Upsilon: '\u03A5',
		upsilon: '\u03C5',
		UpTee: '\u22A5',
		UpTeeArrow: '\u21A5',
		upuparrows: '\u21C8',
		urcorn: '\u231D',
		urcorner: '\u231D',
		urcrop: '\u230E',
		Uring: '\u016E',
		uring: '\u016F',
		urtri: '\u25F9',
		Uscr: '\uD835\uDCB0',
		uscr: '\uD835\uDCCA',
		utdot: '\u22F0',
		Utilde: '\u0168',
		utilde: '\u0169',
		utri: '\u25B5',
		utrif: '\u25B4',
		uuarr: '\u21C8',
		Uuml: '\u00DC',
		uuml: '\u00FC',
		uwangle: '\u29A7',
		vangrt: '\u299C',
		varepsilon: '\u03F5',
		varkappa: '\u03F0',
		varnothing: '\u2205',
		varphi: '\u03D5',
		varpi: '\u03D6',
		varpropto: '\u221D',
		vArr: '\u21D5',
		varr: '\u2195',
		varrho: '\u03F1',
		varsigma: '\u03C2',
		varsubsetneq: '\u228A\uFE00',
		varsubsetneqq: '\u2ACB\uFE00',
		varsupsetneq: '\u228B\uFE00',
		varsupsetneqq: '\u2ACC\uFE00',
		vartheta: '\u03D1',
		vartriangleleft: '\u22B2',
		vartriangleright: '\u22B3',
		Vbar: '\u2AEB',
		vBar: '\u2AE8',
		vBarv: '\u2AE9',
		Vcy: '\u0412',
		vcy: '\u0432',
		VDash: '\u22AB',
		Vdash: '\u22A9',
		vDash: '\u22A8',
		vdash: '\u22A2',
		Vdashl: '\u2AE6',
		Vee: '\u22C1',
		vee: '\u2228',
		veebar: '\u22BB',
		veeeq: '\u225A',
		vellip: '\u22EE',
		Verbar: '\u2016',
		verbar: '\u007C',
		Vert: '\u2016',
		vert: '\u007C',
		VerticalBar: '\u2223',
		VerticalLine: '\u007C',
		VerticalSeparator: '\u2758',
		VerticalTilde: '\u2240',
		VeryThinSpace: '\u200A',
		Vfr: '\uD835\uDD19',
		vfr: '\uD835\uDD33',
		vltri: '\u22B2',
		vnsub: '\u2282\u20D2',
		vnsup: '\u2283\u20D2',
		Vopf: '\uD835\uDD4D',
		vopf: '\uD835\uDD67',
		vprop: '\u221D',
		vrtri: '\u22B3',
		Vscr: '\uD835\uDCB1',
		vscr: '\uD835\uDCCB',
		vsubnE: '\u2ACB\uFE00',
		vsubne: '\u228A\uFE00',
		vsupnE: '\u2ACC\uFE00',
		vsupne: '\u228B\uFE00',
		Vvdash: '\u22AA',
		vzigzag: '\u299A',
		Wcirc: '\u0174',
		wcirc: '\u0175',
		wedbar: '\u2A5F',
		Wedge: '\u22C0',
		wedge: '\u2227',
		wedgeq: '\u2259',
		weierp: '\u2118',
		Wfr: '\uD835\uDD1A',
		wfr: '\uD835\uDD34',
		Wopf: '\uD835\uDD4E',
		wopf: '\uD835\uDD68',
		wp: '\u2118',
		wr: '\u2240',
		wreath: '\u2240',
		Wscr: '\uD835\uDCB2',
		wscr: '\uD835\uDCCC',
		xcap: '\u22C2',
		xcirc: '\u25EF',
		xcup: '\u22C3',
		xdtri: '\u25BD',
		Xfr: '\uD835\uDD1B',
		xfr: '\uD835\uDD35',
		xhArr: '\u27FA',
		xharr: '\u27F7',
		Xi: '\u039E',
		xi: '\u03BE',
		xlArr: '\u27F8',
		xlarr: '\u27F5',
		xmap: '\u27FC',
		xnis: '\u22FB',
		xodot: '\u2A00',
		Xopf: '\uD835\uDD4F',
		xopf: '\uD835\uDD69',
		xoplus: '\u2A01',
		xotime: '\u2A02',
		xrArr: '\u27F9',
		xrarr: '\u27F6',
		Xscr: '\uD835\uDCB3',
		xscr: '\uD835\uDCCD',
		xsqcup: '\u2A06',
		xuplus: '\u2A04',
		xutri: '\u25B3',
		xvee: '\u22C1',
		xwedge: '\u22C0',
		Yacute: '\u00DD',
		yacute: '\u00FD',
		YAcy: '\u042F',
		yacy: '\u044F',
		Ycirc: '\u0176',
		ycirc: '\u0177',
		Ycy: '\u042B',
		ycy: '\u044B',
		yen: '\u00A5',
		Yfr: '\uD835\uDD1C',
		yfr: '\uD835\uDD36',
		YIcy: '\u0407',
		yicy: '\u0457',
		Yopf: '\uD835\uDD50',
		yopf: '\uD835\uDD6A',
		Yscr: '\uD835\uDCB4',
		yscr: '\uD835\uDCCE',
		YUcy: '\u042E',
		yucy: '\u044E',
		Yuml: '\u0178',
		yuml: '\u00FF',
		Zacute: '\u0179',
		zacute: '\u017A',
		Zcaron: '\u017D',
		zcaron: '\u017E',
		Zcy: '\u0417',
		zcy: '\u0437',
		Zdot: '\u017B',
		zdot: '\u017C',
		zeetrf: '\u2128',
		ZeroWidthSpace: '\u200B',
		Zeta: '\u0396',
		zeta: '\u03B6',
		Zfr: '\u2128',
		zfr: '\uD835\uDD37',
		ZHcy: '\u0416',
		zhcy: '\u0436',
		zigrarr: '\u21DD',
		Zopf: '\u2124',
		zopf: '\uD835\uDD6B',
		Zscr: '\uD835\uDCB5',
		zscr: '\uD835\uDCCF',
		zwj: '\u200D',
		zwnj: '\u200C',
	});

	/**
	 * @deprecated
	 * Use `HTML_ENTITIES` instead.
	 * @see {@link HTML_ENTITIES}
	 */
	exports.entityMap = exports.HTML_ENTITIES; 
} (entities$2));

var entities$1 = /*@__PURE__*/getDefaultExportFromCjs(entities$2);

var sax$1 = {};

'use strict';

var conventions$2 = conventions$5;
var g = grammar;
var errors$2 = errors$4;

var isHTMLEscapableRawTextElement = conventions$2.isHTMLEscapableRawTextElement;
var isHTMLMimeType$2 = conventions$2.isHTMLMimeType;
var isHTMLRawTextElement = conventions$2.isHTMLRawTextElement;
var hasOwn = conventions$2.hasOwn;
var NAMESPACE$2 = conventions$2.NAMESPACE;
var ParseError$2 = errors$2.ParseError;
var DOMException$1 = errors$2.DOMException;

//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0; //tag name offerring
var S_ATTR = 1; //attr name offerring
var S_ATTR_SPACE = 2; //attr name end and space offer
var S_EQ = 3; //=space?
var S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)
var S_ATTR_END = 5; //attr value end and no space(quot end)
var S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7; //closed el<el />

function XMLReader$1() {}

XMLReader$1.prototype = {
	parse: function (source, defaultNSMap, entityMap) {
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap, (defaultNSMap = Object.create(null)));
		parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
		domBuilder.endDocument();
	},
};

/**
 * Detecting everything that might be a reference,
 * including those without ending `;`, since those are allowed in HTML.
 * The entityReplacer takes care of verifying and transforming each occurrence,
 * and reports to the errorHandler on those that are not OK,
 * depending on the context.
 */
var ENTITY_REG = /&#?\w+;?/g;

function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
	var isHTML = isHTMLMimeType$2(domBuilder.mimeType);
	if (source.indexOf(g.UNICODE_REPLACEMENT_CHARACTER) >= 0) {
		errorHandler.warning('Unicode replacement character detected, source encoding issues?');
	}

	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10),
				surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}

	function entityReplacer(a) {
		var complete = a[a.length - 1] === ';' ? a : a + ';';
		if (!isHTML && complete !== a) {
			errorHandler.error('EntityRef: expecting ;');
			return a;
		}
		var match = g.Reference.exec(complete);
		if (!match || match[0].length !== complete.length) {
			errorHandler.error('entity not matching Reference production: ' + a);
			return a;
		}
		var k = complete.slice(1, -1);
		if (hasOwn(entityMap, k)) {
			return entityMap[k];
		} else if (k.charAt(0) === '#') {
			return fixedFromCharCode(parseInt(k.substring(1).replace('x', '0x')));
		} else {
			errorHandler.error('entity not found:' + a);
			return a;
		}
	}

	function appendText(end) {
		//has some bugs
		if (end > start) {
			var xt = source.substring(start, end).replace(ENTITY_REG, entityReplacer);
			locator && position(start);
			domBuilder.characters(xt, 0, end - start);
			start = end;
		}
	}

	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /\r\n?|\n|$/g;
	var locator = domBuilder.locator;

	function position(p, m) {
		while (p >= lineEnd && (m = linePattern.exec(source))) {
			lineStart = lineEnd;
			lineEnd = m.index + m[0].length;
			locator.lineNumber++;
		}
		locator.columnNumber = p - lineStart + 1;
	}

	var parseStack = [{ currentNSMap: defaultNSMapCopy }];
	var unclosedTags = [];
	var start = 0;
	while (true) {
		try {
			var tagStart = source.indexOf('<', start);
			if (tagStart < 0) {
				if (!isHTML && unclosedTags.length > 0) {
					return errorHandler.fatalError('unclosed xml tag(s): ' + unclosedTags.join(', '));
				}
				if (!source.substring(start).match(/^\s*$/)) {
					var doc = domBuilder.doc;
					var text = doc.createTextNode(source.substring(start));
					if (doc.documentElement) {
						return errorHandler.error('Extra content at the end of the document');
					}
					doc.appendChild(text);
					domBuilder.currentElement = text;
				}
				return;
			}
			if (tagStart > start) {
				var fromSource = source.substring(start, tagStart);
				if (!isHTML && unclosedTags.length === 0) {
					fromSource = fromSource.replace(new RegExp(g.S_OPT.source, 'g'), '');
					fromSource && errorHandler.error("Unexpected content outside root element: '" + fromSource + "'");
				}
				appendText(tagStart);
			}
			switch (source.charAt(tagStart + 1)) {
				case '/':
					var end = source.indexOf('>', tagStart + 2);
					var tagNameRaw = source.substring(tagStart + 2, end > 0 ? end : undefined);
					if (!tagNameRaw) {
						return errorHandler.fatalError('end tag name missing');
					}
					var tagNameMatch = end > 0 && g.reg('^', g.QName_group, g.S_OPT, '$').exec(tagNameRaw);
					if (!tagNameMatch) {
						return errorHandler.fatalError('end tag name contains invalid characters: "' + tagNameRaw + '"');
					}
					if (!domBuilder.currentElement && !domBuilder.doc.documentElement) {
						// not enough information to provide a helpful error message,
						// but parsing will throw since there is no root element
						return;
					}
					var currentTagName =
						unclosedTags[unclosedTags.length - 1] ||
						domBuilder.currentElement.tagName ||
						domBuilder.doc.documentElement.tagName ||
						'';
					if (currentTagName !== tagNameMatch[1]) {
						var tagNameLower = tagNameMatch[1].toLowerCase();
						if (!isHTML || currentTagName.toLowerCase() !== tagNameLower) {
							return errorHandler.fatalError('Opening and ending tag mismatch: "' + currentTagName + '" != "' + tagNameRaw + '"');
						}
					}
					var config = parseStack.pop();
					unclosedTags.pop();
					var localNSMap = config.localNSMap;
					domBuilder.endElement(config.uri, config.localName, currentTagName);
					if (localNSMap) {
						for (var prefix in localNSMap) {
							if (hasOwn(localNSMap, prefix)) {
								domBuilder.endPrefixMapping(prefix);
							}
						}
					}

					end++;
					break;
				// end element
				case '?': // <?...?>
					locator && position(tagStart);
					end = parseProcessingInstruction(source, tagStart, domBuilder, errorHandler);
					break;
				case '!': // <!doctype,<![CDATA,<!--
					locator && position(tagStart);
					end = parseDoctypeCommentOrCData(source, tagStart, domBuilder, errorHandler, isHTML);
					break;
				default:
					locator && position(tagStart);
					var el = new ElementAttributes();
					var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
					//elStartEnd
					var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler, isHTML);
					var len = el.length;

					if (!el.closed) {
						if (isHTML && conventions$2.isHTMLVoidElement(el.tagName)) {
							el.closed = true;
						} else {
							unclosedTags.push(el.tagName);
						}
					}
					if (locator && len) {
						var locator2 = copyLocator(locator, {});
						//try{//attribute position fixed
						for (var i = 0; i < len; i++) {
							var a = el[i];
							position(a.offset);
							a.locator = copyLocator(locator, {});
						}
						domBuilder.locator = locator2;
						if (appendElement$1(el, domBuilder, currentNSMap)) {
							parseStack.push(el);
						}
						domBuilder.locator = locator;
					} else {
						if (appendElement$1(el, domBuilder, currentNSMap)) {
							parseStack.push(el);
						}
					}

					if (isHTML && !el.closed) {
						end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
					} else {
						end++;
					}
			}
		} catch (e) {
			if (e instanceof ParseError$2) {
				throw e;
			} else if (e instanceof DOMException$1) {
				throw new ParseError$2(e.name + ': ' + e.message, domBuilder.locator, e);
			}
			errorHandler.error('element parse error: ' + e);
			end = -1;
		}
		if (end > start) {
			start = end;
		} else {
			//Possible sax fallback here, risk of positional error
			appendText(Math.max(tagStart, start) + 1);
		}
	}
}

function copyLocator(f, t) {
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @returns
 * end of the elementStartPart(end of elementEndPart for selfClosed el)
 * @see {@link #appendElement}
 */
function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler, isHTML) {
	/**
	 * @param {string} qname
	 * @param {string} value
	 * @param {number} startIndex
	 */
	function addAttribute(qname, value, startIndex) {
		if (hasOwn(el.attributeNames, qname)) {
			return errorHandler.fatalError('Attribute ' + qname + ' redefined');
		}
		if (!isHTML && value.indexOf('<') >= 0) {
			return errorHandler.fatalError("Unescaped '<' not allowed in attributes values");
		}
		el.addValue(
			qname,
			// @see https://www.w3.org/TR/xml/#AVNormalize
			// since the xmldom sax parser does not "interpret" DTD the following is not implemented:
			// - recursive replacement of (DTD) entity references
			// - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
			value.replace(/[\t\n\r]/g, ' ').replace(ENTITY_REG, entityReplacer),
			startIndex
		);
	}

	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG; //status
	while (true) {
		var c = source.charAt(p);
		switch (c) {
			case '=':
				if (s === S_ATTR) {
					//attrName
					attrName = source.slice(start, p);
					s = S_EQ;
				} else if (s === S_ATTR_SPACE) {
					s = S_EQ;
				} else {
					//fatalError: equal must after attrName or space after attrName
					throw new Error('attribute equal must after attrName'); // No known test case
				}
				break;
			case "'":
			case '"':
				if (
					s === S_EQ ||
					s === S_ATTR //|| s == S_ATTR_SPACE
				) {
					//equal
					if (s === S_ATTR) {
						errorHandler.warning('attribute value must after "="');
						attrName = source.slice(start, p);
					}
					start = p + 1;
					p = source.indexOf(c, start);
					if (p > 0) {
						value = source.slice(start, p);
						addAttribute(attrName, value, start - 1);
						s = S_ATTR_END;
					} else {
						//fatalError: no end quot match
						throw new Error("attribute value no end '" + c + "' match");
					}
				} else if (s == S_ATTR_NOQUOT_VALUE) {
					value = source.slice(start, p);
					addAttribute(attrName, value, start);
					errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ')!!');
					start = p + 1;
					s = S_ATTR_END;
				} else {
					//fatalError: no equal before
					throw new Error('attribute value must after "="'); // No known test case
				}
				break;
			case '/':
				switch (s) {
					case S_TAG:
						el.setTagName(source.slice(start, p));
					case S_ATTR_END:
					case S_TAG_SPACE:
					case S_TAG_CLOSE:
						s = S_TAG_CLOSE;
						el.closed = true;
					case S_ATTR_NOQUOT_VALUE:
					case S_ATTR:
						break;
					case S_ATTR_SPACE:
						el.closed = true;
						break;
					//case S_EQ:
					default:
						throw new Error("attribute invalid close char('/')"); // No known test case
				}
				break;
			case '': //end document
				errorHandler.error('unexpected end of input');
				if (s == S_TAG) {
					el.setTagName(source.slice(start, p));
				}
				return p;
			case '>':
				switch (s) {
					case S_TAG:
						el.setTagName(source.slice(start, p));
					case S_ATTR_END:
					case S_TAG_SPACE:
					case S_TAG_CLOSE:
						break; //normal
					case S_ATTR_NOQUOT_VALUE: //Compatible state
					case S_ATTR:
						value = source.slice(start, p);
						if (value.slice(-1) === '/') {
							el.closed = true;
							value = value.slice(0, -1);
						}
					case S_ATTR_SPACE:
						if (s === S_ATTR_SPACE) {
							value = attrName;
						}
						if (s == S_ATTR_NOQUOT_VALUE) {
							errorHandler.warning('attribute "' + value + '" missed quot(")!');
							addAttribute(attrName, value, start);
						} else {
							if (!isHTML) {
								errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
							}
							addAttribute(value, value, start);
						}
						break;
					case S_EQ:
						if (!isHTML) {
							return errorHandler.fatalError('AttValue: \' or " expected');
						}
				}
				return p;
			/*xml space '\x20' | #x9 | #xD | #xA; */
			case '\u0080':
				c = ' ';
			default:
				if (c <= ' ') {
					//space
					switch (s) {
						case S_TAG:
							el.setTagName(source.slice(start, p)); //tagName
							s = S_TAG_SPACE;
							break;
						case S_ATTR:
							attrName = source.slice(start, p);
							s = S_ATTR_SPACE;
							break;
						case S_ATTR_NOQUOT_VALUE:
							var value = source.slice(start, p);
							errorHandler.warning('attribute "' + value + '" missed quot(")!!');
							addAttribute(attrName, value, start);
						case S_ATTR_END:
							s = S_TAG_SPACE;
							break;
						//case S_TAG_SPACE:
						//case S_EQ:
						//case S_ATTR_SPACE:
						//	void();break;
						//case S_TAG_CLOSE:
						//ignore warning
					}
				} else {
					//not space
					//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
					//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
					switch (s) {
						//case S_TAG:void();break;
						//case S_ATTR:void();break;
						//case S_ATTR_NOQUOT_VALUE:void();break;
						case S_ATTR_SPACE:
							if (!isHTML) {
								errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
							}
							addAttribute(attrName, attrName, start);
							start = p;
							s = S_ATTR;
							break;
						case S_ATTR_END:
							errorHandler.warning('attribute space is required"' + attrName + '"!!');
						case S_TAG_SPACE:
							s = S_ATTR;
							start = p;
							break;
						case S_EQ:
							s = S_ATTR_NOQUOT_VALUE;
							start = p;
							break;
						case S_TAG_CLOSE:
							throw new Error("elements closed character '/' and '>' must be connected to");
					}
				}
		} //end outer switch
		p++;
	}
}

/**
 * @returns
 * `true` if a new namespace has been defined.
 */
function appendElement$1(el, domBuilder, currentNSMap) {
	var tagName = el.tagName;
	var localNSMap = null;
	var i = el.length;
	while (i--) {
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if (nsp > 0) {
			var prefix = (a.prefix = qName.slice(0, nsp));
			var localName = qName.slice(nsp + 1);
			var nsPrefix = prefix === 'xmlns' && localName;
		} else {
			localName = qName;
			prefix = null;
			nsPrefix = qName === 'xmlns' && '';
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName;
		//prefix == null for no ns prefix attribute
		if (nsPrefix !== false) {
			//hack!!
			if (localNSMap == null) {
				localNSMap = Object.create(null);
				_copy(currentNSMap, (currentNSMap = Object.create(null)));
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = NAMESPACE$2.XMLNS;
			domBuilder.startPrefixMapping(nsPrefix, value);
		}
	}
	var i = el.length;
	while (i--) {
		a = el[i];
		if (a.prefix) {
			//no prefix attribute has no namespace
			if (a.prefix === 'xml') {
				a.uri = NAMESPACE$2.XML;
			}
			if (a.prefix !== 'xmlns') {
				a.uri = currentNSMap[a.prefix];
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if (nsp > 0) {
		prefix = el.prefix = tagName.slice(0, nsp);
		localName = el.localName = tagName.slice(nsp + 1);
	} else {
		prefix = null; //important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = (el.uri = currentNSMap[prefix || '']);
	domBuilder.startElement(ns, localName, tagName, el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if (el.closed) {
		domBuilder.endElement(ns, localName, tagName);
		if (localNSMap) {
			for (prefix in localNSMap) {
				if (hasOwn(localNSMap, prefix)) {
					domBuilder.endPrefixMapping(prefix);
				}
			}
		}
	} else {
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}

function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
	// https://html.spec.whatwg.org/#raw-text-elements
	// https://html.spec.whatwg.org/#escapable-raw-text-elements
	// https://html.spec.whatwg.org/#cdata-rcdata-restrictions:raw-text-elements
	// TODO: https://html.spec.whatwg.org/#cdata-rcdata-restrictions
	var isEscapableRaw = isHTMLEscapableRawTextElement(tagName);
	if (isEscapableRaw || isHTMLRawTextElement(tagName)) {
		var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);
		var text = source.substring(elStartEnd + 1, elEndStart);

		if (isEscapableRaw) {
			text = text.replace(ENTITY_REG, entityReplacer);
		}
		domBuilder.characters(text, 0, text.length);
		return elEndStart;
	}
	return elStartEnd + 1;
}

function _copy(source, target) {
	for (var n in source) {
		if (hasOwn(source, n)) {
			target[n] = source[n];
		}
	}
}

/**
 * @typedef ParseUtils
 * @property {function(relativeIndex: number?): string | undefined} char
 * Provides look ahead access to a singe character relative to the current index.
 * @property {function(): number} getIndex
 * Provides read-only access to the current index.
 * @property {function(reg: RegExp): string | null} getMatch
 * Applies the provided regular expression enforcing that it starts at the current index and
 * returns the complete matching string,
 * and moves the current index by the length of the matching string.
 * @property {function(): string} getSource
 * Provides read-only access to the complete source.
 * @property {function(places: number?): void} skip
 * moves the current index by places (defaults to 1)
 * @property {function(): number} skipBlanks
 * Moves the current index by the amount of white space that directly follows the current index
 * and returns the amount of whitespace chars skipped (0..n),
 * or -1 if the end of the source was reached.
 * @property {function(): string} substringFromIndex
 * creates a substring from the current index to the end of `source`
 * @property {function(compareWith: string): boolean} substringStartsWith
 * Checks if `source` contains `compareWith`, starting from the current index.
 * @property {function(compareWith: string): boolean} substringStartsWithCaseInsensitive
 * Checks if `source` contains `compareWith`, starting from the current index,
 * comparing the upper case of both sides.
 * @see {@link parseUtils}
 */

/**
 * A temporary scope for parsing and look ahead operations in `source`,
 * starting from index `start`.
 *
 * Some operations move the current index by a number of positions,
 * after which `getIndex` returns the new index.
 *
 * @param {string} source
 * @param {number} start
 * @returns {ParseUtils}
 */
function parseUtils(source, start) {
	var index = start;

	function char(n) {
		n = n || 0;
		return source.charAt(index + n);
	}

	function skip(n) {
		n = n || 1;
		index += n;
	}

	function skipBlanks() {
		var blanks = 0;
		while (index < source.length) {
			var c = char();
			if (c !== ' ' && c !== '\n' && c !== '\t' && c !== '\r') {
				return blanks;
			}
			blanks++;
			skip();
		}
		return -1;
	}
	function substringFromIndex() {
		return source.substring(index);
	}
	function substringStartsWith(text) {
		return source.substring(index, index + text.length) === text;
	}
	function substringStartsWithCaseInsensitive(text) {
		return source.substring(index, index + text.length).toUpperCase() === text.toUpperCase();
	}

	function getMatch(args) {
		var expr = g.reg('^', args);
		var match = expr.exec(substringFromIndex());
		if (match) {
			skip(match[0].length);
			return match[0];
		}
		return null;
	}
	return {
		char: char,
		getIndex: function () {
			return index;
		},
		getMatch: getMatch,
		getSource: function () {
			return source;
		},
		skip: skip,
		skipBlanks: skipBlanks,
		substringFromIndex: substringFromIndex,
		substringStartsWith: substringStartsWith,
		substringStartsWithCaseInsensitive: substringStartsWithCaseInsensitive,
	};
}

/**
 * @param {ParseUtils} p
 * @param {DOMHandler} errorHandler
 * @returns {string}
 */
function parseDoctypeInternalSubset(p, errorHandler) {
	/**
	 * @param {ParseUtils} p
	 * @param {DOMHandler} errorHandler
	 * @returns {string}
	 */
	function parsePI(p, errorHandler) {
		var match = g.PI.exec(p.substringFromIndex());
		if (!match) {
			return errorHandler.fatalError('processing instruction is not well-formed at position ' + p.getIndex());
		}
		if (match[1].toLowerCase() === 'xml') {
			return errorHandler.fatalError(
				'xml declaration is only allowed at the start of the document, but found at position ' + p.getIndex()
			);
		}
		p.skip(match[0].length);
		return match[0];
	}
	// Parse internal subset
	var source = p.getSource();
	if (p.char() === '[') {
		p.skip(1);
		var intSubsetStart = p.getIndex();
		while (p.getIndex() < source.length) {
			p.skipBlanks();
			if (p.char() === ']') {
				var internalSubset = source.substring(intSubsetStart, p.getIndex());
				p.skip(1);
				return internalSubset;
			}
			var current = null;
			// Only in external subset
			// if (char() === '<' && char(1) === '!' && char(2) === '[') {
			// 	parseConditionalSections(p, errorHandler);
			// } else
			if (p.char() === '<' && p.char(1) === '!') {
				switch (p.char(2)) {
					case 'E': // ELEMENT | ENTITY
						if (p.char(3) === 'L') {
							current = p.getMatch(g.elementdecl);
						} else if (p.char(3) === 'N') {
							current = p.getMatch(g.EntityDecl);
						}
						break;
					case 'A': // ATTRIBUTE
						current = p.getMatch(g.AttlistDecl);
						break;
					case 'N': // NOTATION
						current = p.getMatch(g.NotationDecl);
						break;
					case '-': // COMMENT
						current = p.getMatch(g.Comment);
						break;
				}
			} else if (p.char() === '<' && p.char(1) === '?') {
				current = parsePI(p, errorHandler);
			} else if (p.char() === '%') {
				current = p.getMatch(g.PEReference);
			} else {
				return errorHandler.fatalError('Error detected in Markup declaration');
			}
			if (!current) {
				return errorHandler.fatalError('Error in internal subset at position ' + p.getIndex());
			}
		}
		return errorHandler.fatalError('doctype internal subset is not well-formed, missing ]');
	}
}

/**
 * Called when the parser encounters an element starting with '<!'.
 *
 * @param {string} source
 * The xml.
 * @param {number} start
 * the start index of the '<!'
 * @param {DOMHandler} domBuilder
 * @param {DOMHandler} errorHandler
 * @param {boolean} isHTML
 * @returns {number | never}
 * The end index of the element.
 * @throws {ParseError}
 * In case the element is not well-formed.
 */
function parseDoctypeCommentOrCData(source, start, domBuilder, errorHandler, isHTML) {
	var p = parseUtils(source, start);

	switch (isHTML ? p.char(2).toUpperCase() : p.char(2)) {
		case '-':
			// should be a comment
			var comment = p.getMatch(g.Comment);
			if (comment) {
				domBuilder.comment(comment, g.COMMENT_START.length, comment.length - g.COMMENT_START.length - g.COMMENT_END.length);
				return p.getIndex();
			} else {
				return errorHandler.fatalError('comment is not well-formed at position ' + p.getIndex());
			}
		case '[':
			// should be CDATA
			var cdata = p.getMatch(g.CDSect);
			if (cdata) {
				if (!isHTML && !domBuilder.currentElement) {
					return errorHandler.fatalError('CDATA outside of element');
				}
				domBuilder.startCDATA();
				domBuilder.characters(cdata, g.CDATA_START.length, cdata.length - g.CDATA_START.length - g.CDATA_END.length);
				domBuilder.endCDATA();
				return p.getIndex();
			} else {
				return errorHandler.fatalError('Invalid CDATA starting at position ' + start);
			}
		case 'D': {
			// should be DOCTYPE
			if (domBuilder.doc && domBuilder.doc.documentElement) {
				return errorHandler.fatalError('Doctype not allowed inside or after documentElement at position ' + p.getIndex());
			}
			if (isHTML ? !p.substringStartsWithCaseInsensitive(g.DOCTYPE_DECL_START) : !p.substringStartsWith(g.DOCTYPE_DECL_START)) {
				return errorHandler.fatalError('Expected ' + g.DOCTYPE_DECL_START + ' at position ' + p.getIndex());
			}
			p.skip(g.DOCTYPE_DECL_START.length);
			if (p.skipBlanks() < 1) {
				return errorHandler.fatalError('Expected whitespace after ' + g.DOCTYPE_DECL_START + ' at position ' + p.getIndex());
			}

			var doctype = {
				name: undefined,
				publicId: undefined,
				systemId: undefined,
				internalSubset: undefined,
			};
			// Parse the DOCTYPE name
			doctype.name = p.getMatch(g.Name);
			if (!doctype.name)
				return errorHandler.fatalError('doctype name missing or contains unexpected characters at position ' + p.getIndex());

			if (isHTML && doctype.name.toLowerCase() !== 'html') {
				errorHandler.warning('Unexpected DOCTYPE in HTML document at position ' + p.getIndex());
			}
			p.skipBlanks();

			// Check for ExternalID
			if (p.substringStartsWith(g.PUBLIC) || p.substringStartsWith(g.SYSTEM)) {
				var match = g.ExternalID_match.exec(p.substringFromIndex());
				if (!match) {
					return errorHandler.fatalError('doctype external id is not well-formed at position ' + p.getIndex());
				}
				if (match.groups.SystemLiteralOnly !== undefined) {
					doctype.systemId = match.groups.SystemLiteralOnly;
				} else {
					doctype.systemId = match.groups.SystemLiteral;
					doctype.publicId = match.groups.PubidLiteral;
				}
				p.skip(match[0].length);
			} else if (isHTML && p.substringStartsWithCaseInsensitive(g.SYSTEM)) {
				// https://html.spec.whatwg.org/multipage/syntax.html#doctype-legacy-string
				p.skip(g.SYSTEM.length);
				if (p.skipBlanks() < 1) {
					return errorHandler.fatalError('Expected whitespace after ' + g.SYSTEM + ' at position ' + p.getIndex());
				}
				doctype.systemId = p.getMatch(g.ABOUT_LEGACY_COMPAT_SystemLiteral);
				if (!doctype.systemId) {
					return errorHandler.fatalError(
						'Expected ' + g.ABOUT_LEGACY_COMPAT + ' in single or double quotes after ' + g.SYSTEM + ' at position ' + p.getIndex()
					);
				}
			}
			if (isHTML && doctype.systemId && !g.ABOUT_LEGACY_COMPAT_SystemLiteral.test(doctype.systemId)) {
				errorHandler.warning('Unexpected doctype.systemId in HTML document at position ' + p.getIndex());
			}
			if (!isHTML) {
				p.skipBlanks();
				doctype.internalSubset = parseDoctypeInternalSubset(p, errorHandler);
			}
			p.skipBlanks();
			if (p.char() !== '>') {
				return errorHandler.fatalError('doctype not terminated with > at position ' + p.getIndex());
			}
			p.skip(1);
			domBuilder.startDTD(doctype.name, doctype.publicId, doctype.systemId, doctype.internalSubset);
			domBuilder.endDTD();
			return p.getIndex();
		}
		default:
			return errorHandler.fatalError('Not well-formed XML starting with "<!" at position ' + start);
	}
}

function parseProcessingInstruction(source, start, domBuilder, errorHandler) {
	var match = source.substring(start).match(g.PI);
	if (!match) {
		return errorHandler.fatalError('Invalid processing instruction starting at position ' + start);
	}
	if (match[1].toLowerCase() === 'xml') {
		if (start > 0) {
			return errorHandler.fatalError(
				'processing instruction at position ' + start + ' is an xml declaration which is only at the start of the document'
			);
		}
		if (!g.XMLDecl.test(source.substring(start))) {
			return errorHandler.fatalError('xml declaration is not well-formed');
		}
	}
	domBuilder.processingInstruction(match[1], match[2]);
	return start + match[0].length;
}

function ElementAttributes() {
	this.attributeNames = Object.create(null);
}

ElementAttributes.prototype = {
	setTagName: function (tagName) {
		if (!g.QName_exact.test(tagName)) {
			throw new Error('invalid tagName:' + tagName);
		}
		this.tagName = tagName;
	},
	addValue: function (qName, value, offset) {
		if (!g.QName_exact.test(qName)) {
			throw new Error('invalid attribute:' + qName);
		}
		this.attributeNames[qName] = this.length;
		this[this.length++] = { qName: qName, value: value, offset: offset };
	},
	length: 0,
	getLocalName: function (i) {
		return this[i].localName;
	},
	getLocator: function (i) {
		return this[i].locator;
	},
	getQName: function (i) {
		return this[i].qName;
	},
	getURI: function (i) {
		return this[i].uri;
	},
	getValue: function (i) {
		return this[i].value;
	},
	//	,getIndex:function(uri, localName)){
	//		if(localName){
	//
	//		}else{
	//			var qName = uri
	//		}
	//	},
	//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
	//	getType:function(uri,localName){}
	//	getType:function(i){},
};

var XMLReader_1 = sax$1.XMLReader = XMLReader$1;
var parseUtils_1 = sax$1.parseUtils = parseUtils;
var parseDoctypeCommentOrCData_1 = sax$1.parseDoctypeCommentOrCData = parseDoctypeCommentOrCData;

'use strict';

var conventions$1 = conventions$5;
var dom$1 = dom$2;
var errors$1 = errors$4;
var entities = entities$2;
var sax = sax$1;

var DOMImplementation$1 = dom$1.DOMImplementation;

var hasDefaultHTMLNamespace$1 = conventions$1.hasDefaultHTMLNamespace;
var isHTMLMimeType$1 = conventions$1.isHTMLMimeType;
var isValidMimeType$1 = conventions$1.isValidMimeType;
var MIME_TYPE$1 = conventions$1.MIME_TYPE;
var NAMESPACE$1 = conventions$1.NAMESPACE;
var ParseError$1 = errors$1.ParseError;

var XMLReader = sax.XMLReader;

/**
 * Normalizes line ending according to <https://www.w3.org/TR/xml11/#sec-line-ends>,
 * including some Unicode "newline" characters:
 *
 * > XML parsed entities are often stored in computer files which,
 * > for editing convenience, are organized into lines.
 * > These lines are typically separated by some combination
 * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
 * >
 * > To simplify the tasks of applications, the XML processor must behave
 * > as if it normalized all line breaks in external parsed entities (including the document entity)
 * > on input, before parsing, by translating the following to a single #xA character:
 * >
 * > 1. the two-character sequence #xD #xA,
 * > 2. the two-character sequence #xD #x85,
 * > 3. the single character #x85,
 * > 4. the single character #x2028,
 * > 5. the single character #x2029,
 * > 6. any #xD character that is not immediately followed by #xA or #x85.
 *
 * @param {string} input
 * @returns {string}
 * @prettierignore
 */
function normalizeLineEndings$1(input) {
	return input.replace(/\r[\n\u0085]/g, '\n').replace(/[\r\u0085\u2028\u2029]/g, '\n');
}

/**
 * @typedef Locator
 * @property {number} [columnNumber]
 * @property {number} [lineNumber]
 */

/**
 * @typedef DOMParserOptions
 * @property {typeof assign} [assign]
 * The method to use instead of `conventions.assign`, which is used to copy values from
 * `options` before they are used for parsing.
 * @property {typeof DOMHandler} [domHandler]
 * For internal testing: The class for creating an instance for handling events from the SAX
 * parser.
 * *****Warning: By configuring a faulty implementation, the specified behavior can completely
 * be broken.*****.
 * @property {Function} [errorHandler]
 * DEPRECATED! use `onError` instead.
 * @property {function(level:ErrorLevel, message:string, context: DOMHandler):void}
 * [onError]
 * A function invoked for every error that occurs during parsing.
 *
 * If it is not provided, all errors are reported to `console.error`
 * and only `fatalError`s are thrown as a `ParseError`,
 * which prevents any further processing.
 * If the provided method throws, a `ParserError` is thrown,
 * which prevents any further processing.
 *
 * Be aware that many `warning`s are considered an error that prevents further processing in
 * most implementations.
 * @property {boolean} [locator=true]
 * Configures if the nodes created during parsing will have a `lineNumber` and a `columnNumber`
 * attribute describing their location in the XML string.
 * Default is true.
 * @property {(string) => string} [normalizeLineEndings]
 * used to replace line endings before parsing, defaults to exported `normalizeLineEndings`,
 * which normalizes line endings according to <https://www.w3.org/TR/xml11/#sec-line-ends>,
 * including some Unicode "newline" characters.
 * @property {Object} [xmlns]
 * The XML namespaces that should be assumed when parsing.
 * The default namespace can be provided by the key that is the empty string.
 * When the `mimeType` for HTML, XHTML or SVG are passed to `parseFromString`,
 * the default namespace that will be used,
 * will be overridden according to the specification.
 * @see {@link normalizeLineEndings}
 */

/**
 * The DOMParser interface provides the ability to parse XML or HTML source code from a string
 * into a DOM `Document`.
 *
 * ***xmldom is different from the spec in that it allows an `options` parameter,
 * to control the behavior***.
 *
 * @class
 * @param {DOMParserOptions} [options]
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
 */
function DOMParser$1(options) {
	options = options || {};
	if (options.locator === undefined) {
		options.locator = true;
	}

	/**
	 * The method to use instead of `conventions.assign`, which is used to copy values from
	 * `options`
	 * before they are used for parsing.
	 *
	 * @type {conventions.assign}
	 * @private
	 * @see {@link conventions.assign}
	 * @readonly
	 */
	this.assign = options.assign || conventions$1.assign;

	/**
	 * For internal testing: The class for creating an instance for handling events from the SAX
	 * parser.
	 * *****Warning: By configuring a faulty implementation, the specified behavior can completely
	 * be broken*****.
	 *
	 * @type {typeof DOMHandler}
	 * @private
	 * @readonly
	 */
	this.domHandler = options.domHandler || DOMHandler;

	/**
	 * A function that is invoked for every error that occurs during parsing.
	 *
	 * If it is not provided, all errors are reported to `console.error`
	 * and only `fatalError`s are thrown as a `ParseError`,
	 * which prevents any further processing.
	 * If the provided method throws, a `ParserError` is thrown,
	 * which prevents any further processing.
	 *
	 * Be aware that many `warning`s are considered an error that prevents further processing in
	 * most implementations.
	 *
	 * @type {function(level:ErrorLevel, message:string, context: DOMHandler):void}
	 * @see {@link onErrorStopParsing}
	 * @see {@link onWarningStopParsing}
	 */
	this.onError = options.onError || options.errorHandler;
	if (options.errorHandler && typeof options.errorHandler !== 'function') {
		throw new TypeError('errorHandler object is no longer supported, switch to onError!');
	} else if (options.errorHandler) {
		options.errorHandler('warning', 'The `errorHandler` option has been deprecated, use `onError` instead!', this);
	}

	/**
	 * used to replace line endings before parsing, defaults to `normalizeLineEndings`
	 *
	 * @type {(string) => string}
	 * @readonly
	 */
	this.normalizeLineEndings = options.normalizeLineEndings || normalizeLineEndings$1;

	/**
	 * Configures if the nodes created during parsing will have a `lineNumber` and a
	 * `columnNumber`
	 * attribute describing their location in the XML string.
	 * Default is true.
	 *
	 * @type {boolean}
	 * @readonly
	 */
	this.locator = !!options.locator;

	/**
	 * The default namespace can be provided by the key that is the empty string.
	 * When the `mimeType` for HTML, XHTML or SVG are passed to `parseFromString`,
	 * the default namespace that will be used,
	 * will be overridden according to the specification.
	 *
	 * @type {Readonly<Object>}
	 * @readonly
	 */
	this.xmlns = this.assign(Object.create(null), options.xmlns);
}

/**
 * Parses `source` using the options in the way configured by the `DOMParserOptions` of `this`
 * `DOMParser`. If `mimeType` is `text/html` an HTML `Document` is created,
 * otherwise an XML `Document` is created.
 *
 * __It behaves different from the description in the living standard__:
 * - Uses the `options` passed to the `DOMParser` constructor to modify the behavior.
 * - Any unexpected input is reported to `onError` with either a `warning`,
 * `error` or `fatalError` level.
 * - Any `fatalError` throws a `ParseError` which prevents further processing.
 * - Any error thrown by `onError` is converted to a `ParseError` which prevents further
 * processing - If no `Document` was created during parsing it is reported as a `fatalError`.
 * *****Warning: By configuring a faulty DOMHandler implementation,
 * the specified behavior can completely be broken*****.
 *
 * @param {string} source
 * The XML mime type only allows string input!
 * @param {string} [mimeType='application/xml']
 * the mimeType or contentType of the document to be created determines the `type` of document
 * created (XML or HTML)
 * @returns {Document}
 * The `Document` node.
 * @throws {ParseError}
 * for any `fatalError` or anything that is thrown by `onError`
 * @throws {TypeError}
 * for any invalid `mimeType`
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString
 * @see https://html.spec.whatwg.org/#dom-domparser-parsefromstring-dev
 */
DOMParser$1.prototype.parseFromString = function (source, mimeType) {
	if (!isValidMimeType$1(mimeType)) {
		throw new TypeError('DOMParser.parseFromString: the provided mimeType "' + mimeType + '" is not valid.');
	}
	var defaultNSMap = this.assign(Object.create(null), this.xmlns);
	var entityMap = entities.XML_ENTITIES;
	var defaultNamespace = defaultNSMap[''] || null;
	if (hasDefaultHTMLNamespace$1(mimeType)) {
		entityMap = entities.HTML_ENTITIES;
		defaultNamespace = NAMESPACE$1.HTML;
	} else if (mimeType === MIME_TYPE$1.XML_SVG_IMAGE) {
		defaultNamespace = NAMESPACE$1.SVG;
	}
	defaultNSMap[''] = defaultNamespace;
	defaultNSMap.xml = defaultNSMap.xml || NAMESPACE$1.XML;

	var domBuilder = new this.domHandler({
		mimeType: mimeType,
		defaultNamespace: defaultNamespace,
		onError: this.onError,
	});
	var locator = this.locator ? {} : undefined;
	if (this.locator) {
		domBuilder.setDocumentLocator(locator);
	}

	var sax = new XMLReader();
	sax.errorHandler = domBuilder;
	sax.domBuilder = domBuilder;
	var isXml = !conventions$1.isHTMLMimeType(mimeType);
	if (isXml && typeof source !== 'string') {
		sax.errorHandler.fatalError('source is not a string');
	}
	sax.parse(this.normalizeLineEndings(String(source)), defaultNSMap, entityMap);
	if (!domBuilder.doc.documentElement) {
		sax.errorHandler.fatalError('missing root element');
	}
	return domBuilder.doc;
};

/**
 * @typedef DOMHandlerOptions
 * @property {string} [mimeType=MIME_TYPE.XML_APPLICATION]
 * @property {string | null} [defaultNamespace=null]
 */
/**
 * The class that is used to handle events from the SAX parser to create the related DOM
 * elements.
 *
 * Some methods are only implemented as an empty function,
 * since they are (at least currently) not relevant for xmldom.
 *
 * @class
 * @param {DOMHandlerOptions} [options]
 * @see http://www.saxproject.org/apidoc/org/xml/sax/ext/DefaultHandler2.html
 */
function DOMHandler(options) {
	var opt = options || {};
	/**
	 * The mime type is used to determine if the DOM handler will create an XML or HTML document.
	 * Only if it is set to `text/html` it will create an HTML document.
	 * It defaults to MIME_TYPE.XML_APPLICATION.
	 *
	 * @type {string}
	 * @see {@link MIME_TYPE}
	 * @readonly
	 */
	this.mimeType = opt.mimeType || MIME_TYPE$1.XML_APPLICATION;

	/**
	 * The namespace to use to create an XML document.
	 * For the following reasons this is required:
	 * - The SAX API for `startDocument` doesn't offer any way to pass a namespace,
	 * since at that point there is no way for the parser to know what the default namespace from
	 * the document will be.
	 * - When creating using `DOMImplementation.createDocument` it is required to pass a
	 * namespace,
	 * to determine the correct `Document.contentType`, which should match `this.mimeType`.
	 * - When parsing an XML document with the `application/xhtml+xml` mimeType,
	 * the HTML namespace needs to be the default namespace.
	 *
	 * @type {string | null}
	 * @private
	 * @readonly
	 */
	this.defaultNamespace = opt.defaultNamespace || null;

	/**
	 * @type {boolean}
	 * @private
	 */
	this.cdata = false;

	/**
	 * The last `Element` that was created by `startElement`.
	 * `endElement` sets it to the `currentElement.parentNode`.
	 *
	 * Note: The sax parser currently sets it to white space text nodes between tags.
	 *
	 * @type {Element | Node | undefined}
	 * @private
	 */
	this.currentElement = undefined;

	/**
	 * The Document that is created as part of `startDocument`,
	 * and returned by `DOMParser.parseFromString`.
	 *
	 * @type {Document | undefined}
	 * @readonly
	 */
	this.doc = undefined;

	/**
	 * The locator is stored as part of setDocumentLocator.
	 * It is controlled and mutated by the SAX parser to store the current parsing position.
	 * It is used by DOMHandler to set `columnNumber` and `lineNumber`
	 * on the DOM nodes.
	 *
	 * @type {Readonly<Locator> | undefined}
	 * @private
	 * @readonly (the
	 * sax parser currently sometimes set's it)
	 */
	this.locator = undefined;
	/**
	 * @type {function (level:ErrorLevel ,message:string, context:DOMHandler):void}
	 * @readonly
	 */
	this.onError = opt.onError;
}

function position(locator, node) {
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}

DOMHandler.prototype = {
	/**
	 * Either creates an XML or an HTML document and stores it under `this.doc`.
	 * If it is an XML document, `this.defaultNamespace` is used to create it,
	 * and it will not contain any `childNodes`.
	 * If it is an HTML document, it will be created without any `childNodes`.
	 *
	 * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
	 */
	startDocument: function () {
		var impl = new DOMImplementation$1();
		this.doc = isHTMLMimeType$1(this.mimeType) ? impl.createHTMLDocument(false) : impl.createDocument(this.defaultNamespace, '');
	},
	startElement: function (namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
		var el = doc.createElementNS(namespaceURI, qName || localName);
		var len = attrs.length;
		appendElement(this, el);
		this.currentElement = el;

		this.locator && position(this.locator, el);
		for (var i = 0; i < len; i++) {
			var namespaceURI = attrs.getURI(i);
			var value = attrs.getValue(i);
			var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator && position(attrs.getLocator(i), attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr);
		}
	},
	endElement: function (namespaceURI, localName, qName) {
		this.currentElement = this.currentElement.parentNode;
	},
	startPrefixMapping: function (prefix, uri) {},
	endPrefixMapping: function (prefix) {},
	processingInstruction: function (target, data) {
		var ins = this.doc.createProcessingInstruction(target, data);
		this.locator && position(this.locator, ins);
		appendElement(this, ins);
	},
	ignorableWhitespace: function (ch, start, length) {},
	characters: function (chars, start, length) {
		chars = _toString.apply(this, arguments);
		//console.log(chars)
		if (chars) {
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if (this.currentElement) {
				this.currentElement.appendChild(charNode);
			} else if (/^\s*$/.test(chars)) {
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator, charNode);
		}
	},
	skippedEntity: function (name) {},
	endDocument: function () {
		this.doc.normalize();
	},
	/**
	 * Stores the locator to be able to set the `columnNumber` and `lineNumber`
	 * on the created DOM nodes.
	 *
	 * @param {Locator} locator
	 */
	setDocumentLocator: function (locator) {
		if (locator) {
			locator.lineNumber = 0;
		}
		this.locator = locator;
	},
	//LexicalHandler
	comment: function (chars, start, length) {
		chars = _toString.apply(this, arguments);
		var comm = this.doc.createComment(chars);
		this.locator && position(this.locator, comm);
		appendElement(this, comm);
	},

	startCDATA: function () {
		//used in characters() methods
		this.cdata = true;
	},
	endCDATA: function () {
		this.cdata = false;
	},

	startDTD: function (name, publicId, systemId, internalSubset) {
		var impl = this.doc.implementation;
		if (impl && impl.createDocumentType) {
			var dt = impl.createDocumentType(name, publicId, systemId, internalSubset);
			this.locator && position(this.locator, dt);
			appendElement(this, dt);
			this.doc.doctype = dt;
		}
	},
	reportError: function (level, message) {
		if (typeof this.onError === 'function') {
			try {
				this.onError(level, message, this);
			} catch (e) {
				throw new ParseError$1('Reporting ' + level + ' "' + message + '" caused ' + e, this.locator);
			}
		} else {
			console.error('[xmldom ' + level + ']\t' + message, _locator(this.locator));
		}
	},
	/**
	 * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning: function (message) {
		this.reportError('warning', message);
	},
	error: function (message) {
		this.reportError('error', message);
	},
	/**
	 * This function reports a fatal error and throws a ParseError.
	 *
	 * @param {string} message
	 * - The message to be used for reporting and throwing the error.
	 * @returns {never}
	 * This function always throws an error and never returns a value.
	 * @throws {ParseError}
	 * Always throws a ParseError with the provided message.
	 */
	fatalError: function (message) {
		this.reportError('fatalError', message);
		throw new ParseError$1(message, this.locator);
	},
};

function _locator(l) {
	if (l) {
		return '\n@#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';
	}
}

function _toString(chars, start, length) {
	if (typeof chars == 'string') {
		return chars.substr(start, length);
	} else {
		//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if (chars.length >= start + length || start) {
			return new java.lang.String(chars, start, length) + '';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
'endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl'.replace(
	/\w+/g,
	function (key) {
		DOMHandler.prototype[key] = function () {
			return null;
		};
	}
);

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement(handler, node) {
	if (!handler.currentElement) {
		handler.doc.appendChild(node);
	} else {
		handler.currentElement.appendChild(node);
	}
}

/**
 * A method that prevents any further parsing when an `error`
 * with level `error` is reported during parsing.
 *
 * @see {@link DOMParserOptions.onError}
 * @see {@link onWarningStopParsing}
 */
function onErrorStopParsing$1(level) {
	if (level === 'error') throw 'onErrorStopParsing';
}

/**
 * A method that prevents any further parsing when any `error` is reported during parsing.
 *
 * @see {@link DOMParserOptions.onError}
 * @see {@link onErrorStopParsing}
 */
function onWarningStopParsing$1() {
	throw 'onWarningStopParsing';
}

var __DOMHandler = domParser$1.__DOMHandler = DOMHandler;
var DOMParser_1 = domParser$1.DOMParser = DOMParser$1;
var normalizeLineEndings_1 = domParser$1.normalizeLineEndings = normalizeLineEndings$1;
var onErrorStopParsing_1 = domParser$1.onErrorStopParsing = onErrorStopParsing$1;
var onWarningStopParsing_1 = domParser$1.onWarningStopParsing = onWarningStopParsing$1;

'use strict';
var conventions = conventions$5;
var assign = lib.assign = conventions.assign;
var hasDefaultHTMLNamespace = lib.hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
var isHTMLMimeType = lib.isHTMLMimeType = conventions.isHTMLMimeType;
var isValidMimeType = lib.isValidMimeType = conventions.isValidMimeType;
var MIME_TYPE = lib.MIME_TYPE = conventions.MIME_TYPE;
var NAMESPACE = lib.NAMESPACE = conventions.NAMESPACE;

var errors = errors$4;
var DOMException = lib.DOMException = errors.DOMException;
var DOMExceptionName = lib.DOMExceptionName = errors.DOMExceptionName;
var ExceptionCode = lib.ExceptionCode = errors.ExceptionCode;
var ParseError = lib.ParseError = errors.ParseError;

var dom = dom$2;
var Attr = lib.Attr = dom.Attr;
var CDATASection = lib.CDATASection = dom.CDATASection;
var CharacterData = lib.CharacterData = dom.CharacterData;
var Comment = lib.Comment = dom.Comment;
var Document = lib.Document = dom.Document;
var DocumentFragment = lib.DocumentFragment = dom.DocumentFragment;
var DocumentType = lib.DocumentType = dom.DocumentType;
var DOMImplementation = lib.DOMImplementation = dom.DOMImplementation;
var Element = lib.Element = dom.Element;
var Entity = lib.Entity = dom.Entity;
var EntityReference = lib.EntityReference = dom.EntityReference;
var LiveNodeList = lib.LiveNodeList = dom.LiveNodeList;
var NamedNodeMap = lib.NamedNodeMap = dom.NamedNodeMap;
var Node = lib.Node = dom.Node;
var NodeList = lib.NodeList = dom.NodeList;
var Notation = lib.Notation = dom.Notation;
var ProcessingInstruction = lib.ProcessingInstruction = dom.ProcessingInstruction;
var Text = lib.Text = dom.Text;
var XMLSerializer = lib.XMLSerializer = dom.XMLSerializer;

var domParser = domParser$1;
var DOMParser = lib.DOMParser = domParser.DOMParser;
var normalizeLineEndings = lib.normalizeLineEndings = domParser.normalizeLineEndings;
var onErrorStopParsing = lib.onErrorStopParsing = domParser.onErrorStopParsing;
var onWarningStopParsing = lib.onWarningStopParsing = domParser.onWarningStopParsing;

"use strict";

Object.defineProperty(utils, "__esModule", {
  value: true
});
var deepExploreArray_1 = utils.deepExploreArray = deepExploreArray;
var visitArrayItems_1 = utils.visitArrayItems = parseXMLResponse_1 = utils.parseXMLResponse = encodeForBatch_1 = utils.encodeForBatch = void 0;
var _xpath = _interopRequireDefault$3(xpath$1);
var _xmldom = lib;
function _interopRequireDefault$3(e) { return e && e.__esModule ? e : { default: e }; }
const encodeForBatch = textList => {
  return textList.map((text, i) => `<pre><a i="${i}">${text}</a></pre>`);
};
var encodeForBatch_1 = utils.encodeForBatch = encodeForBatch;
const parseXMLResponse = text => {
  let doc;
  try {
    doc = new _xmldom.DOMParser().parseFromString(text, _xmldom.MIME_TYPE.XML_APPLICATION);
  } catch (err) {
    console.error(err);
    return null;
  }
  const nodesWithTranslation = _xpath.default.select('//pre/*[not(self::i)]', doc);
  if (!nodesWithTranslation) return null;
  if (!Array.isArray(nodesWithTranslation)) throw new Error('Unexpected XML parsed result');
  return nodesWithTranslation.map(node => {
    // Select text in child nodes or in self
    const textNodes = _xpath.default.select('descendant-or-self::*/text()', node);
    if (!Array.isArray(textNodes)) return '';
    if (textNodes.length > 1) {
      console.debug('More than one text node found');
    }
    return textNodes.length === 0 ? '' : textNodes.map(node => node.nodeValue).join(' ');
  }).join(' ');
};
var parseXMLResponse_1 = utils.parseXMLResponse = parseXMLResponse;
function deepExploreArray(obj, depth) {
  let currentDepth = 0;
  let currentObj = obj;
  while (depth > currentDepth) {
    if (!Array.isArray(currentObj)) {
      throw new TypeError('Error while explore array on depth #' + String(currentDepth));
    }
    currentObj = currentObj[0];
    currentDepth++;
  }
  return currentObj;
}
/**
 * Visit each item in array recursively
 */
const visitArrayItems = (arr, visitor) => {
  arr.forEach(obj => {
    if (Array.isArray(obj)) {
      visitArrayItems(obj, visitor);
    } else {
      visitor(obj);
    }
  });
};
visitArrayItems_1 = utils.visitArrayItems = visitArrayItems;

"use strict";

Object.defineProperty(GoogleTranslator$1, "__esModule", {
  value: true
});
var GoogleTranslatorTokenFree_1 = GoogleTranslator$1.GoogleTranslatorTokenFree = GoogleTranslator_2 = GoogleTranslator$1.GoogleTranslator = AbstractGoogleTranslator_1 = GoogleTranslator$1.AbstractGoogleTranslator = void 0;
var _queryString = _interopRequireDefault$2(require$$0);
var _BaseTranslator$2 = BaseTranslator$1;
var _languages = languages;
var _token = token;
var _utils = utils;
function _interopRequireDefault$2(e) { return e && e.__esModule ? e : { default: e }; }
var __awaiter$5 = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/**
 * Common class for google translator implementations
 */
class AbstractGoogleTranslator extends _BaseTranslator$2.BaseTranslator {
  static isSupportedAutoFrom() {
    return true;
  }
  static getSupportedLanguages() {
    return _languages.languageAliases.getAll();
  }
  getLengthLimit() {
    return 4000;
  }
  getRequestsTimeout() {
    return 300;
  }
}
/**
 * Translator implementation which use Google API with token from https://translate.google.com
 */
var AbstractGoogleTranslator_1 = GoogleTranslator$1.AbstractGoogleTranslator = AbstractGoogleTranslator;
class GoogleTranslator extends AbstractGoogleTranslator {
  checkLimitExceeding(text) {
    if (Array.isArray(text)) {
      const encodedText = (0, _utils.encodeForBatch)(text).join('');
      const extra = encodedText.length - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    } else {
      const extra = text.length - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    }
  }
  translate(text, from, to) {
    return (0, _token.getToken)(text).then(({
      value: tk
    }) => {
      const apiPath = 'https://translate.google.com/translate_a/single';
      const data = {
        client: 't',
        sl: (0, _languages.getFixedLanguage)(from),
        tl: (0, _languages.getFixedLanguage)(to),
        hl: (0, _languages.getFixedLanguage)(to),
        dt: ['at', 'bd', 'ex', 'ld', 'md', 'qca', 'rw', 'rm', 'ss', 't'],
        ie: 'UTF-8',
        oe: 'UTF-8',
        otf: 1,
        ssel: 0,
        tsel: 0,
        kc: 7,
        q: text,
        tk
      };
      const url = apiPath + '?' + _queryString.default.stringify(data);
      return this.fetch(url, {
        responseType: 'json',
        method: 'GET',
        headers: this.options.headers
      }).then(rsp => rsp.data).then(rsp => {
        if (!(rsp instanceof Array) || !(rsp[0] instanceof Array)) {
          throw new Error('Unexpected response');
        }
        const translatedText = rsp[0].map(chunk => chunk instanceof Array && typeof chunk[0] === 'string' ? chunk[0] : '').join('');
        return translatedText;
      });
    });
  }
  translateBatch(text, from, to) {
    const preparedText = (0, _utils.encodeForBatch)(text);
    return (0, _token.getToken)(preparedText.join('')).then(({
      value: tk
    }) => {
      const apiPath = 'https://translate.googleapis.com/translate_a/t';
      const data = {
        anno: 3,
        client: 'te',
        v: '1.0',
        format: 'html',
        sl: (0, _languages.getFixedLanguage)(from),
        tl: (0, _languages.getFixedLanguage)(to),
        tk
      };
      const url = apiPath + '?' + _queryString.default.stringify(data);
      const body = preparedText.map(text => `&q=${encodeURIComponent(text)}`).join('');
      return this.fetch(url, {
        responseType: 'json',
        method: 'POST',
        headers: Object.assign({
          'Content-Type': 'application/x-www-form-urlencoded'
        }, this.options.headers),
        body
      }).then(rsp => rsp.data).then(rawResp => {
        try {
          if (!Array.isArray(rawResp)) {
            throw new Error('Unexpected response');
          }
          const isSingleResponseMode = text.length === 1;
          const result = [];
          (0, _utils.visitArrayItems)(rawResp, obj => {
            if (isSingleResponseMode && result.length === 1) return;
            if (typeof obj !== 'string') return;
            if (isSingleResponseMode) {
              const parsedText = (0, _utils.parseXMLResponse)(obj);
              result.push(parsedText || obj);
            } else {
              const parsedText = (0, _utils.parseXMLResponse)(obj);
              if (parsedText !== null) {
                result.push(parsedText);
              }
            }
          });
          if (result.length !== text.length) {
            throw new Error('Mismatching a lengths of original and translated arrays');
          }
          return result;
        } catch (err) {
          console.warn('Got response', rawResp);
          throw err;
        }
      });
    });
  }
}
var GoogleTranslator_2 = GoogleTranslator$1.GoogleTranslator = GoogleTranslator;
GoogleTranslator.translatorName = 'GoogleTranslator';
/**
 * Translator implementation which use Google API without token
 */
class GoogleTranslatorTokenFree extends AbstractGoogleTranslator {
  constructor() {
    super(...arguments);
    this.translate = (text, from, to) => __awaiter$5(this, void 0, void 0, function* () {
      const [translation] = yield this.translateBatch([text], from, to);
      return translation;
    });
  }
  translateBatch(text, from, to) {
    const apiPath = 'https://translate.googleapis.com/translate_a/t';
    const data = {
      client: 'dict-chrome-ex',
      sl: (0, _languages.getFixedLanguage)(from),
      tl: (0, _languages.getFixedLanguage)(to),
      q: text
    };
    const url = apiPath + '?' + _queryString.default.stringify(data);
    return this.fetch(url, {
      responseType: 'json',
      method: 'GET',
      headers: Object.assign({
        'Content-Type': 'application/x-www-form-urlencoded'
      }, this.options.headers)
    }).then(rsp => rsp.data).then(rawResp => {
      try {
        if (!Array.isArray(rawResp)) {
          throw new Error('Unexpected response');
        }
        const intermediateTextsArray = [];
        (0, _utils.visitArrayItems)(rawResp, obj => {
          if (typeof obj === 'string') {
            intermediateTextsArray.push(obj);
          }
        });
        const result = [];
        const isSingleResponseMode = text.length === 1;
        const isOneToOneMappingMode = intermediateTextsArray.length === text.length;
        for (let idx = 0; idx < intermediateTextsArray.length; idx++) {
          const text = intermediateTextsArray[idx];
          if (isSingleResponseMode) {
            result.push(text);
            break;
          }
          // Each second text it's not translation if not 1-1 mapping
          const isTranslation = isOneToOneMappingMode || Number(idx) % 2 === 0;
          if (isTranslation) {
            result.push(text);
          }
        }
        if (result.length !== text.length) {
          console.warn('Translation result', result);
          throw new Error('Mismatching a lengths of original and translated arrays');
        }
        return result;
      } catch (err) {
        console.warn('Got response', rawResp);
        throw err;
      }
    });
  }
}
GoogleTranslatorTokenFree_1 = GoogleTranslator$1.GoogleTranslatorTokenFree = GoogleTranslatorTokenFree;
GoogleTranslatorTokenFree.translatorName = 'GoogleTranslatorTokenFree';

var DeepLTranslator$1 = {};

"use strict";

Object.defineProperty(DeepLTranslator$1, "__esModule", {
  value: true
});
var DeepLTranslator_2 = DeepLTranslator$1.DeepLTranslator = void 0;
var _zod$4 = _interopRequireDefault$1(zod);
var _BaseTranslator$1 = BaseTranslator$1;
function _interopRequireDefault$1(e) { return e && e.__esModule ? e : { default: e }; }
var __awaiter$4 = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class DeepLTranslator extends _BaseTranslator$1.BaseTranslator {
  static getSupportedLanguages() {
    // eslint-disable
    // prettier-ignore
    return ['bg', 'cs', 'da', 'de', 'el', 'en', 'es', 'et', 'fi', 'fr', 'hu', 'id', 'it', 'ja', 'ko', 'lt', 'lv', 'nb', 'nl', 'pl', 'pt', 'ro', 'ru', 'sk', 'sl', 'sv', 'tr', 'uk', 'zh'];
    // eslint-enable
  }
  constructor(options) {
    super(options);
    // DeepL API Free authentication keys can be identified easily by the suffix ":fx"
    // Docs: https://www.deepl.com/docs-api/api-access/
    const isApiKeyFreeVersion = options.apiKey.endsWith(':fx');
    const apiHost = isApiKeyFreeVersion ? 'https://api-free.deepl.com' : 'https://api.deepl.com';
    this.apiHost = apiHost + '/v2/translate';
  }
  getLengthLimit() {
    return 5000;
  }
  getRequestsTimeout() {
    return 300;
  }
  checkLimitExceeding(text) {
    if (Array.isArray(text)) {
      const arrayLen = text.reduce((acc, text) => acc + text.length, 0);
      const extra = arrayLen - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    } else {
      const extra = text.length - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    }
  }
  translate(text, from, to) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.translateBatch([text], from, to).then(resp => resp[0]);
    });
  }
  translateBatch(text, from, to) {
    return __awaiter$4(this, void 0, void 0, function* () {
      // eslint-disable-next-line camelcase
      const requestBody = {
        text,
        target_lang: to
      };
      if (from !== 'auto') {
        requestBody['source_lang'] = from;
      }
      const stringifiedBody = Object.entries(requestBody).map(([key, value]) => {
        if (!Array.isArray(value)) return `${key}=${encodeURIComponent(value)}`;
        // Handle array parameters
        return value.map(t => `${key}=` + encodeURIComponent(t)).join('&');
      }).join('&');
      return this.fetch(this.apiHost, {
        responseType: 'json',
        method: 'POST',
        headers: Object.assign({
          Authorization: `DeepL-Auth-Key ${this.options.apiKey}`,
          'Content-Type': 'application/x-www-form-urlencoded'
        }, this.options.headers),
        body: stringifiedBody
      }).then(rsp => {
        return _zod$4.default.object({
          translations: _zod$4.default.object({
            text: _zod$4.default.string()
          }).array()
        }).transform(({
          translations
        }) => translations.map(({
          text
        }) => text)).parse(rsp.data, {
          error: () => 'Unexpected data'
        });
      });
    });
  }
}
DeepLTranslator_2 = DeepLTranslator$1.DeepLTranslator = DeepLTranslator;
DeepLTranslator.translatorName = 'DeepLTranslator';
DeepLTranslator.isRequiredKey = () => true;
DeepLTranslator.isSupportedAutoFrom = () => true;

var TartuNLPTranslator$1 = {};

"use strict";

Object.defineProperty(TartuNLPTranslator$1, "__esModule", {
  value: true
});
var TartuNLPTranslator_2 = TartuNLPTranslator$1.TartuNLPTranslator = void 0;
var _zod$3 = _interopRequireDefault(zod);
var _BaseTranslator = BaseTranslator$1;
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
var __awaiter$3 = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class TartuNLPTranslator extends _BaseTranslator.BaseTranslator {
  static isSupportedAutoFrom() {
    return false;
  }
  static getSupportedLanguages() {
    // eslint-disable
    // prettier-ignore
    return ["en", "et", "de", "lt", "lv", "fi", "ru", "no", "hu", "se"];
    // eslint-enable
  }
  getLengthLimit() {
    return 5000;
  }
  getRequestsTimeout() {
    return 300;
  }
  checkLimitExceeding(text) {
    if (Array.isArray(text)) {
      const arrayLen = text.reduce((acc, text) => acc + text.length, 0);
      const extra = arrayLen - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    } else {
      const extra = text.length - this.getLengthLimit();
      return extra > 0 ? extra : 0;
    }
  }
  translate(text, from, to) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.translateBatch([text], from, to).then(resp => resp[0]);
    });
  }
  translateBatch(text, from, to) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.fetch('https://api.tartunlp.ai/translation/v2', {
        responseType: 'json',
        method: 'POST',
        headers: Object.assign({
          'Content-Type': 'application/json'
        }, this.options.headers),
        body: JSON.stringify({
          text,
          src: from,
          tgt: to
        })
      }).then(rsp => {
        return _zod$3.default.object({
          result: _zod$3.default.string().array()
        }).parse(rsp.data, {
          error: () => 'Unexpected data'
        }).result;
      });
    });
  }
}
TartuNLPTranslator_2 = TartuNLPTranslator$1.TartuNLPTranslator = TartuNLPTranslator;
TartuNLPTranslator.translatorName = 'TartuNLPTranslator';

var LLMTranslators = {};

var ChatGPTLLMTranslator$1 = {};

var LLMTranslator$1 = {};

"use strict";

Object.defineProperty(LLMTranslator$1, "__esModule", {
  value: true
});
var getPrompt_1 = LLMTranslator$1.getPrompt = LLMTranslator_2 = LLMTranslator$1.LLMTranslator = void 0;
var _zod$2 = zod;
var __awaiter$2 = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const getPrompt = (text, from, to) => {
  // use full language name
  const langFormatter = new Intl.DisplayNames(['en'], {
    type: 'language'
  });
  const originLang = from == 'auto' ? 'auto' : langFormatter.of(from);
  const targetLang = langFormatter.of(to);
  return `You are a text translation service. I will provide an array of texts, and your task is to translate them from language ${originLang} to language ${targetLang}.
If I specify the source language as 'auto', you should automatically detect it and translate it into the target language I set.
The array in your response must be the same length as the one in the request. Do not add any explanations — translate strictly according to the content. 
Be careful when creating an array; it must be syntactically correct and do not change quotation marks. Return an array of translated texts while preserving their order.
Here is the JSON array of texts: ${JSON.stringify(text)}`;
};
getPrompt_1 = LLMTranslator$1.getPrompt = getPrompt;
class LLMTranslator {
  constructor(llm, options) {
    var _a, _b, _c, _d, _e, _f, _g;
    this.llm = llm;
    this.config = {
      retryLimit: (_b = (_a = options === null || options === void 0 ? void 0 : options.retryOptions) === null || _a === void 0 ? void 0 : _a.retryLimit) !== null && _b !== void 0 ? _b : 3,
      retryTimeout: (_d = (_c = options === null || options === void 0 ? void 0 : options.retryOptions) === null || _c === void 0 ? void 0 : _c.retryTimeout) !== null && _d !== void 0 ? _d : this.llm.getRequestsTimeout(),
      maxRetryTimeout: (_e = options === null || options === void 0 ? void 0 : options.retryOptions) === null || _e === void 0 ? void 0 : _e.maxRetryTimeout,
      retryBackoffFactor: (_f = options === null || options === void 0 ? void 0 : options.retryOptions) === null || _f === void 0 ? void 0 : _f.retryBackoffFactor,
      getPrompt: (_g = options === null || options === void 0 ? void 0 : options.getPrompt) !== null && _g !== void 0 ? _g : getPrompt
    };
  }
  translate(text, from, to) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const translated = yield this.translateBatch([text], from, to);
      return translated[0];
    });
  }
  translateBatch(text, from, to) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let attempt = 0;
      // Retry loop
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      while (true) {
        try {
          // first request without delay
          if (attempt > 0) {
            yield this.waitRetryDelay(attempt);
          }
          const response = yield this.llm.fetch(this.config.getPrompt(text, from, to));
          const validateResult = _zod$2.z.string().array().length(text.length, {
            message: 'The response must be the same length as the requested array'
          }).parse(JSON.parse(response));
          return validateResult;
        } catch (error) {
          attempt++;
          if (attempt >= this.config.retryLimit) throw error;
        }
      }
    });
  }
  getLengthLimit() {
    return this.llm.getLengthLimit();
  }
  getRequestsTimeout() {
    return this.llm.getRequestsTimeout();
  }
  checkLimitExceeding(text) {
    const plainText = Array.isArray(text) ? text.join('') : text;
    const extra = plainText.length - this.getLengthLimit();
    return extra > 0 ? extra : 0;
  }
  /**
   * Calculates retry delays: starts with retryTimeout,
   * then increases exponentially (retryTimeout * factor^n) up to maxRetryTimeout (default: 4000).
   * Default retryBackoffFactor: 1.5
   */
  waitRetryDelay(attempt) {
    var _a, _b;
    const maxTimeout = (_a = this.config.maxRetryTimeout) !== null && _a !== void 0 ? _a : 4000;
    const factor = (_b = this.config.retryBackoffFactor) !== null && _b !== void 0 ? _b : 1.5;
    const delay = Math.min(maxTimeout, this.config.retryTimeout * Math.pow(factor, attempt - 1));
    return new Promise(r => setTimeout(r, delay));
  }
}
var LLMTranslator_2 = LLMTranslator$1.LLMTranslator = LLMTranslator;

var ChatGPTLLMFetcher$1 = {};

"use strict";

Object.defineProperty(ChatGPTLLMFetcher$1, "__esModule", {
  value: true
});
var ChatGPTLLMResponseSchema_1 = ChatGPTLLMFetcher$1.ChatGPTLLMResponseSchema = ChatGPTLLMFetcher_2 = ChatGPTLLMFetcher$1.ChatGPTLLMFetcher = void 0;
var _zod$1 = zod;
var __awaiter$1 = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const ChatGPTLLMResponseSchema = ChatGPTLLMResponseSchema_1 = ChatGPTLLMFetcher$1.ChatGPTLLMResponseSchema = _zod$1.z.object({
  choices: _zod$1.z.object({
    message: _zod$1.z.object({
      content: _zod$1.z.string()
    })
  }).array().min(1)
});
class ChatGPTLLMFetcher {
  constructor({
    apiKey,
    model,
    apiOrigin
  }) {
    this.config = {
      apiKey: apiKey,
      model: model !== null && model !== void 0 ? model : 'gpt-4o-mini',
      apiOrigin: apiOrigin !== null && apiOrigin !== void 0 ? apiOrigin : 'https://api.openai.com'
    };
    this.apiUrl = new URL('/v1/chat/completions', this.config.apiOrigin).toString();
  }
  getLengthLimit() {
    return 5000;
  }
  getRequestsTimeout() {
    return 500;
  }
  fetch(prompt) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const response = yield fetch(this.apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          model: this.config.model,
          messages: [{
            role: 'user',
            content: prompt
          }]
        })
      });
      if (!response.ok) {
        throw new Error(`Request failed with status ${response.status}: ${response.statusText}`);
      }
      // validate response structure
      const parseResult = ChatGPTLLMResponseSchema.parse(yield response.json());
      // a list of chat completion choices, there can be more than one only if specified directly.
      // source: https://platform.openai.com/docs/api-reference/chat/object#chat/object-choices
      return parseResult.choices[0].message.content;
    });
  }
}
var ChatGPTLLMFetcher_2 = ChatGPTLLMFetcher$1.ChatGPTLLMFetcher = ChatGPTLLMFetcher;

"use strict";

Object.defineProperty(ChatGPTLLMTranslator$1, "__esModule", {
  value: true
});
var ChatGPTLLMTranslator_2 = ChatGPTLLMTranslator$1.ChatGPTLLMTranslator = void 0;
var _LLMTranslator$1 = LLMTranslator$1;
var _ChatGPTLLMFetcher = ChatGPTLLMFetcher$1;
class ChatGPTLLMTranslator extends _LLMTranslator$1.LLMTranslator {
  constructor(config) {
    var _a, _b, _c, _d;
    const llm = new _ChatGPTLLMFetcher.ChatGPTLLMFetcher({
      apiKey: config.apiKey,
      model: config.model,
      apiOrigin: config.apiOrigin
    });
    super(llm, {
      getPrompt: config.getPrompt,
      retryOptions: {
        retryLimit: (_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.retryLimit,
        retryTimeout: (_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.retryTimeout,
        maxRetryTimeout: (_c = config.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetryTimeout,
        retryBackoffFactor: (_d = config.retryOptions) === null || _d === void 0 ? void 0 : _d.retryBackoffFactor
      }
    });
  }
}
ChatGPTLLMTranslator_2 = ChatGPTLLMTranslator$1.ChatGPTLLMTranslator = ChatGPTLLMTranslator;
ChatGPTLLMTranslator.translatorName = 'ChatGPTLLMTranslator';
ChatGPTLLMTranslator.isRequiredKey = () => true;
ChatGPTLLMTranslator.isSupportedAutoFrom = () => true;
// ChatGPT docs don’t list supported languages for text models, we can use the list for text-to-speech instead
// source: https://platform.openai.com/docs/guides/text-to-speech#supported-languages
ChatGPTLLMTranslator.getSupportedLanguages = () => {
  // eslint-disable
  // prettier-ignore
  return ["ar", "bn", "bg", "zh", "hr", "cs", "da", "nl", "en", "et", "fa", "fi", "fr", "de", "el", "gu", "he", "hi", "hu", "id", "it", "ja", "kn", "ko", "lv", "lt", "ml", "mr", "no", "pl", "pt", "ro", "ru", "sr", "sk", "sl", "es", "sw", "sv", "ta", "te", "th", "tr", "uk", "ur", "vi"];
  // eslint-enable
};

var GeminiLLMTranslator$1 = {};

var GeminiLLMFetcher$1 = {};

"use strict";

Object.defineProperty(GeminiLLMFetcher$1, "__esModule", {
  value: true
});
var GeminiLLMResponseSchema_1 = GeminiLLMFetcher$1.GeminiLLMResponseSchema = GeminiLLMFetcher_2 = GeminiLLMFetcher$1.GeminiLLMFetcher = void 0;
var _zod = zod;
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const GeminiLLMResponseSchema = GeminiLLMResponseSchema_1 = GeminiLLMFetcher$1.GeminiLLMResponseSchema = _zod.z.object({
  candidates: _zod.z.object({
    content: _zod.z.object({
      parts: _zod.z.object({
        text: _zod.z.string()
      }).array()
    })
  }).array().min(1)
});
class GeminiLLMFetcher {
  constructor({
    apiKey,
    model,
    apiOrigin
  }) {
    this.config = {
      apiKey: apiKey,
      model: model !== null && model !== void 0 ? model : 'gemini-2.0-flash',
      apiOrigin: apiOrigin !== null && apiOrigin !== void 0 ? apiOrigin : `https://generativelanguage.googleapis.com`
    };
    this.url = new URL(`/v1beta/models/${this.config.model}:generateContent?key=${this.config.apiKey}`, this.config.apiOrigin).toString();
  }
  getLengthLimit() {
    return 5000;
  }
  getRequestsTimeout() {
    return 500;
  }
  fetch(prompt) {
    return __awaiter(this, void 0, void 0, function* () {
      const response = yield fetch(this.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            role: 'user',
            parts: [{
              text: prompt
            }]
          }]
        })
      });
      if (!response.ok) {
        throw new Error(`Request failed with status ${response.status}: ${response.statusText}`);
      }
      // validate response structure
      const parseResult = GeminiLLMResponseSchema.parse(yield response.json());
      // content.parts contains ordered segments that together may form a complete response from the LLM
      // each segment may contain different types of data (e.g., text, functions, etc.), we join all text parts to get the complete response
      // documentation source: https://ai.google.dev/api/caching#Content
      // join all parts in one string
      const text = parseResult.candidates[0].content.parts.map(part => part.text).join('');
      // for large, poorly structured code, the gemini add extraneous characters
      return text.replace(/^```json\s*?|\s*?```$/g, '').trim();
    });
  }
}
var GeminiLLMFetcher_2 = GeminiLLMFetcher$1.GeminiLLMFetcher = GeminiLLMFetcher;

"use strict";

Object.defineProperty(GeminiLLMTranslator$1, "__esModule", {
  value: true
});
var GeminiLLMTranslator_2 = GeminiLLMTranslator$1.GeminiLLMTranslator = void 0;
var _LLMTranslator = LLMTranslator$1;
var _GeminiLLMFetcher = GeminiLLMFetcher$1;
class GeminiLLMTranslator extends _LLMTranslator.LLMTranslator {
  constructor(config) {
    var _a, _b, _c, _d;
    const llm = new _GeminiLLMFetcher.GeminiLLMFetcher({
      apiKey: config.apiKey,
      model: config.model,
      apiOrigin: config.apiOrigin
    });
    super(llm, {
      getPrompt: config.getPrompt,
      retryOptions: {
        retryLimit: (_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.retryLimit,
        retryTimeout: (_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.retryTimeout,
        maxRetryTimeout: (_c = config.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetryTimeout,
        retryBackoffFactor: (_d = config.retryOptions) === null || _d === void 0 ? void 0 : _d.retryBackoffFactor
      }
    });
  }
}
GeminiLLMTranslator_2 = GeminiLLMTranslator$1.GeminiLLMTranslator = GeminiLLMTranslator;
GeminiLLMTranslator.translatorName = 'GeminiLLMTranslator';
GeminiLLMTranslator.isRequiredKey = () => true;
GeminiLLMTranslator.isSupportedAutoFrom = () => true;
// source: https://ai.google.dev/gemini-api/docs/models#supported-languages
GeminiLLMTranslator.getSupportedLanguages = () => {
  // eslint-disable
  // prettier-ignore
  return ["ar", "bn", "bg", "zh", "hr", "cs", "da", "nl", "en", "et", "fa", "fi", "fr", "de", "el", "gu", "he", "hi", "hu", "id", "it", "ja", "kn", "ko", "lv", "lt", "ml", "mr", "no", "pl", "pt", "ro", "ru", "sr", "sk", "sl", "es", "sw", "sv", "ta", "te", "th", "tr", "uk", "ur", "vi"];
  // eslint-enable
};

(function (exports) {
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _ChatGPTLLMTranslator = ChatGPTLLMTranslator$1;
	Object.keys(_ChatGPTLLMTranslator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _ChatGPTLLMTranslator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _ChatGPTLLMTranslator[key];
	    }
	  });
	});
	var _GeminiLLMTranslator = GeminiLLMTranslator$1;
	Object.keys(_GeminiLLMTranslator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _GeminiLLMTranslator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _GeminiLLMTranslator[key];
	    }
	  });
	});
	
} (LLMTranslators));

var index$1 = /*@__PURE__*/getDefaultExportFromCjs(LLMTranslators);

(function (exports) {
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _BaseTranslator = BaseTranslator$1;
	Object.keys(_BaseTranslator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _BaseTranslator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _BaseTranslator[key];
	    }
	  });
	});
	var _Translator = Translator;
	Object.keys(_Translator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _Translator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _Translator[key];
	    }
	  });
	});
	var _FakeTranslator = FakeTranslator$1;
	Object.keys(_FakeTranslator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _FakeTranslator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _FakeTranslator[key];
	    }
	  });
	});
	var _MicrosoftTranslator = MicrosoftTranslator$1;
	Object.keys(_MicrosoftTranslator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _MicrosoftTranslator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _MicrosoftTranslator[key];
	    }
	  });
	});
	var _YandexTranslator = YandexTranslator$1;
	Object.keys(_YandexTranslator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _YandexTranslator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _YandexTranslator[key];
	    }
	  });
	});
	var _GoogleTranslator = GoogleTranslator$1;
	Object.keys(_GoogleTranslator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _GoogleTranslator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _GoogleTranslator[key];
	    }
	  });
	});
	var _DeepLTranslator = DeepLTranslator$1;
	Object.keys(_DeepLTranslator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _DeepLTranslator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _DeepLTranslator[key];
	    }
	  });
	});
	var _TartuNLPTranslator = TartuNLPTranslator$1;
	Object.keys(_TartuNLPTranslator).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _TartuNLPTranslator[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _TartuNLPTranslator[key];
	    }
	  });
	});
	var _LLMTranslators = LLMTranslators;
	Object.keys(_LLMTranslators).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _LLMTranslators[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _LLMTranslators[key];
	    }
	  });
	});
	
} (translators));

var index = /*@__PURE__*/getDefaultExportFromCjs(translators);

translators.GoogleTranslatorTokenFree;
